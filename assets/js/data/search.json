[ { "title": "[Springboot] 페이징 + Fetch Join 쿼리로 OneToMany 할 때, 모든 엔티티를 불러오는 문제를 해결해보자", "url": "/posts/Springboot_FetchJoin+Paging_Problem/", "categories": "Springboot, DB", "tags": "CS, DB, N+1, Fetch Join, OneToMany", "date": "2023-03-30 12:00:00 +0900", "snippet": "문제 상황댓글이 일대다 매핑 된 게시글들을 페이지 단위로 불러오는 쿼리를 실행하면 OOM(메모리 초과) 문제가 발생하는 것을 확인했다.문제가 되는 엔티티와 쿼리문은 다음과 같다.게시글 엔티티 @Builder@Getter@AllArgsConstructor@NoArgsConstructor@Entitypublic class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; @Column private String title; @Column private String content; @OneToMany(mappedBy = \"post\") private final List&lt;Comment&gt; comments = new ArrayList&lt;&gt;(); public void addComment(Comment comment) { comments.add(comment); }} 댓글 엔티티 @Builder@Getter@AllArgsConstructor@NoArgsConstructor@Entitypublic class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; @Column private String content; @ManyToOne @JoinColumn(name = \"post_id\") private Post post;} 게시글 리포지토리 public interface PostRepository extends JpaRepository&lt;Post, Long&gt; { @Query(value = \"SELECT DISTINCT p FROM Post p JOIN FETCH p.comments WHERE p.content LIKE %:content%\", countQuery = \"SELECT COUNT(DISTINCT p) FROM Post p INNER JOIN p.comments WHERE p.content LIKE %:content%\") Page&lt;Post&gt; findByContentWithFetchJoin(String content, Pageable pageable);} 문제 원인문제는 아래의 상황에서 발생한다고 한다. OneToMany 매핑이 있는 엔티티 N+1 문제의 해결 방법인 Fetch Join을 사용 페이징 처리를 위해 Pageable 인터페이스를 사용이유는 다음과 같다.컬렉션을 조인할 때 생기는 같은 식별자의 엔티티들을 distinct 쿼리로 제거해주면, 불러온 엔티티의 개수가 달라져 페이지에 담을 엔티티가 부족해지게 된다.이런 상황이 발생하는 걸 막고자, JPA는 모든 엔티티를 불러와서 중복 제거를 하고, 그 후 페이지에 필요한 만큼 잘라내어 준다.이렇게 모든 엔티티를 불러오는 과정때문에 메모리 초과 문제가 발생한 것.출력된 쿼리문을 찾아보니, 엔티티를 모두 메모리에 올린다는 로그와 함께, 쿼리문에는 limit 같은 제한 조건이 걸려있지 않은 걸 확인했다.해결 방법Fetch Join이 아닌 Batch Size 를 설정해 N+1 문제를 해결하고, 쿼리문에서는 Fetch Join을 지워주면 된다.application.yaml spring:jpa: properties: hibernate: default_batch_fetch_size: 1000 게시글 리포지토리 public interface PostRepository extends JpaRepository&lt;Post, Long&gt; { @Query(value = \"SELECT p FROM Post p WHERE p.content LIKE %:content%\", countQuery = \"SELECT COUNT(p) FROM Post p WHERE p.content LIKE %:content%\") Page&lt;Post&gt; findByContentLike(String content, Pageable pageable);} 위와 같이 수정 한 후 쿼리문을 찾아보니, WARN 로그 없이 fetch first ? rows only 가 출력되는 것을 확인했다.참고 자료 The best way to fix the Hibernate “firstResult/maxResults specified with collection fetch; applying in memory!” warning message JPA Fetch 조인(join)과 페이징(paging) 처리 JPA에서 Fetch Join과 Pagination을 함께 사용할때 주의하자" }, { "title": "[CS] DB: 정규화란?", "url": "/posts/CS_DB_Normalization/", "categories": "CS, DB", "tags": "CS, DB, Normalization", "date": "2023-03-03 11:00:00 +0900", "snippet": "정규화정규화란, 관계형 데이터베이스의 설계에서 중복을 최소화하고, 독립적인 관계를 가진 속성을 분리시켜 데이터를 구조화하는 작업을 말한다.정규화의 기본 목표는 관련이 없는 함수 종속성은 별개의 릴레이션으로 표현하는 것이다. 함수적 종속이란, 어떤 릴레이션 R의 속성 X와 Y에 대해, X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, Y는 X에 함수적 종속이라고 한다. 학번을 알면 학생의 이름을 알 수 있는 것.정규형제1정규형릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(Atomic value)만으로 구성되어 있어 반복 그룹이 없는 상태를 말한다. 즉, 하나의 기본키에 두 개 이상의 값을 가지는 속성 집합이 있어서는 안된다는 것이다. 학번 이름 과목 번호 231701 석규 (AP010, AP011) 231702 상범 (AP010, AP120) 위 테이블은 과목 번호에 반복 그룹이 있기 때문에 제1정규형을 만족하지 못한 상태이다.제1정규형을 만족시키려면 아래와 같이 수정해주면 된다. 학번 이름 과목 번호 231701 석규 AP010 231701 석규 AP011 231702 상범 AP010 231702 상범 AP120 제2정규형릴레이션이 제1정규형을 만족하고, 부분 함수의 종속성이 제거된 형태를 말한다. 즉, 기본키가 아닌 모든 속성이 기본키에 함수 종속적이라는 것이다. 학번 과목 번호 지도 교수 성적 231701 AP010 현성 100 231701 AP011 수현 70 231702 AP010 현성 90 231702 AP120 정희 80 위 테이블에서 학생의 성적을 알기 위해 학생번호 + 과목이 필요하지만, 과목의 지도 교수를 알기 위해선 과목 번호만 알고 있으면 된다. 따라서 지도 교수는 과목에만 종속 되어 있는 부분적 종속을 가지고 있으므로, 제2정규형을 만족하지 못한 상태이다.제2정규형을 만족시키려면 아래와 같이 수정해야 한다. 학번 과목 번호 성적 231701 AP010 100 231701 AP011 70 231702 AP010 90 231702 AP120 80 과목 번호 지도 교수 AP010 현성 AP011 수현 AP010 현성 AP120 정희 제3정규형릴레이션이 제2정규형을 만족하고, 기본키가 아닌 모든 속성이 이행적 함수 종속이 없는 상태를 말한다. 이행적 함수 종속이란, A -&gt; B 와 B -&gt; C 일때, A -&gt; C 가 성립하는 것을 말한다. 학번 식권 ID 가격 231701 A1 6000 231702 B1 10000 231703 A1 6000 231704 A2 8000 위 테이블에서 각 학생은 1개의 식권만 선택할 수 있다고 할 때, 학번을 알면 선택한 식권을 알 수 있고, 식권을 알면 지불해야할 금액을 알 수 있기 때문에, 학번을 알면 학생이 지불해야할 금액을 알 수 있게 된다. 따라서 제3정규형을 만족하지 못한 상태이다.제3정규형을 만족시키려면 아래와 같이 수정해야 한다. 학번 식권 ID 231701 A1 231702 B1 231703 A1 231704 A2 식권 ID 가격 A1 6000 B1 10000 A1 6000 A2 8000 보이스/코드 정규형보이스/코드 정규형(BCNF)은 릴레이션이 제3정규형이고, 모든 결정자가 후보키인 상태를 말한다. 결정자란, 함수 종속 관계에서 특정 종속자를 결정짓는 요소를 말한다. X -&gt; Y일 때 X가 결정자, Y는 종속자이다. 학번 지도 교수 강의명 231701 현성 DB 231701 수현 운영체제 231702 상호 DB 231702 정희 인간과 사회 한 학생은 한 교수의 강의만 수강할 수 있고, 한 교수는 한 강의만 담당하고, 한 강의를 여러 교수가 맡을 수 있다고 할 때, (학번, 강의명) 또는 (학번, 지도 교수) 가 후보키가 되며, 이 때 새로운 교수가 새로운 강의를 맡는다고 할 때, 학번은 NULL이 되는 문제점이 발생한다. 즉, 지도 교수 속성이 결정자이지만 후보키가 아니므로, 지도 교수 속성을 분리해야 한다. 학번 지도 교수 231701 현성 231701 수현 231702 상호 231702 정희 지도 교수 강의명 현성 DB 수현 운영체제 상호 DB 정희 인간과 사회 참고 자료 데이터베이스 정규화(Normalization)란 10. 함수적 종속(Functional Dependency)" }, { "title": "[CS] DB: 키의 종류", "url": "/posts/CS_About_Key/", "categories": "CS, DB", "tags": "CS, DB, Key", "date": "2023-03-02 09:00:00 +0900", "snippet": "키데이터베이스에서 키란, 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플과 구별할 수 있는 유일한 기준이 되는 속성(Attribute)이다.종류키의 종류에는 5가지가 있다. 후보키 (Candidate key) 릴레이션(테이블)에서 각 튜플을 유일하게 식별할 수 있는 속성 또는 집합을 말한다. 후보키가 되려면 유일성과 최소성을 모두 만족해야 한다. 기본키 (Primary key) 기본키는 후보키 중에서 행을 식별하기 위해 특별히 선택된 키를 말한다. 기본키는 중복될 수 없으며, NULL값이 올 수 없다. 유일성과 최소성을 만족해야 한다. 기본키는 테이블당 오직 하나의 필드에만 설정할 수 있다. 기본키 제약 조건은 테이블의 데이터를 쉽고 빠르게 찾도록 도와주는 역할을 한다. 대체키 (Alternate key) 대체키는 기본키로 선택되지 않고 남은 후보키를 의미한다. 보조키라고도 부른다. 슈퍼키 (Super key) 슈퍼키는 관계의 행을 고유하게 식별할 수 있는 속성 또는 집합을 의미한다. 슈퍼키는 대상관계의 모든 속성이 함수 종속하는 속성의 집합으로 정의할 수 있다. 외래키 (Foreign key) 외래키는 두 테이블을 서로 연결하는데 사용되는 키이다 외래키가 포함된 테이블을 자식 테이블이라고 하고, 외래키 값을 제공하는 테이블을 부모 테이블이라 한다. 외래키는 데이터의 무결성을 유지하는데 사용된다. 부모와 자식 데이터 간의 논리적 관계를 일치시킨다는 것이다. 유일성과 최소성 유일성: 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질 여러 개의 튜플이 존재할 때 각각의 튜플을 서로 구분할 수 있어야 한다는 성질이다. 즉, 각각의 튜플은 유일해야 한다는 것이다. 예를 들어, (주민 번호, 나이, 주소, 혈액형)이라는 속성이 있을 때 나이, 주소, 혈액형은 충분히 중복될 수 있으나, 주민 번호는 모두 달라 중복될 수 없다. 주민 번호처럼 각각의 튜플을 구분할 수 있는 속성이 가진 성질을 유일성이라고 합니다. 최소성: 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질 키를 구성하는 속성들이 각 튜플을 구분하는데 꼭 필요한 속성들로만 구성된다는 성질이다. 예를 들어, [주민 번호, 이름, 나이]처럼 키가 구성되어 있다면, 이미 주민 번호로 해당 키를 식별할 수 있는데 이름과 나이가 포함되어 있기 때문에 최소성을 만족하지 못한다. 참고 자료 데이터베이스 키의 개념과 종류 [DB] 키의 종류, 최소성과 유일성" }, { "title": "[CS] DB: DB란 무엇인가?", "url": "/posts/CS_DatabaseBasic/", "categories": "CS, DB", "tags": "CS, DB, Entity, Attribute", "date": "2023-02-25 09:00:00 +0900", "snippet": "데이터베이스데이터베이스란, 일정한 규칙 혹은 규약을 통해 구조화 되어 저장되는 데이터의 모음이다. 그런 데이터를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)라고 하며, 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다. 또, 데이터베이스는 실시간 접근과 동시 공유가 가능하다.기초 용어 엔티티엔티티(Entity)는 사람, 장소, 물건 등 데이터베이스에서 관리 되는 여러 개의 속성을 지닌 명사를 의미한다. 예를 들어, 회원이라는 엔티티는 이름, 아이디, 주소, 전화번호 등의 속성이 있고, 이 중 서비스의 요구사항에 맞게 필요햔 것만 남고 나머지는 사라진다.엔티티는 약한 엔티티와 강한 엔티티로 나뉜다. 엔티티 A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면, 엔티티 A는 약한 엔티티, B는 강한 엔티티가 된다. 릴레이션릴레이션(Relation)은 DB에서 정보를 구분해 저장하는 기본 단위이다. 엔티티에 관한 데이터를 릴레이션에 담아 관리한다. 관계형 데이터베이스에서는 이를 ‘테이블’이라고 하고, NoSQL 데이터베이스에서는 ‘컬렉션’이라고 한다. 속성속성(Attribute)은 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보이다. 회원 정보에 이름, 아이디, 주소, 전화번호 등이 있다고 할 때, 만약 서비스 요구 사항에 주소가 없다면 주소는 속성으로 관리되지 않는 것이다. 도메인도메인(Domain)은 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합을 말한다. 회원 정보에 성별이라는 속성 있다면, 이 성별은 [남, 여]라는 도메인을 가지는 것이다. 스키마스키마(Schema)는 관계형 데이터베이스에서 데이터의 구조와 제약 조건에 관한 전반적인 명세를 정의한 것이다. 엔티티가 어떤 속성을 가지고, 그 속성에는 어떤 데이터가 들어있는지에 대한 정의와 제약 조건을 서술해 놓은 것이다. 관계관계(Relationship)은 관계형 데이터베이스에서 두 개의 엔티티가 존재의 형태로서나 행위로서 서로에게 부여된 연관성을 말한다. 회원 정보를 저장한 엔티티와, 수업 정보를 저장한 엔티티가 있을 때, 회원이 특정 수업을 들어 수업의 ID를 저장한다면, 두 엔티티 사이 관계가 성립된 것이다. 엔티티정의엔티티는, 앞에서 말했듯 데이터베이스에서 관리 되는 여러 개의 속성을 지닌 명사를 의미한다. 엔티티는 일반적으로 다음과 같은 특징을 가지고 있다. 엔티티가 사용되는 곳의 업무에서 필요하며 관리하고자 하는 정보이어야 한다. 엔티티가 포함하는 인스턴스에 대해 유일한 식별자로 식별이 가능해야 한다. 엔티티는 지속적으로 존재하는 두개 이상의 인스턴스들의 조합이어야 한다. 엔티티는 반드시 속성을 지녀야 한다. 엔티티는 업무 프로세스에 의해서 이용되어야 한다. 엔티티는 다른 엔티티와 최소 한 개 이상의 관계가 있어야 한다.분류엔티티는 실체 유형(유무형)에 따라 구분하거나, 엔티티의 발생 시점에 의해 분류될 수 있다. 실체 유형에 따른 분류 유형 엔티티(Tangible Entity): 물리적인 형태가 존재하는 엔티티이며 안정적이고 지속적으로 활용되는 엔티티이다. 개념 엔티티(Conceptual Entity): 물리적인 형태는 존재하지 않고 관리해야 할 개념적인 정보로 구분이 되는 엔티티이다. 사건 엔티티(Event Entity): 업무를 수행함에 따라 발생되는 엔티티이다. 발생 시점에 따른 분류 기본/키 엔티티(Fundamental/Key Entity): 해당 업무에 원래 존재하는 정보로, 다른 엔티티와의 관계에 의해 발생 또는 생성되지 않고 독립적으로 존재하는 엔티티이다. 이는 독립적으로 생성이 가능하며 다른 엔티티의 부모역할을 한다. 중심 엔티티(Main Entity): 기본 엔티티로 부터 발생되며, 업무에 있어서 중심적인 역할을 한다. 일반적으로 데이터 양이 많으며 다른 엔티티와의 관계를 통해 행위 엔티티를 생성한다. 행위 엔티티(Active Entity): 두 개 이상의 부모 엔티티로 부터 주로 발생되고, 엔티티의 내용이 자주 바뀌거나 데이터 양이 증감한다. 속성정의속성은 엔티티가 가지는 구체적이며 고유한 이름을 갖는 정보이다. 속성도 엔티티와 같이 다음과 같은 성질을 지니며, 이런 성질을 지니지 못한 속성은 적절하지 못한 속성일 확률이 높다. 엔티티와 마찬가지로 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다. 정규화 이론에 근간하여 정해진 주 식별자에 함수적 종속성을 가져야 한다. 쉽게 말해, 다양하게 존재하는 인스턴스들에 대해 유일하게 구별할 수 있는 주식별자를 통해서 식별될 수 있어야 한다는 것이다. 하나의 속성은 단 한 개의 값만을 가진다.분류 속성의 특성에 따른 분류 기본 속성(Basic Attribute): 업무 분석을 통해 바로 정의한 속성을 기본속성이라고 한다. 엔터티에 있어서 가장 일반적이고 많은 속성을 차지한다. 하지만 코드성 데이터, 엔터티를 식별하기 위해 부여된 일련번호, 그리고 다른 속성을 계산하거나 영향을 받아 생성된 속성등은 기본속성이 아니다. 설계 속성(Designed Attribute): 업무상 필요한 데이터 이외에 데이터 모델링을 위해, 업무를 규칙화하기 위해 새로 만들어지거나 변형된 속성을 설계 속성이라고 한다. 일반적으로 코드성 속성은 기존의 속성을 업무상 필요에 의해 변형하여 만든 설계 속성이다. 또한 일련번호와 같은 속성 또한 단일한 식별자를 부여하기 위해 모델 상에서 새롭게 정의하는 설계속성이다. 파생 속성(Derived Attribute): 다른 속성에 영향을 받아 발생하는 속성은 파생 속성이다. 일반적으로 계산된 값들이 이에 해당된다. 파생 속성은 가급적 적게 정의하는 것이 좋다. 엔티티 구성 방식에 따른 분류 PK(Primary Key) 속성: 엔터티를 유일하게 구분할 수 있는 속성을 PK 속성이라고 한다. FK(Foreign Key) 속성: 다른 엔터티와의 관계에 있어서 포함된 속성을 FK 속성이라고 한다. 일반 속성: 엔터티에 포함되어 있고, PK 또는 FK에 포함되지 않는 속성을 일반 속성이라고 한다. 예상 질문&lt;/details&gt; 데이터베이스는 무엇인가요?답변* 데이터베이스는 일정한 규칙, 혹은 규약을 통해 구조회되어 저장되는 데이터들의 모음입니다.* 이런 데이터들을 관리하는 통합 시스템을 DBMS 라 하고, 각각의 DBMS마다 정의된 쿼리 언어를 통해 삽입, 조회, 수정, 삭제 등을 수행할 수 있습니다. 참고 자료 [데이터베이스]릴레이션R,엔터티,테이블 등 데이터 모델링에 대한 용어 이야기. [DB 이론] #1_엔터티(Entity)와 속성(Attribute)" }, { "title": "[CS] OS: CPU 스케줄링 알고리즘", "url": "/posts/CS_CpuScheduler/", "categories": "CS, OS", "tags": "CS, OS, SchedulingAlgorithm, Starvation, Aging", "date": "2023-02-24 09:00:00 +0900", "snippet": "CPU 스케줄링 알고리즘CPU 스케줄러는 레디 큐에 존재하는 프로세스들을 특정한 우선순위를 기반으로 CPU를 할당받게 해주는 역할을 한다.스케줄링 알고리즘프로그램이 실행될 때 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄 것인지 결정한다. 이 알고리즘은 다음과 같은 항목들을 목표로 한다. CPU 이용률: CPU를 얼마나 잘 활용했는지 처리량: 단위시간 당 완료된 프로세스의 개수가 몇 개인지 총 처리 시간: 어떤 프로세스를 실행하는데 걸리는 시간이 얼마나 짧은지 대기 시간: 레디 큐에서 대기한 시간이 얼마나 짧은지 응답 시간: 시스템에 요청이 들어온 시간부터 첫 번째 응답이 발생하기까지의 시간이 얼마나 짧은지종류는 크게 두 가지로 나뉜다. 비선점형(Non-preemptive): 일단 CPU를 할당받으면 해당 프로세스가 끝날때까지 CPU를 빼앗기지 않는다. 선점형(Preemptive): 우선순위가 높은 작업이 오거나, 해당 작업이 더 우선되어야 한다고 판단되면 해당 작업에게서 CPU를 빼앗을 수 있다.비선점형 FCFS(First Come First Served)FCFS는 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘이다. 구현은 간단하나, 길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 ‘호위 효과(Convoy Effect)’가 발생한다는 단점이 있다. SJF(Shortest Job First)SJF는 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘이다. 최소 평균 대기 시간을 보장한다는 장점이 있으나, 긴 시간을 가진 프로세스가 실행되지 않는 ‘기아 현상(Starvation)’이 일어날 가능성이 있다는 단점이 있다. Priority Scheduling가장 높은 우선순위를 가진 프로세스에게 CPU를 할당해주는 방법이다. 오랜 대기시간을 가지고 있는 작업의 우선순위를 높이는 방법(Aging)을 통해 기아 현상을 해결한다는 장점이 있다.선점형 SRTF (Shortest Remaining Time First)SJF의 선점형 스케줄링 방식으로, 중간에 더 짧은 시간을 가진 작업이 들어오면 CPU를 내어주는 알고리즘이다. 처리량은 많아질 수 있으나, 역시 기아 현상이 일어난다. RR (Round Robin)라운드 로빈은 현대 컴퓨터가 쓰는 우선순위 스케줄링의 일종으로, 각 프로세스에게 동일한 할당 시간을 주고 그 시간에 작업이 끝나지 않으면 준비 큐로 돌아가는 알고리즘이다. 모든 프로세스는 ‘실행중인 프로세스의 개수 * 할당 시간’ 이내에 응답을 받을 수 있어 평균 응답시간이 짧다는 장점이 있다. 하지만 할당 시간을 너무 길게 설정하면 FCFS와 같아져 비효율적이어지고, 너무 짧게 설정하면 컨텍스트 스위칭이 너무 자주 일어나 오버헤드가 증가한다는 딜레마가 있다. MLQ (MultiLevel Queue)MLQ, 다단계 큐는 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 다른 스케줄링 알고리즘을 적용한 것을 말한다. 큐 간의 프로세스 이동이 안 되므로 스케줄링 부담은 적지만, 유연성이 떨어지기 때문에 우선순위가 낮은 프로세스는 기아 현상을 겪을 수 있다는 단점이 있다.&lt;/details&gt; CPU 스케줄링이 무엇인가요?답변* 프로그램이 실행되어 프로세스로 등록되고 나서 어떤 프로세스에 CPU 소유권을 줄 것인지를 특정한 알고리즘에 따라 결정하는 것을 말합니다.* 그 알고리즘은 프로세스가 CPU를 한 번 점유하고 나서, 다른 프로세스에게 소유권을 넘겨주는지의 여부에 따라 선점형, 비선점형으로 나눌 수 있습니다. 1. 비선점형 알고리즘에는 FCFS, SJF, Priority 스케줄링 등이 있고, 2. 선점형 알고리즘에는 SRFT, 라운드 로빈, 다단계 큐 등이 있습니다. 운영체제에서 기아란 무엇인가요?답변특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태를 말합니다. 운영체제에서 에이징은 무엇인가요?답변스케줄링 시스템에서 기아를 방지하기 위해 사용되는 기술입니다. 특정 프로세스의 우선순위가 낮아 무한정 기다리게 되는 경우, 한 번 양보하거나 기다린 시간에 비례하여 일정시간이 지나면 우선순위를 한 단계씩 높여 가까운 시간 내에 자원을 할당받도록 합니다.참고 자료 스케줄링(Scheduling) 개념 및 이해 [OS] 면접 준비" }, { "title": "[CS] OS: 멀티 프로세싱과 멀티 스레딩", "url": "/posts/CS_MultiProcess/", "categories": "CS, OS", "tags": "CS, OS, Multiprocess, Multithread, CriticalSection, Semaphore, Mutex, Deadlock", "date": "2023-02-23 09:00:00 +0900", "snippet": "멀티 프로세싱과 멀티 스레딩멀티 프로세싱멀티 프로세싱은 여러 개의 프로레스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것을 말한다. 이를 통해 하나 이상의 일을 병렬적으로 처리할 수 있으며, 프로세스 중 일부에 문제가 발생하더라도 다른 프로세스를 이용해 처리할 수 있어 신뢰성이 높다.프로세스는 모두 독립적인 메모리 공간을 할당 받기 때문에, 프로세스끼리 서로 데이터를 주고 받기 위해서는 IPC(Inter Process Communication)을 사용해야 한다. IPC는 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘으로, 종류로는 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐가 있는데, 이들 모두 이미 메모리를 공유하고 있는 스레드 보다는 속도가 떨어진다.멀티 스레딩멀티 스레딩은 프로세스 내 작업을 여러 개의 스레드로 처리하는 기법이다. 스레드끼리는 서로 자원을 공유하기 때문에 효율성이 높다는 장점이 있다. 한 스레드가 중단되어도 다른 스레드는 실행 상태일 수 있어 중단되지 않은 빠른 처리가 가능하다. 하지만 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있는 단점이 있다.이외에도 멀티 스레딩을 기반으로 프로그래밍할 때는 동일한 자원에 동시에 접근하는 동기화 작업에 신경써줘야 한다. 서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다.공유 자원과 임계 영역공유 자원굥유 자원(Shared resource)은 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일 등의 자원이나 변수 등을 의미한다. 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태라고 한다.임계 영역임계 영역(Critical section)은 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라질 수 있는 코드 영역을 말한다. 임계 영역에서 문제가 일어나지 않도록 하기 위해서 다음 세 가지 조건을 충족시켜 주어야 한다. 상호 배제(Mutual exclusion) - 하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다. 진행(Progress) - 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러 개라면 어느 것이 들어갈지 결정 해주어야 한다. 한정 대기(Bounded waiting) - 다른 프로세스의 기아를 방지하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 두어야 한다.임계 영역 문제를 해결하기 위한 방법은 크게 뮤텍스, 세마포어, 모니터 세 가지가 있다. 뮤텍스뮤텍스(Mutex)는 프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고, 사용한 후 unlock()을 통해 잠금을 해제하는 객체이다. 상태는 잠금과 잠금 해제만 존재하고, 잠금이 설정되면 다른 프로세스나 스레드는 잠긴 코드 영역에 접근할 수 없다. 세마포어세마포어(Semaphore)는 wait()으로 자신의 차례가 올 때 까지 기다리도록 하고, signal()로 다음 프로세스에게 순서를 넘기는 방식으로 공유 자원에 대한 접근을 처리하는 방법이다. 프로세스가 공유 자원에 접근하면 세마포어에서 wait() 작업을 수행하고, 해제하면 signal() 작업을 수행한다.종류로는 상태 값을 0과 1만을 가져 하나의 프로세스나 스레드만 접근 가능케 하는 바이너리 세마포어, 그 이상의 값을 가져 여러 자원에 대한 접근을 제어하는 데 사용하는 카운팅 세마포어가 있다. 모니터모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 방식이다. 모니터는 모니터 큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리한다.교착 상태교착 상태(deadlock)란, 두 개 이상의 프로세스들이 서로가 가진 자원이 해제되길 기다리며 실행이 중단된 상태를 말한다.교착 상태가 되기 위한 조건은 네 가지로, 한 가지만 달성되지 않아도 교착 상태는 일어나지 않는다. 비선점 (Nonpreemptive) : 다른 프로세스의 자원을 뺏을 수 없음. 상호 배제(Mutual Exclusion) : 한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우. 순환 대기 (Circular wait) : 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조. 점유 대기 (Hold &amp; Wait) : 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.교착 상태를 해결하기 위한 방법은 다음과 같다 예방: 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계한다. 회피: 안정 상태, 즉 교착 상태 가능성이 없을 때만 자원을 할당하며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 ‘은행원 알고리즘’을 사용한다. 탐지: 교착 상태가 발생하면 사이클이 있는지 찾아보고, 이에 관련된 프로세스를 하나씩 지운다. 무시: 교착 상태는 드물게 일어나고 탐지하거나 예방하는 비용이 매우 크기 때문에, 이를 무시하고 특별한 조치를 취하지 않는 방법이다.예상 질문 멀티 프로세싱과 멀티 스레딩의 차이점을 설명해주세요.답변1. 멀티 프로세싱과 멀티 스레딩 모두 여러 개의 작업을 동시에, 혹은 병렬로 처리할 수 있도록 해주는 것을 말합니다.2. 멀티 프로세싱은 프로세스를 여러 개 생성해 작업을 처리하는 방법으로, * 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만, * 멀티 스레딩보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다.3. 멀티 스레딩은 하나의 프로세스 내에 여러 개의 스레드를 생성해 작업을 처리하는 방법으로, * 멀티 프로세싱보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, * 하나의 스레드에 문제가 생기면 전체 스레드가 영향을 받는다는 점과, 같은 자원을 공유하기 때문에 스레드 세이프 처리(임계 영역의 자원에 대한 동기화 처리)를 해주어야 한다는 단점이 있습니다. 스레드 세이프가 무엇인지 설명해 주세요.답변스레드 세이프란, 임계 영역에 있는 자원이 여러 스레드로부터 동시 다발적인 접근이 일어나도 경쟁 상태가 발생하지 않고 프로그램이 의도대로 실행되는 것을 말합니다. 경쟁 상태가 무엇인지 설명해 주세요.답변경쟁 상태는 두 개 이상의 프로세스나 스레드가 공유 자원을 동시에 읽거나 써, 프로그램이 의도된 대로 실행되지 않는 것을 의미합니다. 은행에 천원을 입금하는 작업 두 건이 동시에 발생하는 경우에, 원래라면 이천원이 추가되어야 하지만, 하나의 결과가 처리되기 전에 잔고를 읽어들임으로 둘 모두 천원을 추가한 결과를 저장하는 것입니다. 임계 영역이 무엇인지 설명해 주세요.답변1. 임계 영역은 둘 이상의 프로세스 또는 스레드가 공유 자원에 접근할 때, 순서 등의 이유로 결과가 달라질 수 있는 코드 영역을 말합니다. 2. 임계 영역 문제를 예방하기 위해서는 세가지 조건을 만족시켜줘야 합니다.3. 첫 번째 조건은 상호 배제로, 하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없도록 해야 합니다.4. 두 번째 조건은 진행으로, 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러 개라면 어느 것이 먼저 들어갈지 결정 해주어야 합니다.5. 세 번째 조건은 한정 대기로, 임계 구역에 들어갔던 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 두어야 합니다. 임계영역 문제를 해결하기 위한 방법에는 무엇이 있나요?답변* 대표적으로 뮤텍스, 세마포어, 모니터 세 가지 방식이 있습니다.1. 뮤텍스는 * 동기화 할 자원이 하나일 때 사용하는 방법으로, * 임계 영역에 들어간 프로세스가 자원을 점유하며 lock()을 호출해 잠금을 걸고, unlock()을 호출해 자원을 해제하는 방식입니다.2. 세마포어는 * 동기화 할 자원이 하나 이상일 때 사용할 수 있는 방법으로, * 임계 영역에 들어갈 때 wait()을 호출해 진입을 알려 진입 가능 숫자를 줄이고, 나올 때 signal()을 호출해 숫자를 다시 늘리는 방식입니다. * 진입 가능 숫자가 0 과 1로 이루어져 하나의 프로세스만 진입하게 하는 바이너리 세마포어, 그 이상의 숫자로 설정해 여러 프로세스가 진입할 수 있도록 하는 카운팅 세마포어가 있습니다.3. 모니터는 * 프레임워크나 라이브러리 차원에서 제공하는 방법으로, * 공유 자원을 특정 인터페이스로만 진입할 수 있도록 하고, 진입을 큐로 관리해 순서대로 접근할 수 있도록 하는 방법입니다. * 자바는 이 방식을 사용하며, synchronized 키워드를 사용해 관리합니다. 교착 상태가 무엇인지 설명해 주세요.답변교착 상태란, 두 개 이상의 프로세스들이 서로가 가진 자원이 해제되길 기다리며 실행이 중단된 상태를 말합니다. 교착 상태의 조건에는 무엇이 있나요?답변* 교착 상태가 되기 위한 조건은 네 가지로, 그 중 한 가지만 달성되지 않아도 교착 상태는 일어나지 않습니다.1. 첫 번째는 비선점으로, 다른 프로세스가 가진 자원을 뺏을 수 없다는 조건입니다.2. 두 번째는 상호 배제로, 한 번에 한 프로세스만 공유 자원에 접근 가능하다는 조건입니다.3. 세 번째는 순환 대기로, 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 그 관계가 순환적인 구조로 되어 있다는 조건입니다.4. 네 번째는 점유 대기로, 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구한다는 조건입니다. 교착 상태는 어떻게 해결하나요?답변* 교착 상태를 해결하는 방법은 예방, 회피, 탐지, 무시 네 가지가 있습니다.1. 예방은 자원을 할당할 때에 애초에 교착 상태 조건 네 가지중 하나를 부정함으로 해결하는 방법입니다.2. 회피는 자원을 할당해도 다른 프로세스에게 할당할 자원이 남아있도록 교착 상태가 일어날 가능성 자체를 회피하는 방법입니다.3. 탐지는 교착 상태가 발생했을 때 사이클을 찾아보고, 사이클에 관련된 프로세스를 하나씩 종료하며 해결하는 방법입니다.4. 무시는 교착 상태는 매우 드물게 일어나고, 다른 방법을 사용할 때 드는 오버헤드가 크므로 아예 무시하는 방법입니다.참고 자료 [OS] 멀티 프로세스와 멀티 스레드의 차이는 무엇일까? [OS] 교착상태(Deadlock, 데드락)의 정의, 발생 조건, 해결 방법 신입 개발자 기술면접 질문 정리 - 운영체제" }, { "title": "[CS] OS: 프로세스란?", "url": "/posts/CS_About_Process/", "categories": "CS, OS", "tags": "CS, OS, Process, Thread, ContextSwitching, PCB", "date": "2023-02-22 09:00:00 +0900", "snippet": "프로세스와 스레드프로세스프로세스란, 실행 중에 있는 프로그램을 의미한다. ‘스케줄링의 대상이 되는 작업’과 같은 의미로 쓰인다. 프로세스 내부에는 최소 하나의 스레드(Thread)를 가지고있는데, 실제로는 스레드단위로 스케줄링을 한다.하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 프로세스라 불린다.메모리 구조프로세스는 다음과 같은 메모리 구조를 가지며, 모든 프로세스마다 내부에 같은 구조를 지니고 있다.높은 메모리 주소부터, 스택(Stack), 힙(Heap), 데이터 영역, 코드 영역으로 나눠진다. 스택과 힙스택과 힙은 런타임 단계에 동적으로 메모리를 할당받는 데이터들이 저장되는 영역이다. 스택에는 지역변수, 매개변수, 함수의 호출 정보 등이 계속해서 저장된다. 힙에는 동적으로 할당되는 변수들이 저장된다. 데이터와 코드 영역데이터 영역과 코드 영역은 컴파일 단계에 정적으로 메모리를 할당받는 데이터들이 저장되는 영역이다. 데이터 영역에는 전역 변수, static 이나 const로 선언되는 변수들이 저장된다. 코드 영역에는 프로그램을 실행시키는 실행 파일 내의 명령어들, 즉 코드가 저장된다.스레드스레드는 프로세스의 실행 가능한 가장 작은 단위이다. 하나의 프로세스는 여러 스레드를 가질 수 있다.코드, 데이터, 스택, 힙을 각각 생성하는 프로세스와 달리 스레드는 코드, 데이터, 힙은 공유하되, 그 외 스택 등의 영역은 각각 생성된다.상태 변화컴퓨터에서 하나의 코어에 실행되는 프로세스는 하나이기 때문에, 다음과 같은 여러가지 상태 값으로 실행 여부를 표현한다.프로세스의 상태는 크게 실행 상태, 비실행 상태로 구분된다. 프로세스의 실행 상태와 비실행 상태는 준비, 실행, 대기로 구분될 수 있으며, 프로세스는 준비, 실행, 대기로 변화하면서 종료가 된다. 준비 -&gt; 실행 (Dispatch)준비 큐 맨 앞에 있던 프로세스가 프로세서를 점유 하는 것. 실행 -&gt; 준비 (Timeout)프로세스가 프로세서를 독점하지 못 하도록 인터럽트 클록을 두어 특정 시간동안만 (할당된 시간만큼만) 프로세서를 점유하게 한다. 실행 -&gt; 대기 (Block) 할당된 시간 이전에 실행상태의 프로세스에 입출력 연산 등이 필요하거나 새로운 자원 요청의 문제로 프로세서를 스스로 양도하는 상태 대기 -&gt; 준비 (Wakeup)block 상태의 프로세스가 입출력 작업이 끝나면 대기에서 준비 상태가 된다. 컨텍스트 스위칭컨텍스트 스위칭(Context Switching)이란, 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 작업의 상태를 PCB에 저장하고, 다음에 진행할 작업의 상태 값을 읽어 적용하는 과정을 말한다.컨텍스트 스위칭 과정은 간단하다. 프로세스 P1의 실행 정보를 PCB1에 저장한다. 프로세스 P2의 PCB2를 불러와 실행한다. 프로세스 P2의 실행 정보를 PCB2에 저장한다. 프로세스 P1의 PCB1을 불러와 실행한다.컨텍스트 스위칭에는 많은 비용이 소모된다. PCB를 저장하고 불러오는 과정에서 발생하는 유휴(Idle) 시간 이전 프로세스의 메모리 주소와 캐시를 초기화 하는데 발생하는 시간 캐시가 초기화 되면서 발생할 캐시미스만약 스레드 간에 컨텍스트 스위칭이 일어난다면, 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 비용이 적고, 시간도 적게 걸린다.PCBPCB(Process Control Block)이란, 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓은 것으로, 프로세스의 상태 정보를 저장한 ‘데이터’를 말한다. 프로그램이 실행되면 프로세스가 생성되고, 프로세스 주소 값들에 스택, 힙 등의 구조를 기반으로 메모리가 할당되는데, 이 데이터들이 PCB에 저장되어 관리되는 것이다.PCB에는 다음과 같은 내용이 저장된다: Process State: 생성, 준비, 실행, 대기, 종료 중에 해당하는 상태 정보를 저장한다. Process Number: 프로세스의 아이디 정보를 저장한다. Process Counter: 다음에 실행할 명령어의 주소를 가리키는 카운터를 저장한다. CPU Register: 프로세스를 실행하기 위해 저장해야할 레지스터에 대한 정보를 저장한다. CPU-Scheduling information: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보를 저장한다. Memory-management information: 프로세스의 메모리 관리 시스템(페이지 혹은 세그먼트 테이블)에 대한 정보를 저장한다. Accounting information: 프로세스 실행에 사용된 CPU 사용량, 유저 정보를 저장한다. I/O status information: 프로세스에 할당된 I/O 장치들의 목록을 저장한다.예상 질문 프로세스는 무엇인가요?답변1. 프로세스란, **메모리에 할당되어 실행되고 있는 프로그램의 인스턴스**를 말합니다. 2. 프로세스는 명령어를 수행하기 위해 각각 독립된 메모리 영역을 할당 받고, 기본적으로 최소 하나의 스레드를 가지고 있습니다.3. 프로세스는 각각 별도의 주소 공간에서 실행되며, 기본적으로는 다른 프로세스의 자원에 접근할 수 없습니다. 프로세스와 스레드의 차이점을 설명해 주세요.답변1. 먼저 간단히 말하자면, * 프로세스는 컴퓨터로부터 자원을 할당 받은 작업의 단위이고, * 스레드는 그런 작업 내에서 실행 흐름의 단위입니다.2. 이렇게 말하는 이유는 프로세스는 최소 하나, 또 그 이상의 스레드를 내부에 포함하고 있기 때문입니다. * 프로세스가 생성될 때에는 코드, 데이터, 힙, 스택을 위한 자원을 각각 따로 받지만, * 스레드가 생성될 때에는 같은 프로세스 내의 코드, 데이터, 힙은 공유하되, 그 외의 스택 등의 영역만 따로 할당 받습니다. 힙 영역과 스택 영역의 차이점을 설명해주세요.답변1. 힙과 스택 영역 모두 런타임에 할당되는 데이터를 저장하는 공간입니다. 2. 스택에는 지역변수, 매개변수 등이 저장되고, 함수가 호출될 때 할당되고 호출이 끝나면 사라집니다. 높은 주소부터 낮은 주소 순서로 저장됩니다. 3. 힙에는 동적으로 할당되는 변수들이 저장되고, 사용자가 할당과 해제를 관리합니다. 낮은 주소부터 높은 주소 순서로 저장됩니다. 컨텍스트 스위칭이 무엇인지 설명해주세요.답변프로세스, 혹은 스레드를 통해 여러 작업을 처리해야 하는 상황에서 현재 진행중인 작업의 상태를 PCB나 TCB에 저장하고, 다음에 진행할 작업의 상태 값을 읽어 적용하는 과정을 말합니다. PCB는 무엇인가요?답변* PCB란, 운영체제에서 프로세스에 대한 저장한 메타데이터를 말합니다. * 프로세스가 생성되면 운영체제는 해당 프로세스에 대한 PCB를 생성하는데, * 프로세스가 현재 실행중인지 아닌지, 프로세스가 실행할 다음 명령어는 어디 있는지 등의 정보를 저장해, 컨텍스트 스위칭이 일어날 때마다 프로세스의 실행 상태를 저장하고 불러오는 데 사용됩니다.참고 자료 [운영체제] 프로세스란? (스케줄링, 메모리구조, 상태변화) 프로세스의 개념 / 구조 / 상태 변화 [운영체제] PCB(Process Control Block)" }, { "title": "[CS] OS: 메모리와 캐시", "url": "/posts/CS_Memory/", "categories": "CS, OS", "tags": "CS, OS, Memory, Cache, VirtualMemory, Memory Allocation", "date": "2023-02-20 09:00:00 +0900", "snippet": "메모리메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어있다. 레지스터 : CPU안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음 캐시 : L1, L2캐시를 지칭 주기억장치 : 메모리 즉 RAM 지칭 보조기억장치 : HDD, SDD 지칭램은 하드디스크로부터 일정량의 데이터를 복사해 임시로 저장하고, 이를 필요 시마다 CPU에 빠르게 전달한다. 계층 위로 올라갈수록 속도는 빨라지지만 용량이 작아지고 속도는 빨라진다.속도가 빠른데도 계층으로 나누어진 이유는 경제성, 즉, 비싸기 때문이다.캐시캐시는 데이터를 미리 복사해 놓는 임시 저장소로, 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리이다.정보는 보통 어떤 저장장치에 보관되는데, 정보가 저장된 저장공간에 따라 불러오는 속도가 다르다. 예를 들어 주기억장치 에 있는 프로그램이나 데이터들은 보조기억장치에서 불러올 때보다 훨씬 빠르게 불러온다. 그러나 중복되어 불려지는 데이터나 프로그램의 부분은 더욱 빨리 불러와질 필요가 있었고, 이를 위해 더 빠른 장치인 캐시에 해당 데이터를 저장하여 불러와 성능을 향상시키는 것이다.하지만 캐시는 크기가 제한되어 있기 때문에 캐시 관리는 중요한 설계 문제로 성능을 크게 좌지우지한다. 캐시는 “이 데이터가 자주 사용되는가?”를 판단해 설정하는 것이 좋다. 자주 사용되는지에 대한 근거가 되는 것을 지역성이라고 하며, 지역성은 최근 사용한 데이터에 다시 접근하려는 특성인 시간 지역성(temporal locality)과 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하려는 특성인 공간 지역성(spatial locality)로 나뉜다.캐시히트, 캐시미스캐시에서 원하는 데이터를 찾는 것을 캐시히트라고 하며, 캐시에 없어서 메모리로 가서 데이터를 찾아오는 것을 캐시미스라고 한다.캐시 히트가 일어나면, 제어장치를 거쳐 데이터를 가져온다. 위치도 가깝고 CPU 내부 버스 기반으로 작동하기 때문에 빠르다.캐시 미스가 일어나면, 메모리에서 데이터를 가져온다. 시스템 버스를 기반으로 작동하기 때문에 느리다.캐시의 사례 웹 브라우저의 캐시소프트웨어적인 대표적인 캐시로는 웹 브라우저의 쿠키, 로컬 스토리지, 세션 스토리지가 있다. 보통 사용자의 커스텀한 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰인다. 데이터베이스의 캐시데이터베이스 시스템을 구축할 때도 메인 데이터베이스 위에 레디스(redis) 데이터 베이스 계층을 ‘캐싱 계층’으로 둬서 성능을 향상시키기도 한다.메모리 관리가상 메모리가상 메모리는 메모리 관리 기법의 하나로, 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다.이때 가상적으로 주어진 주소를 가상 주소(Logical address)라고 하며, 실제 메모리 상에 있는 주소를 실제 주소(Physical address)라고 한다. 가상 주소는 메모리관리장치에 의해 실제 주소로 변환되며, 이 덕분에 사용자는 실제 주소를 의식할 필요없이 프로그램을 구축할 수 있다.가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어있는 페이지 테이블로 관리되는데, 이때 속도 향상을 위해 메모리와 CPU 사이에서 주소변환을 해주는 캐시인 TLB를 사용한다.만약 가상 메모리에는 존재하지만, 실제 메모리엔 없는 데이터를 접근할 경우, 페이지 폴트가 발생한다. 이때 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고, 하드디스크의 일부분을 마치 메모리처럼 불러와 사용하는 것을 스와핑(Swapping)이라고 한다. 스와핑이 일어나는 과정은 다음과 같다. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생시켜 운영체제에 알린다. 운영체제는 CPU의 동작을 잠시 멈춘다. 운영체제는 페이지 테이블을 확인하여 페이지 테이블을 확인하여 가상 메모리에 페이지(가상 메모리를 사용하는 최소 크기 단위)가 존재하는지 확인한다. 없으면 프로세스를 중단하고 현재 물리 메모리에 비어있는 프레임(실제 메모리를 사용하는 최소 크기 단위)이 있는지 찾는다. 물리 메모리에도 없다면 스와핑이 발동된다. 비어있는 프레임에 해당 페이지는 로드하고, 페이지 테이블을 최신화 한다. 중단되어있던 CPU를 다시 실행한다.메모리에 너무 많은 프로세스가 동시에 올라가면서 스와핑이 너무 많이 일어나 페이지 폴트율이 높아지는 것을 스레싱(Thrashing)이라고 한다. 페이지 폴트가 일어나면 CPU 사용이 낮아지고, CPU 사용률이 낮아지면 운영체제는 CPU가 한가한 걸로 파악해 메모리에 더 많은 프로세스를 올리려고 하기에 악순환이 반복된다. 이를 해결하기 위한 방법으로는, 과거 사용 이력을 통해 페이지 집합을 만들어 미리 메모리에 올리는 작업 세트(Working set), 프레임을 동적으로 조절해 페이지 폴트 빈도를 조절하는 PFF(Page Fault Frequency)가 있다.메모리 할당메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당하는데, 연속할당과 불연속할당으로 나뉜다.연속 할당연속 할당은 메모리에 ‘연속적’으로 공간을 할당하는 것을 말한다. 메모리를 미리 나누어 관리하는 고정 분할 방식, 매 시점 프로그램의 크기에 맞게 메모리를 분할하는 가변 분할 방식으로 나눌 수 있다. 고정 분할 방식은 메모리를 미리 나누어 사용하기에 융통성이 없어 내부 단편화가 발생한다. 가변 분할 방식은 매 시간 프로그램의 크기에 맞게 동적으로 공간을 할당한다. 내부 단편화는 발생하지 않지만 외부 단편화가 발생할 수 있다. 홀 : 할당할 수 있는 비어있는 메모리 공간내부 단편화 : 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 발생하는 상태외부 단편화 : 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 상태 불연속 할당불연속 할당은 메모리를 연속적으로 할당하지 않는 방법으로, 현대 운영체제가 쓰고 있으며, 대표적으로 페이징 기법이 있다. 페이징(Paging)페이징은 프로세스를 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 할당하는 방식을 말한다.홀의 크기가 균일하지 않은 문제가 없어지지만, 주소 변환이 복잡해진다. 세그멘테이션 (Segmentation)세그멘테이션은 페이지 단위가 아닌, 의미 단위인 세그먼트 단위로 나누는 방식을 말한다. 의미 단위는 코드와 데이터로 나눌 수도 있고, 코드 내의 함수를 단위로 나눌 수도 있다.보안 측면에서 장점을 가지지만, 홀 크기가 균일하지 않은 단점이 있다. 페이지드 세그멘테이션 (Paged Segmentation)페이지드 세그멘테이션은 프로그램의 의미 단위인 세그먼트로 나눠 공유나 보안 측면에 강점을 두고, 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것을 말한다. 페이지 교체 알고리즘스와핑이 많이 일어나지 않도록 캐싱할 데이터를 선택하는 것이 중요하다. 오프라인 알고리즘 / OPT (Optimal)먼 미래에 참조될 페이지와 현재 할당된 페이지를 바꾸는 알고리즘이다.미래에 참조할 프로세스를 알 수 없기 때문에 사용할 수 없는 알고리즘이나, 효율적인 알고리즘을 선택하는데 있어 기준을 제공하는 데 의의를 둔다. FIFO (First In First Out)가장 먼저 온 페이지를 교체 영역에 가장 먼저 올려두는 것을 말한다. LRU (Least Recentle Used)가장 오래된 페이지를 바꾸는 알고리즘이다. 페이지가 참조되면, 교체 순서의 가장 뒤로 밀어내는 방식이다.가장 오래된 것을 파악하기 위해 계수기, 스택 등을 두어야하는 문제점이 있다. NUR (Not Used Recently)최근에 사용되지 않은 페이지를 교체하는 알고리즘이다. 참조 비트를 두어, 한 번 참조된 페이지는 교체할 순서가 왔을 때에도 교체 되지 않고 한 번 넘어가는 방식이다. LFU (Least Frequently Used)가장 참조가 적은 페이지를 교체하는 알고리즘이다. 예상 질문 캐시란 무엇인가요?답변1. 캐시란, 데이터를 미리 복사해두는 임시 저장공간을 말합니다. 캐시는 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위해 사용됩니다.2. 모든 데이터를 캐시에 담을 수 없기 때문에 소수의 데이터를 선별해 담는데, 이를 판단할 때 사용되는 것이 지역성입니다.3. 지역성은 시간 지역성, 공간 지역성으로 나뉩니다. 4. 시간 지역성이란, 최근 사용한 데이터에 다시 접근하려는 특성을 말합니다.5. 공간 지역성이란, 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하려는 특성을 말합니다. 가상 메모리가 무엇인지 설명해 주세요.답변1. 가상 메모리란, 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화해서 사용자들에게는 매우 큰 메모리로 보이게 만드는 것을 말합니다.2. 이 때, 가상적으로 주어지는 주소를 가상 주소, 실제로 데이터가 존재하는 주소를 실제 주소라고 하는데, 가상 주소는 메모리 관리 장치에 의해 실제 주소로 바뀌기 때문에, 사용자는 실제 주소를 의식 할 필요 없이 프로그램을 만들 수 있게 되는 것입니다. 메모리 단편화는 무엇인지 설명해 주세요.답변1. 메모리 단편화란, 프로세스를 메모리에 할당 할 때, 프로세스가 들어갈 빈 공간이 충분히 있음에도, 그 공간이 잘게 나누어져 실제로는 사용이 불가능한 상태를 말합니다.2. 메모리 단편화는 내부 단편화와 외부 단편화로 구분됩니다.3. 내부 단편화란, 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 공간이 낭비 되는 상황을 말합니다.4. 외부 단편화란, 사용 중인 메모리 사이사이 빈 공간이 프로세스를 할당하기에 너무 작아 공간이 낭비 되는 상황을 말합니다. 페이징 기법과 세그멘테이션 기법의 차이점에 대해 설명해 주세요.답변1. 페이징과 세그멘테이션 기법 모두 메모리 할당 시에 연속적인 메모리 공간이 아닌 곳에 할당하는, 불연속 할당에 속하는 기법들입니다.2. 페이징의 경우, 프로세스를 동일한 크기로 나눠 서로 다른 위치에 할당시키는 방법을 말합니다.3. 세그멘테이션의 경우, 프로세스를 의미 단위의 다른 크기로 나눠 다른 위치에 할당시키는 방법을 말합니다.4. 페이징을 사용한다면, 홀의 크기가 동일해 외부 단편화 문제를 해결할 수 있으나, 페이지와 프로세스의 크기가 딱 맞아 떨어지지 않아 내부 단편화 문제가 생길 수 있습니다.5. 세그멘테이션을 사용한다면, 의미 단위로 딱 맞게 나눠 내부 단편화 문제를 해결할 수 있으나, 크기가 제각각이므로 프로세스가 메모리를 해제했을 때 외부 단편화 문제가 생길 수 있습니다. 페이지 교체 알고리즘에 대해 설명해주세요.답변1. 페이지 교체 알고리즘이란, 캐시가 가득 차 페이지를 교체해야할 상황에 캐시를 최소한으로 교체시키기 위해 어느 페이지를 탈락시킬지를 결정하는 알고리즘입니다.2. 종류는 대표적으로 OPT, FIFO, LRU, LFU, NUR 등이 있습니다.* OPT는 가장 먼 미래에 참조될 페이지를 교체하는 기법으로, 미래를 알 수 없기 때문에 실현 가능성이 없는 기법이지만, 최선의 알고리즘에 대한 기준이 되는 기법입니다.* FIFO는 가장 먼저 들어온 페이지가 가장 먼저 교체되는 기법입니다. 선입선출의 구조이기 때문에 구현이 가장 쉽습니다.* LRU는 가장 과거에 사용됐던 페이지가 먼저 교체되는 기법입니다. 페이지가 참조되었다면 교체 순서를 가장 나중으로 미루는 방식으로 구현합니다.* LFU는 가장 적게 참조된 페이지가 먼저 교체되는 기법입니다.* NUR은 최근에 참조되지 않은 페이지를 교체하는 기법입니다. 페이지 참조 비트를 두어, 참조 되었다면 교체 순서에 교체 당하지 않고 넘어가는 방식으로 구현합니다. 참고 자료 캐시와 메모리 할당 Memory Management in Operating System [OS] 페이지 교체 알고리즘 - FIFO/LRU/LFU/MFU/NUR" }, { "title": "[CS] OS: 운영체제란 무엇인가?", "url": "/posts/CS_OS/", "categories": "CS, OS", "tags": "CS, OS, Kernel, SystemCall, Interrupt", "date": "2023-02-17 09:00:00 +0900", "snippet": "운영체제운영체제(Operating System)는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다. 운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해 준다.운영체제의 목적에는 처리능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다.역할운영 체제의 역할은 크게 네 가지가 있다. 자원 기능 프로세스 관리 CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리 기억장치 관리 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리 주변장치 관리 마우스, 키보드 같은 데이터를 주고받는 장치를 관리 파일 관리 파일을 어떤 방법으로 보관할지 관리 구조운영체제는 응용프로그램과 하드웨어 사이에 위치해 있으며, 커널과 인터페이스로 이루어져있다. 커널 : 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아놓은 것으로 운영체제의 성능을 좌우한다. 인터페이스 : 사용자의 명령을 전달하고 실행 결과를 사용자에게 알려주는 역할을 한다. 그래픽으로 되어있으면 GUI, 명령어 형태로만 전달하면 CUI라고 한다.커널커널 내부에는 시스템콜과 드라이버가 있는데, 각각이 무엇인지 알아보도록 하자. 시스템콜시스템콜이란 커널이 자신을 보호하기 위해 만든 인터페이스이다. 사용자나 프로그램이 직접 컴퓨터 자원에 직접 접근하는 것을 막는다. 사용자나 응용 프로그램이 컴퓨터 자원을 사용하기 위해서는 시스템 호출을 사용해야 한다. 보통은 함수의 형태로 제공된다. (Ex. printf(), write())시스템콜이 작동 될 때, modebit을 참고해 유저 모드와 커널 모드를 구분한다. I/O 장치를 작동시킬 때 운영 체제를 통하지 않는다면, 공격자가 I/O 장치를 건드리기 쉬워진다. 이를 방지하기 위해 I/O 장치를 작동시키고 싶으면 시스템콜을 호출해 modebit을 1에서 0으로 바꿔 해당 장치를 이용한 로직을 수행하도록 한다. 드라이버드라이버는 커널과 하드웨어의 인터페이스를 담당한다. 컴퓨터 하드웨어의 종류는 다양한데, 이때 운영체제가 각 하드웨어에 맞는 인터페이스를 개발하기는 어려우므로 하드웨어 제작자가 만든 소프트웨어를 받아서 설치하여 하드웨어를 사용할 수 있게 한다. 이 소프트웨어를 디바이스 드라이버라고 한다.인터럽트인터럽트란, 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행중인 작업으로 복귀하는 것을 말한다. 인터럽트가 발생하면, 인터럽트 핸들러 함수가 모여있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행된다. 인터럽트 간에는 우선 순위가 있고, 우선 순위에 따라 실행된다.종류인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다. 하드웨어 인터럽트하드웨어 인터럽트는 키보드, 마우스를 연결하는 등 IO 장치에서 발생하는 인터럽트를 말한다. 소프트웨어 인터럽트트랩이라고도 불리는 소프트웨어 인터럽트는 프로세스에서 오류가 일어나거나, 프로세스가 시스템콜을 호출해 발생하는 인터럽트를 말한다.처리 과정 현재 실행중인 명령의 메모리 주소를 포함한 부가 정보를 PCB에 저장한다.CPU에서 명령이 실행될 때에는 CPU 내부에 있는 임시 기억장치인 레지스터에 데이터를 읽거나 쓰면서 작업을 한다.이때 인터럽트가 발생하면 기존의 레지스터값들이 지워지게 되므로 CPU 내의 이러한 상태를 PCB에 저장한다. 인터럽트 처리 루틴에 따라 인터럽트를 처리한다.운영체제는 할 일을 쉽게 찾아가기 위해 인터럽트 벡터(interrupt vector)를 가지고 있다. 인터럽트 백터란 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키는 자료구조를 말한다.인터럽트 백터를 따라가면 실제 처리해야 할 코드는 인터럽트 처리 루틴(Interrupt service routine) 또는 인터럽트 핸들러(Interrupt handler)라고 불리는 다른 곳에 정의된다. 인터럽트 당하기 직전으로 복원한다.인터럽트 처리 루틴을 통해 해당되는 인터럽트 처리를 완료하고 나면 PCB에 저장한 수행중이던 원래 수행하던 작업으로 돌아가 중단되었던 일을 계속해서 수행한다.예상 질문 운영 체제에 대해 설명해주세요.답변운영 체제는 컴퓨터 하드웨어가 컴퓨터 소프트웨어와 통신하고 작동하도록하는 소프트웨어 프로그램입니다. 운영 체제의 주요 목적은 무엇인가요?답변운영 체제에는 두 가지 주요 목적이 있습니다. 하나는 컴퓨터 시스템의 자원들을 효율적으로 관리하는 것이고, 다른 하나는 사용자가 컴퓨터를 사용하기 편리한 환경을 제공하는 것입니다. 인터럽트가 무엇이고, 인터럽트 발생 시 어떤 동작이 일어나는지 간략히 말해 보세요.답변1. 인터럽트는 현재 실행 중인 프로그램을 중단하고, 다른 프로그램의 실행을 요구하는 명령어입니다.2. 키보드를 누름으로 인해 발생하는 인터럽트나, 입출력 장치등에 의한 인터럽트등이 있고, 소프트웨어적인 인터럽트는 시스템 콜로써 구현이 됩니다.3. 인터럽트가 발생하면, 현재 실행 중이었던 프로세스의 상태 정보를 PCB에 저장해 둡니다. 이후 인터럽트 서비스 루틴이 인터럽트를 처리하고, 처리가 모두 끝나면 다시 이전 작업 상태 정보를 복구하여 재개합니다. 시스템 콜이 무엇인지 설명해 주세요.답변1. 시스템 콜은 응용프로그램에서 시스템 커널에 어떠한 기능을 수행해 달라고 요청하는 것을 말합니다. 사용자가 직접 커널에 접근할 수는 없기 때문에, 이를 시스템 콜을 통해 대신하는 것입니다.2. 리눅스의 프로세스 정지 명령어나 fork 명령어, 파일을 오픈, 클로즈 하거나 읽는 등 open, read, close 등의 명령들도 모두 시스템 콜에 해당이 됩니다.참고 자료 운영체제란 무엇인가? [운영체제] 운영체제의 구조 (커널과 인터페이스) [운영체제] 한번에 모아보는 면접대비 운영체제 질문 목록들" }, { "title": "[CS] HTTP와 HTTPS: 메시지를 안전하게 보내는 방법", "url": "/posts/CS_HTTPvsHTTPS/", "categories": "CS, Network", "tags": "CS, Network, HTTP, HTTPS", "date": "2023-02-16 09:00:00 +0900", "snippet": "개요지난 번에는 HTTP 프로토콜의 변천사에 대해 알아보면서, ‘어떻게 하면 더 빨리’ 메시지를 보내도록 바뀌었는지 그 과정을 알아보았다. 이번에는 ‘더 안전하게’ 메시지를 보내기 위해 나온 HTTPS에 대해, 더 정확히는 그 메시지를 보내는 과정에 무엇이 추가 되었고 어떻게 메시지를 보내는지에 대해 알아보고자 한다.HTTPHTTP(Hyper Text Transfer Protocol)는 서버와 클라이언트가 데이터를 주고 받을 때 사용하는 프로토콜이다. HTTP는 텍스트, 이미지, 영상, JSON 등등 거의 모든 형태의 데이터를 전송할수 있다.HTTP는 상태 정보를 저장하지 않는 무상태성(Stateless)의 특징과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 비연결성 (Connectionless)의 특징을 가지고 있다. 장점통신간의 연결 상태 처리나 상태 정보를 관리할 필요가 없어 서버 디자인이 간단하다.각각의 HTTP 요청에 독립적으로 응답만 보내주면 된다. 단점이전 통신의 정보를 모르기 때문에, 매번 인증을 하거나 쿠키나 토큰을 이용해 정보를 저장해야 한다.HTTP에는 클라이언트와 서버간의 통신에 있어서 별다른 보안 조치가 없다. 만약 누군가 네트워크 신호를 가로챈다면 HTTP로 전달한 내용은 그대로 외부에 노출된다. 고객의 개인정보나 비밀을 취급하는 대규모 서비스라면 큰 보안적 허점이 되는 것이다. 이런 문제를 해결하기 위해 등장한 것이 HTTPS이다.HTTPSHTTPS 는 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS를 넣은, 신뢰할 수 있는 HTTP 요청이다. HTTPS 가 제공하는 것들은 다음과 같다. 기밀성: HTTPS는 두 참여자간의 통신을 암호화하여 보호한다. ex) 와이파이 운영자가 개인 정보를 보지 못하게 함 무결성: HTTPS는 변조되지 않은 정보로 목적지에 도달하게 한다. ex) 와이파이 운영자가 웹사이트에 광고를 추가하지 못하게 함 인증: HTTPS를 통해 웹사이트의 진위 여부를 확인할 수 있다. ex) 와이파이를 통해 가짜 웹사이트를 브라우저에 보낼 수 있지만, https는 이를 검증한다.SSL/TLSSSL/TLS는 전송 계층에서 보안을 제공하는 프로토콜이다. 클라이언트가 서버와 통신할 때 SSL/TLS를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록 한다.SSL/TLS는 보안 세션을 기반으로 데이터를 암호화하며, 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용된다.보안 세션보안 세션이란, 보안이 시작되고 끝나는 동안 유지되는 세션을 말하고, SSL/TLS는 핸드셰이크를 통해 보안 세션을 만들어 정보를 공유한다. 핸드셰이크의 과정은 다음과 같다. 클라이언트는 스키마가 https:// 인 것을 확인하고, 브라우저의 SSL/TLS 버전, 브라우저가 지원하는 암호화 방식 모음(사이퍼 슈트), 임의의 난수 등을 보낸다. 서버는 응답으로 브라우저가 보낸 사이퍼 슈트 중 사용할 암호화 방식, 공개키가 담긴 인증서, 임의의 난수를 담아 보낸다. 클라이언트는 인증서를 확인한 후, 자신과 서버가 생성했던 두 개의 난수를 가지고 premaster secret 을 만들고, 인증서에 있는 공개키로 암호화 해 보낸다. 서버는 암호화 된 값을 비밀키로 복호화하고, 이를 master secret으로 설정, 그리고 그 값으로 session key를 생성한다. 이 세션 키를 대칭키로 사용해 브라우저와 서버 사이에 주고받는 데이터를 암호화하고 복호화한다.여기서 사이퍼 슈트란 데이터 암복호화에 사용할 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 집합을 말한다. 또, AEAD 사이퍼 모드는 데이터 암호화 알고리즘으로, AES_128_GCM 등이 있다.암호화 알고리즘HTTPS를 통해 전송할 데이터를 암호화 할 때 SSL/TLS에서는 키 교환 암호화 알고리즘을 사용한다. 대표적인 키 교환 암호화 알고리즘으로 ECDHE, DHE가 있는데, 둘 모두 DHE, 즉 디피-헬만 알고리즘 방식을 근간으로 사용한다.디피-헬만 알고리즘은 암호키를 교환하는 하나의 방법으로, y = g^x mod p 의 식에서 g, x, p를 알면 y는 구하기 쉽지만, g, y, p를 알면 x는 구하기 어렵다. 라는 원리에 기반한 알고리즘이다.위의 보안 세션 과정과 비교해 설명하자면, 처음에 공개 값을 공유(생성한 임의의 난수)하고, 각자의 비밀 값과 혼합한 후 그 값을 공유(premaster key), 그 혼합 값을 다시 비밀 값과 혼합하면 공통의 암호키(session key)를 얻을 수 있다.예상 질문 HTTP에 대해서 설명해주세요답변1. HTTP는 클라이언트와 서버가 요청과 응답의 형태로 데이터를 주고받기 위해 그 메시지의 형식을 규정해놓은 프로토콜입니다. 2. 특징으로는 연결이 종료되면 클라이언트의 상태를 유지하지 않는다는 무상태성, 요청에 대한 응답을 주면 연결을 종료한다는 비연결성이 있습니다.3. 이 덕분에 각각의 HTTP 요청에 독립적으로 응답을 보낼 수 있어 설계가 간단해진다는 장점이 있지만, 이전의 통신 정보를 모르기 때문에 인증이 번거로워진다는 단점이 있습니다. HTTPS는 HTTP와 어떻게 다른지 설명해주세요.답변1. HTTP는 통신 상대를 확인하지 않는 평문 통신이기 때문에 도청과 위장의 위험이 있습니다. 2. 이를 방지하기 위해 애플리케이션과 전송 계층 사이에 보안 계층으로 SSL/TLS 프로토콜을 삽입한 것이 HTTPS 입니다. 3. 이 보안 계층은 클라이언트가 인증서를 통해 웹사이트가 진짜임을 확인할 수 있도록 하고, 인증서에 포함된 공개키로 암호화에 쓰일 대칭키를 만들어 패킷을 암복호화하는 역할을 합니다.참고 자료 HTTP vs HTTPS의 차이점을 알아보자 [TLS 핸드셰이크의 원리는 무엇일까요? SSL 핸드셰이크](https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/) 디피 헬만 알고리즘(Diffie-Hellman Algorithm) 신입 개발자 기술면접 질문 정리 - 네트워크" }, { "title": "[CS] HTTP 1.0 부터 3.0까지: HTTP 규약은 어떻게 변화해 왔나", "url": "/posts/CS_HTTP_history/", "categories": "CS, Network", "tags": "CS, Network, HTTP, HTTPS", "date": "2023-02-13 09:00:00 +0900", "snippet": "개요인터넷에서 웹 서버와 사용자 컴퓨터에 설치된 웹 브라우저 사이에 문서를 전송하기 위한 통신 규약인 HTTP 프로토콜은, 당연하게도 처음부터 완벽한 상태로 나오지는 않았다. 개발자들은 ‘어떻게 하면 더 빨리, 더 안전하게 응답을 보낼 수 있을까’에 대해 고민하며 데이터 송수신 방식을 발전시켜왔고, 그에 따라 여러가지 규약들이 생겨났다. 이번엔 이 HTTP의 규약이 처음엔 어땠고, 어떤 변화를 거쳐왔는지 알아보도록 하자.HTTP/1.0특징 TCP 기반으로 연결을 설정한다. 한 연결에 하나의 요청을 처리하도록 설계 되었다. GET, HEAD, POST의 메서드만을 지원한다. GET : Request-URI에서 지정한 정보를 Entity Body로 전달해달라는 요청 HEAD : Header의 정보만 요구 POST : Request 메시지의 body에 포함된 자원을 Request-URI로 넘겨주는 경우 사용 한계 서버로부터 파일을 가져올 때마다 TCP의 3-웨이 핸드셰이크를 열어야해서 RTT(라운드 트립, 패킷 왕복 시간)가 증가하는 단점이 있다. RTT 증가에 대한 해결책으로 이미지 스프라이트(여러 개의 이미지를 하나의 이미지로 합쳐서 관리하는 이미지), 코드 압축(빈 칸 삭제), 이미지 Base64 인코딩 방식을 사용했다. HTTP/1.1특징 HTTP/1.0에서 발전한 것으로, 매번 TCP 연결을 하는 것이 아니라, 한번 TCP를 초기화 한 후 Keep-alive 옵션으로 여러개의 파일을 송수신 할 수 있게 바뀌었다. 여러 개의 요청을 동시에 보내는 Pipelining을 지원해 응답 속도를 높일 수 있게끔 했다. OPTION, PUT, DELETE, TRACE의 메서드가 추가되었다. OPTION : 통신과 관련된 선택사항들에 대한 정보를 요구하는 경우 PUT : Request 메시지에 포함되어 있는 data를 지정한 Request-URI로 저장하기 위함 DELETE : 특정 resource를 지우기 위함 TRACE : 최종 destination까지의 Loopback을 테스트하기 위함 한계 문서 안에 포함된 다수의 리소스를처리하려면, 요청할 리소스 개수에 비례해서 대기 시간이 길어지는 단점이 있다. HOL Blocking(Head Of Line Blocking)으로 전송이 빠르지만 나중에 도착한 패킷(css 등)보다 전송이 느리지만 먼저 도착한 패킷(이미지 등)을 먼저 전송해야해서 성능 저하 현상이 발생한다. HTTP/1.1의 헤더에는 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무겁다.HTTP/2장점 여러 개의 스트림을 사용해 송수신하는 멀티플렉싱을 지원한다. 멀티플렉싱은 하나의 TCP 연결로 동시에 여러개의 메시지를 주고 받고, 응답을 순서에 상관없이 스트림으로 주고받는 방식을 말한다. 즉, HTTP 상의 HOL Blocking을 해결하게 되었다. 중복되는 헤더의 반복 전송을 낮추기 위해, 허프만 코딩 압축 알고리즘(중복 횟수가 많은 정보는 적은 비트 수를 사용해 표현하며 데이터의 표현에 필요한 비트양을 줄이는 방식)을 사용해 헤더를 HPACK 압축 형식으로 압축해서 전송한다. 서버 푸시 기능을 통해 클라이언트가 요청하지 않은 데이터라도 서버가 스스로 전송해줄 수 있도록 했다. html에 css와 js가 포함되어있다면, html 요청 한 번에 html, css, js 응답 3개를 모두 전송하는 것이다.한계 TCP 기반으로 동작하기에 핸드셰이크 과정이 필수적이고, 그에 따른 지연 시간이 발생한다. 패킷이 유실되거나 오류가 있을때 재전송을하는데, 이 패킷을 재전송하는 동안 전체 패킷 전송이 중단되게 된다. HOL Blocking 문제가 여전히 발생하는 것이다.HTTP/3특징 TCP 기반이 아닌, UDP 기반으로 QUIC 프로토콜을 사용해 연결 설정을 하기 때문에 3-웨이 핸드셰이크 과정을 필요로 하지 않는다. 또, 보안 통신을 위해 TLS를 이용할 때에도 TCP+TLS 로 다수의 라운드 트립이 필요했던 HTTP/2와 다르게, Quic은 TLS 인증서를 내포하고 있기 때문에 인증도 단축되었다. 결과적으로 첫 연결 설정에 한 번의 라운드 트립만 필요하고, 덕분에 초기 연결의 시간이 단축되었다. 순방향 오류 수정 메커니즘이 적용되어, 패킷이 손실 되었어도 수신 측에서 에러를 검출하고 수정할 수 있어 패킷 손실률이 낮다. 각 스트림을 스트림 식별자로 식별함으로 스트림 중 하나에서 어떤 패킷이 손실되더라도 해당 스트림만 멈추게 된다. 즉, TCP상의 HOL Blocking 문제까지 해결하게 되었다. QUIC은 Connection ID를 사용하여 서버와 연결을 생성하기 때문에, 네트워크 변경과 같이 IP가 바뀌는 상황에도 연결을 유지할 수 있다.한계 QUIC은 패킷별로 암호화를 한다. 이는 기존의 TLS-TCP에서 패킷을 묶어서 암호화하는 것보다 더 큰 리소스 소모를 불러올 수 있다는 단점이 있다. UDP 기반이기 때문에 패킷 차단에 필요한 정보가 거의 없어 Ddos 공격에 대응하기 어렵고, 또 IP 스푸핑으로 IP를 속인 채 요청을 대량으로 보내면 피해 IP는 원치 않는 데이터를 대량으로 수신하게 되는 반사 공격을 할 수도 있다.예상 질문 HTTP/1.0 에 대해 설명해주세요.답변1. HTTP/1.0는 TCP를 기반으로 한 번의 연결로 하나의 요청을 처리할 수 있도록 설계된 버전입니다.2. 요청 하나마다 3-웨이 핸드셰이킹으로 연결하고 4-웨이 핸드셰이킹으로 종료해야 하므로, 라운드 트립이 여러번 발생한다는 단점이 있습니다.3. 이런 단점에 대한 해결책으로 이미지 스프라이트나 Base64 인코딩, 코드 압축 같은 기술이 도입되었습니다. * 이미지 스프라이트란 여러 개의 이미지를 하나로 합쳐 관리하는 기법입니다. * Base64 인코딩은 이미지파일을 64진법으로 이루어진 문자열로 인코딩해 이미지에 대한 요청을 없애는 기법입니다. * 코드 압축은 코드상의 개행 문자 같은 빈칸을 없애 크기를 최소화하는 방법입니다. HTTP/1.1은 1.0과 무슨 차이가 있는지 설명해주세요.답변1. HTTP/1.1은 한번의 연결로 많은 요청을 처리할 수 있도록 하는 Keep-alive 옵션이 생겼습니다.2. 또, 파이프 라이닝을 지원해 여러 개의 요청을 동시에 보낼 수 있도록 할 수 있습니다.3. 기존의 GET, POST, HEAD 메서드에서 추가되어 PUT, DELETE, OPTION 등의 메서드가 추가되었습니다. HTTP/2.0에 대해 설명해주세요.답변1. HTTP/2.0는 1.0보다 지연 시간을 줄이고 응답 시간을 빠르게 할 수 있도록 설계된 버전입니다. 2. 2.0의 장점으로는 멀티플렉싱, HPACK 방식의 헤더 압축, 서버 푸시 등이 있습니다. * 멀티플렉싱은 여러 개의 스트림을 사용해 패킷을 송수신 하는 것입니다. * HPACK은 허프만 코딩 알고리즘으로 헤더를 압축한 것을 말하는데, 중복되는 헤더를 그 횟수에 따라 다른 비트로 표현하는 것입니다. * 서버 푸시란, 한 번의 요청으로 관련된 자료를 같이 응답으로 주는 것입니다.3. 단점으로는, TCP 상의 HOL Blocking을 해결하지 못했다는 것과, TCP와 TLS 사용으로 초기 연결 시간이 길다는 것입니다. HTTP/3.0에 대해 설명해주세요.답변1. HTTP/3.0은 2.0까지 사용되어 왔던 TCP가 아닌, UDP 기반의 QUIC 프로토콜을 이용해 통신하는 버전입니다.2. 3.0의 장점으로는 1-RTT 연결 설정, 스트림 식별자 사용, Connection ID 사용 등이 있습니다. * 3.0는 TLS 인증서를 내포한 QUIC 프로토콜로 연결을 설정하므로, 한 번의 RTT로 연결 설정이 완료됩니다. * 또, 스트림 식별자를 사용해 패킷 유실시에도 해당 패킷과 관련된 스트림만 멈춰 HOL Blocking을 해결합니다. * 그리고 IP 대신 Connection ID로 연결을 설정해, 네트워크 변경시에도 연결을 유지할 수 있습니다.3. 단점으로는, QUIC은 패킷별로 암호화를 해 리소스 소모가 크다는 점, QUIC 폭주나 반사 공격 등 보안 취약점이 아직 존재한다는 점이 있습니다.참고 자료 [Network] HTTP 1.0 vs HTTP 1.1 HTTP/3는 왜 UDP를 선택한 것일까? HTTP3, 사실 진짜로 바뀐건 TCP 였다. [QUIC 폭주 DDoS 공격이란? QUIC 폭주와 UDP 폭주](https://www.cloudflare.com/ko-kr/learning/ddos/what-is-a-quic-flood/) " }, { "title": "[백엔드|스프링부트] 서버가 사용자를 인증하는 법 (JWT를 이용한 방법)", "url": "/posts/SpringBoot_AboutSpringSecurity/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, SpringSecurity, JWT", "date": "2023-02-09 09:00:00 +0900", "snippet": "개요애플리케이션 개발에 사용자 인증과 인가 등의 보안 기능은 거의 필수적으로 구현해야할 사항이다. 보통은 아이디와 비밀번호를 서버에 전달해 사용자를 인증하는 방법을 사용하는데, 스프링부트는 이걸 어떻게 처리할까? 쿠키나 세션 방식같은 방법이 있겠지만, 이번에는 JWT라는 토큰값을 활용하는 보안 기법으로 알아보려고 한다.Spring Security개념 스프링 시큐리티는 인증, 인가를 지원하고 주요 공격으로부터 어플리케이션을 보호해주는 프레임워크이다. 명령형과 리액티브 어플리케이션 모두에서 가장 잘 동작하는, 사실상 스프링 기반 어플리케이션의 표준 보안 프레임워크이다.동작 원리스프링 시큐리티는 클라이언트가 디스패처 서블릿에 접근 하기 전, 서블릿 필터 라는 필터 체인을 기반으로 동작한다. 요청은 이 필터를 처리되기 전에 한번, 처리 된 후에 다시 한번 거쳐 지나가게 된다.이 필터 체인 역시 서블릿 컨테이너에서 관리하는데, 클라이언트에서 요청이 들어오면 서블릿 컨테이너는 URI를 확인해 필터와 서블릿을 매핑해준다.스프링 시큐리티는 이 필터 체인 안의 필터 중 하나로, DelegatingFilterProxy 라는 자동 생성되는 빈을 통해 보안 필터의 프록시 객체를 필터 체인 안으로 집어넣어 동작시킨다.인증 과정스프링 시큐리티 구조의 처리 과정을 간단히 설명하면 다음과 같다. 사용자가 로그인 정보와 함께 인증 요청을 한다.(Http Request) AuthenticationFilter가 요청을 가로채고, 가로챈 정보를 통해 UsernamePasswordAuthenticationToken의 인증용 객체를 생성한다. AuthenticationManager의 구현체인 ProviderManager에게 앞에서 생성한 객체를 전달한다. AuthenticationManager는 등록된 AuthenticationProvider(들)을 조회하여 인증을 요구한다. 실제 DB에서 사용자 인증정보를 가져오는 UserDetailsService에 사용자 정보를 넘겨준다. 넘겨받은 사용자 정보를 통해 DB에서 찾은 사용자 정보인 UserDetails 객체를 만든다. AuthenticationProvider(들)은 UserDetails를 넘겨받고 사용자 정보를 비교한다. 인증이 완료되면 권한 등의 사용자 정보를 담은 Authentication 객체를 반환한다. 다시 최초의 AuthenticationFilter에 Authentication 객체가 반환된다. Authenticaton 객체를 SecurityContext에 저장한다.설정법이전에는 WebSecurityConfidurerAdapter 클래스를 상속 받아 보안 필터 체인을 설정했었다. 하지만 현재 이 기능은 Deprecated 되어 사용이 불가능해졌고, 다음과 같이 SecurityFilterChain을 @Bean으로 등록해 사용해야 한다.@Configurationpublic class SecurityConfiguration { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http.authorizeRequests() .anyRequest().authenticated() .build(); }}구체적인 설정법에 대해서는 뒤에 가서 알아보도록 하자.JWTJWT(JSON Web Token)는 당사자 간에 정보를 JSON 형태로 안전하게 전송하기 위한 토큰이다. JWT는 다음과 같은 특징이 있다. URL로 이용할 수 있는 문자열로만 구성돼 있다. 디지털 서명이 적용돼 있어 신뢰할 수 있다.구조JWT는 헤더(Header), 내용(Payload), 서명(Signature) 각각의 부분이 Base64Url 형식으로 인코딩되어 .으로 구분지어진 구조를 가지고 있다.헤더JWT의 헤더는 검증과 관련된 내용을 담고 있다. 헤더에는 alg 와 typ, 두 가지 정보를 포함하고 있다.{ \"alg\": \"H256\", \"typ\": \"JWT\"}alg 에선 해싱 알고리즘을 지정한다. 해싱 알고리즘은 보통 SHA256 혹은 RSA를 사용하며, 코튼을 검증할 때 사용되는 서명 부분에서 사용된다. typ 에서는 토큰의 타입을 지정한다.내용{ \"sub\": \"board service payload\", \"exp\": \"1602076408\", \"userId\": \"TaemHam\"}JWT 내용에는 토큰에 담는 정보를 포함한다. 이 정보를 클레임(Claim)이라 하고, 크게 세 가지로 분류된다. 등록된 클레임(Registered Claim) 등록된 클레임은 필수는 아니지만 토큰에 대한 정보를 담기 위해 이미 이름이 정해져 있는 클레임이다. iss: JWT 발금자 주체. sub: JWT의 제목. aud: JWT의 수신인. exp: JWT의 만료 시간. 형식은 NumericDate 형식이어야 한다. nbf: ‘Not Before’ iat: JWT 발급 시간. jti: JWT의 식별자(JWT ID). 주로 중복 처리를 방지하기 위해 사용된다. 공개 클레임(Public Claim) 등록 클레임과 충돌이 발생하지 않는 선에서 마음대로 정할 수 있는 속성이다. 비공개 클레임(Private Claim) 비공개 클레임은 통신 간에 상호 합의된, 위의 두 클레임이 아닌 클레임이다.서명JWT의 서명 부분은 인코딩된 헤더, 인코딩된 내용, 비밀키, 헤더의 알고리즘 속성값을 가져와 생성된다. 예를 들어, HMAC SHA256 알고리즘을 사용해 서명을 생성하면 다음과 같이 생성된다.HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret )서명은 토큰의 값들을 포함해 암호화하기 때문에 메시지가 도중에 변경되지 않았는지 확인할 때 사용한다.구현 UserDetails와 UserDetailsService 구현체@Getter@AllArgsConstructorpublic class CustomUserDetails implements UserDetails { private String username; private String password; private String email; private Collection&lt;? extends GrantedAuthority&gt; authorities; public static CustomUserDetails of(String username, String password, String email, UserRole role) { Set&lt;UserRole&gt; rollTypes = Set.of(role); return new CustomUserDetails( username, password, email, rollTypes.stream() .map(UserRole::getName) .map(SimpleGrantedAuthority::new) .collect(Collectors.toUnmodifiableSet()) ); } // 엔티티에서 UserDto로, 다시 CustomUserDetails로 바꾸기 위한 메서드 public static CustomUserDetails from(UserDto dto) { return CustomUserDetails.of( dto.getUsername(), dto.getPassword(), dto.getEmail(), dto.getRole() ); } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return authorities; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; }}CustomUserDetails 클래스는 UserDetails 인터페이스를 구현하고 있다. 위의 그림에서 설명했듯이, UserDetails는 UserDetailsService를 통해 입력된 로그인 정보를 가지고 데이터베이스에서 사용자 정보를 가져오는 역할을 수행한다.@AllArgsConstructorpublic class UserDetailsServiceImpl implements UserDetailsService { private final UserRepository userRepository; @Override public CustomUserDetails loadUserByUsername(String username) { return CustomUserDetails.from(UserDto.from(userRepository.findByUsername(username))); }} JWTTokenProvider 구현JWTTokenProvider는 UserDetails에서 정보를 추출해 JWT 토큰을 생성하는 클래스이다.@Componentpublic class JwtTokenProvider { private final UserDetailsService userDetailsService; @Value(\"${springboot.jwt.secret}\") private String secretKey = \"secretKey\"; private final long TOKEN_VALID_MILLISECOND = 1000L * 60 * 60; @Autowired public JwtTokenProvider(UserDetailsService userDetailsService) { this.userDetailsService = userDetailsService; } @PostConstruct // Bean 으로 주입되면서 실행 protected void init() { secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes(StandardCharsets.UTF_8)); } // 토큰 생성 public String createToken(String username, Set&lt;String&gt; roles) { Claims claims = Jwts.claims().setSubject(username); claims.put(\"roles\", roles); Date now = new Date(); return Jwts.builder() .setClaims(claims) .setIssuedAt(now) .setExpiration(new Date(now.getTime() + TOKEN_VALID_MILLISECOND)) .signWith(SignatureAlgorithm.HS256, secretKey) .compact(); } // 토큰 인증 정보 조회 public Authentication getAuthentication(String token) { UserDetails userDetails = userDetailsService.loadUserByUsername(this.getUsername(token)); return new UsernamePasswordAuthenticationToken(userDetails, \"\", userDetails.getAuthorities()); } // 토큰 기반 회원 구별 정보 추출 public String getUsername(String token) { return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(token) .getBody() .getSubject(); } // HTTP 헤더에서 Token 값 추출 public String resolveToken(HttpServletRequest request) { return request.getHeader(\"X-AUTH-TOKEN\"); } // 토큰 유효성 체크 public boolean validateToken(String token) { try { Jws&lt;Claims&gt; claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token); return !claims.getBody().getExpiration().before(new Date()); } catch (Exception e) { return false; } }} JWTAuthenticationFilter 구현JWTAuthenticationFilter는 헤더로 받은 JWT 토큰을 추출해 유효성을 검사하고, SecurityContextHolder에 Authentication을 부여하는 클래스이다.public class JwtAuthenticationFilter extends OncePerRequestFilter { private final JwtTokenProvider jwtTokenProvider; @Autowired public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider) { this.jwtTokenProvider = jwtTokenProvider; } @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // 토큰 추출 String token = jwtTokenProvider.resolveToken(request); // 토큰 유효성 체크 if (token != null &amp;&amp; jwtTokenProvider.validateToken(token)) { Authentication authentication = jwtTokenProvider.getAuthentication(token); SecurityContextHolder.getContext().setAuthentication(authentication); } filterChain.doFilter(request, response); }} SecurityConfiguration 구현JWT를 사용하는 SecurityFilterChain은 다음과 같이 구현한다.@RequiredArgsConstructor@Configurationpublic class SecurityConfiguration { private final JwtTokenProvider jwtTokenProvider; private final JwtAccessDeniedHandler jwtAccessDeniedHandler; private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint; // 필터체인을 통과시키지 않을 URI 설정 @Bean public WebSecurityCustomizer webSecurityCustomizer(){ return (web) -&gt; web.ignoring() .antMatchers(\"/favicon.ico\"); } // 필터체인 설정 @Bean public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception { return httpSecurity // token을 사용하는 방식이기 때문에 csrf를 disable한다. .csrf().disable() // 세션을 사용하지 않기 때문에 STATELESS로 설정 .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() // 각 URI 인증 여부 결정 .authorizeRequests() .antMatchers(\"/api/v1/sign-in\", \"/api/v1/sign-up\").permitAll() // 허용 경로 .antMatchers(HttpMethod.GET, \"/api/v1/article\").permitAll() // GET 방식만 허용 .antMatchers(\"/api/v1/user-info\").hasRole(\"ADMIN\") // Role이 ADMIN 이어야 함 .anyRequest().authenticated() // 나머지 경로는 JWT 인증 필요 .and() // 예외 전달 설정 (설명은 이후에 추가) .exceptionHandling() .authenticationEntryPoint(jwtAuthenticationEntryPoint) // 커스텀 엔트리포인트 .accessDeniedHandler(jwtAccessDeniedHandler) // 커스텀 인가 실패 핸들링 .and() // JwtAuthenticationFilter 적용 .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class) .build(); }}WebSecurityCustomizer 는 필터체인의 앞단에 적용되며, 전체적으로 스프링 시큐리티 영향권의 밖에 있는 필터이다. 때문에 인증과 인가가 적용되지 않는 리소스 접근에 대해 사용할 수 있다. “favicon.ico” 외에도, Swagger 를 사용한다면 “/v2/api-docs”, “/swagger-resource/**”, “/swagger-ui.html”, “webjars/**“를, h2 DB를 사용한다면 “/h2/**” 를 추가하기도 한다.SecurityFilterChain 를 빈으로 등록해 필터체인을 설정한다. 다음은 각각의 필터에 대한 설명이다.csrf().disable(): 스프링 시큐리티의 csrf() 메서드는 기본적으로 CSRF 토큰을 발급해 클라이언트로부터 요청을 받을 때마다 토큰을 검사하는 방식으로 진행한다. REST API 에서는 CSRF 보안이 필요 없기 때문에 비활성화 하는 로직이다.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS): REST API 기반 애플리케이션의 동작 방식을 설정한다. JWT 토큰으로 인증을 처리하며 세션은 사용하지 않기 때문에 STATELESS로 설정하는 로직이다.authorizeRequests(): 애플리케이션에 들어오는 요청에 대한 사용 권한을 체크한다. ansMatchers()로 URI별 설정을 하고, 나머지에 대해선 anyRequest()로 설정한다. permitAll()은 해당 요청을 모두 허용한다는 것,hasRole(“[권한]”)은 특정 권한에 대해서만 허용한다는 것, 그리고 authenticated()는 인증된 권한을 가진 사용자에게만 허용한다는 것이다.exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint): 인증 과정에서 예외가 발생한 경우 예외를 전달한다.exceptionHandling().accessDeniedHandler(jwtAccessDeniedHandler): 권한을 확인하는 과정에서 통과하지 못하는 예외가 발생할 경우 예외를 전달한다. 커스텀 AccessDeniedHandler, AuthenticationEntryPoint@Componentpublic class JwtAccessDeniedHandler implements AccessDeniedHandler { @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException exception) throws IOException { response.sendRedirect(\"/exception\"); }}AccessDeniedException 은 액세스 권한이 없는 리소스에 접근할 경우 발생하는 예외이다. 이 예외를 처리하기 위해 AccessDeniedHandler 인터페이스가 사용되고, 앞의 SecurityConfiguration에서도 exceptonHandling() 메서드를 통해 추가했다. 위의 예제는 예외 발생시 “/exception”으로 리다이렉트 되도록 sendRedirect() 메서드를 활용하는 방식으로 구현되었다.@Componentpublic class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint { @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException { ObjectMapper objectMapper = new ObjectMapper(); EntryPointErrorResponse entryPointErrorResponse = new EntryPointErrorResponse(\"인증이 실패하였습니다.\"); response.setStatus(401); response.setContentType(\"application/json\"); response.setCharacterEncoding(\"utf-8\"); response.getWriter().write(objectMapper.writeValueAsString(entryPointErrorResponse)); }}///@Getter@AllArgsConstructor@ToStringpublic class EntryPointErrorResponse { private String message;}AuthenticationEntryPoint의 구조는 앞의 AccessDeniedHandler와 크게 다르지 않고, commence() 메서드를 오버라이딩 해 구현한다. 위의 예제는 예외 처리를 위해 직접 Response를 생성해 클라이언트에게 응답하는 방식으로 구현되었다. 만약 메시지를 설정할 필요가 없다면, 다음과 같이 response.sendError() 메서드로 인증 실패 코드만 전달할 수 있다.//... @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException { response.sendError(HttpServletResponse.SC_UNAUTHORIZED) }//...회원 가입과 로그인 기능의 컨트롤러와 서비스등 위의 구현 내용을 이어붙이는 것이기 때문에, 밑의 나머지 부분에 넣어 놓고 넘어가겠다.나머지* SignService```java@Service@AllArgsConstructorpublic class SignServiceImpl implements SignService { public UserRepository userRepository; public JwtTokenProvider jwtTokenProvider; // `@Configuration` 으로 BcryptEncoder를 등록시켜 주어야 한다. public PasswordEncoder passwordEncoder; @Override public SignUpResponseDto signUp(String username, String password, String email, String role) { SignUpResponseDto signUpResponseDto = new SignUpResponseDto(); User user = User.builder() .username(username) .password(passwordEncoder.encode(password)) .email(email) .role(role.equalsIgnoreCase(\"admin\") ? UserRole.ADMIN : UserRole.USER) .build(); User savedUser = userRepository.save(user); if (savedUser.getUsername().isEmpty()) { setFailResult(signUpResponseDto); return signUpResponseDto; } setSuccessResult(signUpResponseDto); return signUpResponseDto; } @Override public SignInResponseDto signIn(String username, String password) throws RuntimeException { User user = userRepository.findByUsername(username); if(!passwordEncoder.matches(password, user.getPassword())) { throw new RuntimeException(); } SignInResponseDto signInResponseDto = SignInResponseDto.builder() .token(jwtTokenProvider.createToken(String.valueOf(user.getUsername()), Set.of(user.getRole().getName()))) .build(); setSuccessResult(signInResponseDto); return signInResponseDto; } private void setSuccessResult(SignUpResponseDto responseDto) { responseDto.setSuccess(true); responseDto.setCode(0); responseDto.setMessage(\"Success\"); } private void setFailResult(SignUpResponseDto responseDto) { responseDto.setSuccess(false); responseDto.setCode(-1); responseDto.setMessage(\"Fail\"); }}```* SignController```java@RestController@RequestMapping(\"/sign-api\")@AllArgsConstructorpublic class SignController { private final SignService signService; private final Logger LOGGER = LoggerFactory.getLogger(SignController.class); @PostMapping(\"/sign-in\") public ResponseEntity signIn(@RequestBody SignInRequestDto requestDto) throws RuntimeException { SignInResponseDto responseDto = signService.signIn(requestDto.getUsername(), requestDto.getPassword()); return ResponseEntity.status(HttpStatus.OK).body(responseDto); } @PostMapping(\"sign-up\") public ResponseEntity createProduct(@RequestBody SignUpRequestDto requestDto) { SignUpResponseDto responseDto = signService.signUp(requestDto.getUsername(), requestDto.getPassword(), requestDto.getEmail(), requestDto.getRole()); return ResponseEntity.status(HttpStatus.OK).body(responseDto); } @GetMapping(\"/exception\") public void exceptionTest() throws RuntimeException { throw new RuntimeException(\"접근이 금지되었습니다.\"); } @ExceptionHandler(value = RuntimeException.class) public ResponseEntity&lt;Map&lt;String, String&gt;&gt; ExceptionHandler(RuntimeException e) {// HttpHeaders responseHeaders = new HttpHeaders();// responseHeaders.add(HttpHeaders.CONTENT_TYPE, \"application/json\"); HttpStatus httpStatus = HttpStatus.BAD_REQUEST; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"error type\", httpStatus.getReasonPhrase()); map.put(\"code\", \"400\"); map.put(\"message\", \"에러 발생\"); return ResponseEntity.status(httpStatus).body(map); }}```* PasswordEncoderConfiguration```java@Configurationpublic class PasswordEncoderConfiguration { // DB에 비밀번호 암호화해 저장 @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }}```* User 엔티티```java@Entity@Getter@NoArgsConstructor@AllArgsConstructor@Builder@Tablepublic class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String username; @JsonProperty(access = Access.WRITE_ONLY) @Column(nullable = false) private String password; @Column(nullable = false) private String email; @Column(name = \"role\") @Enumerated(EnumType.STRING) private UserRole role;}```* 그 외에 사용한 DTO들```java@Getter@AllArgsConstructorpublic class UserDto { private Long id; private String username; private String password; private String email; private UserRole role; public static UserDto from(User entity) { return new UserDto( entity.getId(), entity.getUsername(), entity.getPassword(), entity.getEmail(), entity.getRole() ); }}//-----@AllArgsConstructor@Getterpublic class SignInRequestDto{ private String username; private String password;}//-----@AllArgsConstructor@NoArgsConstructor@Builder@Getterpublic class SignInResponseDto extends SignUpResponseDto{ private String token;}//-----@AllArgsConstructor@NoArgsConstructor@Getterpublic class SignUpRequestDto { private String username; private String password; private String email; private String role;}//-----@AllArgsConstructor@NoArgsConstructor@Datapublic class SignUpResponseDto { private boolean success; private int code; private String message;}```&lt;/details&gt;## 마치며이 모든 과정에도 불구하고, JWT를 사용해 인증을 구현할 때에는 [주의를 요한다](https://velog.io/@thelm3716/JWTvul). 하지만 이 모든 주의사항을 숙지하고 방비한다면, JWT는 마이크로 서비스 아키텍처 기반 환경의 서비스에서 사용 가능한 안전하고 효율적인 인증 방식이 될 것이다.## 참고 자료**** [스프링 시큐리티 공식 레퍼런스 번역 문서](https://godekdls.github.io/Spring%20Security/contents/)* [[Spring] Security WebSecurityConfigurerAdapter Deprecated 해결하기](https://devlog-wjdrbs96.tistory.com/434)* [스프링 시큐리티 비밀번호 암호화 설정](https://franklee0180.tistory.com/42)* [SpringBoot + JWT + Security + JPA 인증 구현, JWT란?](https://aljjabaegi.tistory.com/659)" }, { "title": "[CS] IP & MAC: 컴퓨터에서 보낸 메시지는 길을 어떻게 찾아가지?", "url": "/posts/CS_IpAndMac/", "categories": "CS, Network", "tags": "CS, Network, IP", "date": "2023-02-08 09:00:00 +0900", "snippet": "개요“컴퓨터에서 보낸 메시지는 길을 어떻게 찾아가지?”라는 질문에 대해 보통은 IP 주소를 가지고 찾아간다고 한다. 하지만 이는 엄밀히 말하면 정확한 표현 방법이 아니다. 이번 글에서는 컴퓨터끼리 통신할 때 사용되는 기술들이 어떤 것이 있으며, 그 기술이 어떻게 사용되어 통신이 이루어지는지 알아보도록 하자.IP위 질문에 대답하기 위해서는, 네트워크 통신에 사용되는 프로토콜인 IP가 무엇인지 알아야 한다.정의IP(Internet Protocol)는 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 정보 위주의 규약이며, OSI 네트워크 계층에서 호스트의 주소 지정과 패킷 분할 및 조립 기능을 담당한다. 쉽게 이야기 하면, 메시지를 주고 받을 때 필요한 출발지와 도착지에 관한 정보를 어디에 어떻게 써 넣을지를 정해놓은 것이다.IP 주소여기서 이 ‘출발지’와 ‘도착지’를 표현해 놓은 것이 IP 주소이다. 정확히는, 네트워크 환경에서 컴퓨터(노드) 간 통신하기 위해 각 컴퓨터에 부여된 네트워크 상 주소이다.이 IP 주소가 결정되는 방식은 개인의 집 주소를 나라에서 정해주듯이, ‘한국 인터넷 정보 센터(KRNIC)’라는 기관에서 인터넷 사업체에게 IP를 할당해주고, 그 IP를 다시 해당 서비스의 사용자에게 할당해 주는 것으로 정해진다.IP 주소 체계IP 주소 체계는 IPv4와 IPv6로 나뉜다.IPv4둘 중 먼저 나온 것은 IPv4이다. 총 32비트 길이의 주소를 8비트씩 4부분으로 나누어 10진수로 바꾸고, .으로 구분해 표기한다. 최소 0.0.0.0 부터 최대 255.255.255.255가 나온다. 클래스 기반 할당IP 주소 체계가 처음 나왔을 때 사용한 방식이다. 장치가 속해 있는 네트워크를 구분하기 위해 클래스를 A, B, C, D, E 총 5개로 나누었고, IP 주소의 앞 부분은 네트워크 주소, 나머지 부분은 컴퓨터에 부여하는 호스트 주소로 구성되어 있다.위 도표를 보면 알 수 있듯, 주소의 첫 비트가 0이면 클래스 A, 두번째 비트가 0 이면 클래스 B 인 방식이다. 클래스에 따라 네트워크 주소를 표현하는데 사용하는 바이트 갯수가 달라서, 클래스마다 사용할 수 있는 호스트 주소 갯수도 다르다.IPv6하지만 컴퓨터의 보급률이 늘어나고, IP 주소를 필요로 하는 장치가 많아지면서 발급해 줄 IP가 부족하게 되었는데, 이를 해소하기 위해 나온 방식 중 하나가 IPv6이다.IPv6는 총 128비트 길이의 주소를 16비트씩 8부분으로 나누어 16진수로 바꾸고, :으로 구분해 표기한다.길이가 길어진 만큼 표현할 수 있는 주소의 갯수도 급수적으로 늘어났다. 2^32 와 2^128 의 차이인 것이다.문제는 아직까지도 IPv4에서 IPv6로의 전환이 완료되지 않았다는 점이다. 아직까지도 많은 라우터들은 IPv4를 사용한다. IPv6로의 전환은 많은 시간과 비용이 들기 때문에 완료되기까지 적지 않은 세월이 걸릴 것이다. 현재는 IPv4와 IPv6를 혼용해서 사용하는데, IPv4 라우터에서는 tunneling이라는 방식을 사용해 IPv6 데이터그램을 전송한다.NATIP 주소 부족을 해결하는 또 다른 방식으로는 NAT가 있다.NAT(Network Address Translation)은 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정해 IP 주소를 다른 주소로 매핑하는 방법이다. 이 방식을 사용하면 공인 IP 하나만으로 사설 IP를 여러개 두어 많은 주소를 처리할 수 있게 된다. NAT가 사용된 대표적인 장치로 인터넷 공유기가 있다.DHCP또, 클래스 기반 할당 방식은 사용하는 주소보다 버리는 주소가 많다는 단점이 있었는데, 이를 해결하기 위해 나온 것이 DHCP 이다.DHCP(Dynamic Host Configuration Protocol)는 IP 주소, 서브넷마스크, 게이트웨이 등 TCP/IP 프로토콜의 기본 설정 값들을 자동으로 할당하기 위한 네트워크 관리 프로토콜이다. 이 기술을 통해 IP 주소를 수동으로 설정할 필요 없이 인터넷에 접속할 때마다 자동으로 IP 주소를 할당받을 수 있다.MAC위에서 설명했듯, IP는 회선의 주소일 뿐 컴퓨터의 주소가 아니다. IP 주소로만 통신하는 것은, 편지를 보내는데 동호수 없이 아파트 이름만 적어 놓고 보내는 것과 비슷하다. 때문에 통신에 사용될 세부적인 주소가 필요한데, 이 때 사용되는 것이 MAC(Media Access Control) 주소이다.MAC 주소MAC 주소는 하드웨어에 부여된 고유한 식별 번호이다. 이 주소는 하드웨어를 생산할 때 부여되는 것으로 임의로 바뀌는 것이 아니다. 따라서 인터넷 상의 장치들의 실제 주소를 식별하는 용도로 사용된다.MAC 주소는 48비트 길이의 주소를 8비트씩 6부분으로 나누어 16진수로 바꾸어 표기한다. 구분자는 :, -, . 등 다양하게 사용된다.ARP그렇다면 컴퓨터는 IP만 가지고 어떻게 상대방 컴퓨터로 데이터를 전송하는 걸까? 네트워크 단에서 IP 주소로 MAC 주소를 검색할 수 있도록 해주는 프로토콜을 통해 주소를 바꾸어 통신하는데, 이 프로토콜을 ARP 라고 한다.ARP(Address Resolution Protocol)는 IP 주소를 통해 MAC 주소를 얻을 수 있도록 다리 역할을 해주는 프로토콜이다. ARP를 통해 가상 주소인 IP 주소를 실제 주소인 MAC 주소로 변환하고, 반대로 RARP를 통해 실제 주소인 MAC 주소를 가상 주소인 IP 주소로 변환하기도 한다.이 때 변환은 다음과 같은 방식으로 이루어진다: 데이터를 전송하려는 장치는 보낼 IP에 대해 ARP Request 브로드캐스트(네트워크에 연결된 모든 호스트에 전송)를 보낸다. 해당 주소에 맞는 장치는 ARP Reply 유니캐스트(정해진 호스트로 1:1 전송)를 통해 MAC 주소를 반환한다.마무리이제 처음의 질문에 대한 좀 더 정확한 대답을 해보자면, “컴퓨터는 ARP를 통해 IP 주소에서 MAC 주소를 찾고, 해당 MAC 주소를 기반으로 통신한다”고 할 수 있다.참고 자료 [[네트워크] IP,IP 클래스, IPv4, IPv6이란? IP 클래스 구분](https://code-lab1.tistory.com/33) https://jhnyang.tistory.com/404" }, { "title": "[CS] TCP/IP: 인터넷에서 컴퓨터들이 정보를 주고 받을 때 쓰이는 프로토콜들에 대해 알아보자", "url": "/posts/CS_TCPIP/", "categories": "CS, Network", "tags": "CS, Network, TCP/IP", "date": "2023-02-07 09:00:00 +0900", "snippet": "개요사람들과 마찬가지로, 컴퓨터들도 서로 의사소통 하기 위해 공통된 규칙이 있어야 한다. 컴퓨터가 사용하는 규칙을 프로토콜이라고 하며, 용도에 따라 나뉘면서 많은 프로토콜이 존재한다. 이런 많은 프로토콜에 대한 합의된 표준이 필요하게 되어 나오게 된게 TCP/IP 이다. TCP/IP는 보통 컴퓨터에 내장되어있고 대부분 알아서 동작하긴 하지만, 그 동작 원리는 알아 둘 필요가 있다.TCP/IPTCP/IP를 한마디로 설명하자면, 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 규약의 모음이다. 데이터의 흐름에 따라 4개의 계층 구조로 나누며, 규칙이나 프로토콜이 적용되는 특정한 조건들을 규정하고 있다.계층구조TCP/IP의 4개의 계층 구조는 OSI 7계층과 비교 된다.TCP/IP는 애플리케이션 계층, 전송 계층, 인터넷 계층, 링크 계층으로 나뉜다.TCP/IP 계층과 달리, OSI 계층은 애플리케이션 계층을 세 개로 쪼개고 링크 계층을 데이터 링크 계층, 물리 계층으로 나눠서 표현하는 것이 다르고, 인터넷 계층을 네트워크 계층으로 부른다는 것이 다르다.애플리케이션 계층애플리케이션 계층은 웹 서비스, 이메일 등 서비스를 실질적으로 사람들에게 제공하는 데 사용되는 프로토콜에 대한 계층이다. 대표적으로 다음과 같은 프로토콜들이 있다. FTP: 장치와 장치 간 파일 전송 HTTP: WWW를 위한 데이터 통신 SMTP: 전자 메일 전송 DNS: 도메인과 IP 주소를 매핑전송 계층전송 계층은 송신자와 수신자를 연결하는 통신 서비스를 제공하고, 애플리케이션과 인터넷 계층 사이 데이터를 전달할 때 사용되는 프로토콜에 대한 계층이다. 연결 지향 데이터 스트림을 지원하고, 신뢰성과 흐름 제어를 제공하기도 한다. 대표적으로 TCP와 UDP가 있다. TCP: 연결 지향적 프로토콜로, 안정적으로, 순서대로, 에러 없이 교환할 수 있도록 ‘가상회선 패킷 교환 방식’을 사용해 데이터를 전달하는 프로토콜이다.TCP는 신뢰성을 확보하기 위해 연결할 때 ‘3 웨이 핸드셰이크’라는 작업을 진행한다. 클라이언트는 서버에 접속을 요청하는 SYN을 보낸다. 이 때 패킷의 순서를 알기 위해 패킷에 임의의 숫자로 ISN를 보낸다. 서버는 SYN을 받고 ISN에 1을 더해 SYN+ACK에 담아 보낸다. 클라이언트는 다시 ISN에 1을 더해 서버에게 ACK을 보낸다.TCP는 이렇게 신뢰성이 구축된 상태에서 데이터 전송을 시작한다.연결을 해제할 때에는 ‘4 웨이 핸드셰이크’를 진행한다. 클라이언트는 FIN을 보낸다. (클라이언트는 FIN_WAIT_1 상태) 서버는 ACK를 클라이언트에게 보낸다. (서버는 CLOSE_WAIT 상태, 클라이언트는 수신 후 FIN_WAIT_2로 전환) 서버는 일정 시간 후 클라이언트에게 FIN을 보낸다.(서버는 LAST_ACK 상태) 클라이언트는 서버에게 ACK를 보낸다.(클라이언트는 TIME-WAIT 상태, 서버는 수신 후 CLOSED로 전환, 클라이언트도 일정 시간 후 CLOSED로 전환) UDP: 비연결형 프로토콜로, 안정적이진 않아도 빠르게 교환할 수 있도록 ‘데이터그램 패킷 교환 방식’을 사용해 데이터를 전달하는 프로토콜이다.인터넷 계층인터넷 계층은 장치로부터 받은 패킷을 지정된 목적지로 전송할 때 사용되는 프로토콜에 대한 계층이다. 상대방이 제대로 받았는지에 대해 보장하지 않는 비연결형적인 특징을 가지고 있다.대표적으로 IP, ARP, ICMP 등의 프로토콜이 있다.링크 계층장치 간에 신호를 주고받는 규칙을 정하는 프로토콜에 대한 계층이다. 유선 LAN 혹은 무선 LAN을 통해 0과 1로 이루어진 데이터를 보내며, ‘이더넷 프레임’을 통해 에러 확인, 흐름 제어, 접근 제어를 담당한다. 대표적인 프로토콜로 이더넷이 있다. 유선 LAN을 이루는 이더넷은 IEEE802.3이라는 프로토콜을 따르고, 전이중화 통신(통신의 양쪽 장치가 동시에 송수신할 수 있는 방식)을 쓴다. 무선 LAN을 이루는 이더넷은 IEEE802.11이라는 프로토콜을 따르고, 송수신이 같은 채널을 사용하기 때문에 반이중화 통신(한 번에 한 방향만 통신할 수 있는 방식)을 쓴다. 이더넷이란, 원칙적으로 하나의 인터넷 회선에 공유기 등의 통신장비를 설치해 다수의 시스템이 LAN으로 연결되어 통신이 가능한 네트워크 구조이다. 이더넷 프레임 전달받은 데이터의 에러를 검출하고 캡슐화한다. Preamable: 이더넷 프레임 시작 SFD: 다음 바이트부터 MAC DMAC, SMAC: 수신 송신 MAC EtherType: IP 프로토콜 정의, IPv4, IPv6 Payload: 데이터 CRC: 에러 확인 비트 PDUPDU(Protocol Data Unit)란, 네트워크의 계층 간 데이터가 전달될 때, 한 덩어리의 단위를 말한다. 제어 관련 정보들이 포함된 헤더, 데이터를 의미하는 페이로드로 구성되어 있다. 각 계층마다 캡슐화 되는 데이터와 추가되는 헤더가 다르기에, 명칭도 달라진다. 애플리케이션 계층 : 메시지 전송 계층 : 세그먼트(TCP), 데이터그램(UDP) 인터넷 계층 : 패킷 링크 계층 : 프레임(데이터 링크 계층), 비트(물리 계층) 캡슐화란, 상위 계층의 데이터와 헤더를 하위 계층의 데이터로 포함시키고 헤더를 삽입하는 과정을 말한다. 예상 질문 TCP/IP 에 대해 설명해주세요.답변1. TCP/IP는 프로토콜이라는, 컴퓨터끼리 서로 의사소통하기 위해 정해놓은 규칙들의 모음입니다.2. 데이터의 흐름에 따라 4계층으로 나뉘는데, 각각 애플리케이션 계층, 전송 계층, 인터넷 계층, 링크 계층으로 나뉩니다. * 애플리케이션 계층은 서비스를 실질적으로 사람들에게 제공하는 데 사용되는 프로토콜에 대한 계층이며, HTTP, SMTP 같은 프로토콜이 여기에 속합니다. * 전송 계층은 신뢰성 있는 데이터 전송을 보장하는 프로토콜에 대한 계층이며, TCP, UDP 등이 여기에 속합니다. * 인터넷 계층은 데이터의 목적지를 설정하는 프로토콜에 대한 계층이며, IP, ARP 등이 여기에 속합니다. * 링크 계층은 데이터를 전기 신호로 변환해 MAC 주소로 알맞은 기기까지 데이터를 전송하는 프로토콜에 대한 계층입니다. 이더넷, WIFI가 여기에 속합니다. TCP/IP 모델에서 계층을 나누는 이유에 대해 설명해주세요.답변1. 각 계층별 처리 역할이 다르기 때문에, 계층별 간섭을 최소화할 수 있습니다. 2. 특정 계층에서 문제가 생기더라도 해당 계층만 살펴보면 되기 때문에, 유지 보수가 편리합니다.3. 다른 계층끼리는 데이터의 전달 과정을 구체적으로 알 필요가 없기 때문에, 데이터의 캡슐화와 은닉이 가능합니다. www.google.com 을 웹 브라우저에 입력하면 무슨 일이 일어나나요?답변1. HTTP 헤더는 HTTP Request를 통해 채워 진 상태입니다.2. IP 헤더를 채우기 위해 DNS 서버에 접속해 구글 도메인의 IP 주소를 받습니다.3. TCP 헤더를 채우기 위해 구글과 3-웨이 핸드셰이크로 TCP 연결을 합니다.4. 패킷을 보내 구글로부터 HTML 응답을 받습니다.5. 응답 받은 HTML을 브라우저에 띄우고 4-웨이 핸드셰이크로 TCP 연결을 종료합니다. TCP와 UDP의 차이점에 대해 설명해주세요.답변1. 둘 모두 TCP/IP 네트워크 모델의 4계층 중 전송 계층에서 사용되는 프로토콜입니다. 2. TCP는 연결 지향적 프로토콜로, 안정적으로, 순서대로, 에러 없이 교환할 수 있도록 가상 회선을 만들어 데이터를 전달합니다. 데이터를 제대로 수신했는지 확인하는 과정이 있어 속도는 느립니다.3. UDP는 비연결형 프로토콜로, 안정적이진 않아도 빠르게 교환할 수 있도록, 데이터의 수신 여부를 상관하지 않고 데이터를 전달하는 프로토콜입니다. 3-웨이 핸드셰이크와 4-웨이 핸드셰이크는 무엇인가요? 3-웨이 핸드셰이크는 클라이언트가 서버에 TCP 프로토콜로 연결할 때, 데이터의 신뢰성을 보장하기 위해 하는 작업입니다. 클라이언트는 ISN으로 사용할 임의의 숫자를 담아 SYN을 보냅니다. 서버는 클라이언트에게 ISN에 1을 더해 SYN + ACK(씬애크)를 보냅니다. 클라이언트는 다시 1을 더해 ACK를 보낸 뒤, 데이터 전송을 시작합니다. 4-웨이 핸드셰이크는 연결을 종료할 때 진행하는 작업입니다. 클라이언트는 FIN 을 보내고 FIN_WAIT_1 상태로 변합니다. 서버는 응답으로 ACK를 보내고 CLOSE_WAIT 상태로 변하고, 응답을 받은 클라이언트는 FIN_WAIT_2 상태로 변합니다. 서버는 일정 시간 후에 FIN을 보내고 LAST_ACK 상태로 변합니다. 클라이언트는 마지막으로 ACK를 보내고 혹시라도 늦게 도착하는 패킷이 있는지 기다리기 위해 TIME_WAIT으로 들어갔다가 CLOSED로 끝냅니다. ACK를 받은 서버도 CLOSED로 끝내며 연결을 해제합니다. 참고 자료 What is TCP/IP and How Does it Work? [기술면접] TCP와 UDP [Network] TCP/IP 와 TCP/IP 4계층이란? [네트워크] TCP/UDP와 3 -Way Handshake &amp; 4 -Way Handshake" }, { "title": "[CS] 네트워크의 기초", "url": "/posts/CS_Network/", "categories": "CS, Network", "tags": "CS, Network", "date": "2023-02-06 09:00:00 +0900", "snippet": "네트워크네트워크는 두 대 이상의 장치들을 연결해 서로 리소스를 공유할 수 있는 집합을 지칭하는 용어다. 네트워크 장치들을 노드라고 하며, 유선 또는 무선 연결을 링크라고 한다. 좋은 네트워크의 기준은 많은 처리량을 처리할 수 있고, 지연시간이 짧고, 장애 빈도가 적으며, 좋은 보안을 갖추어야 한다.기본 용어 정리처리량처리량(throughput)은 링크 내에서 전달된 데이터의 양을 말한다. 단위는 시간당으로 계산해 bps(bits per second)를 사용한다. 처리량은 대역폭, 에러, 하드웨어 스펙, 트래픽 크기 등에 영향을 받는다.트래픽트래픽(traffic)이란 네트워크 장치에서 일정 시간 내에 흐르는 데이터의 양을 말한다. 웹사이트에 트래픽이 많다는 것은 사용자 접속이 많아서 전송하는 데이터의 양이 많다는 것을 뜻한다.대역폭대역폭(bandwidth)는 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트의 수를 말한다. 즉, 속도 보다는 용량과 관계되어 있다고 할 수 있다.지연 시간지연 시간(latency)이란 요청이 처리되는 시간, 즉 어떤 메시지가 두 장치 사이를 왕복하는 데 걸린 시간을 말한다. 매체 타입(무선, 유선), 패킷 크기, 라우터의 패킷 처리 시간에 영향을 받는다.네트워크 토폴로지네트워크 토폴로지란, 네트워크를 이루는 노드와 링크가 배치 되어있는 형태를 의미한다. 종류로는 트리, 버스, 스타, 링, 메시 등이 있다.종류 트리 토폴로지트리 형태로 배치한 네트워크 구성을 말한다.장점: 노드의 추가, 삭제가 쉬워 관리와 확장이 용이하다.단점: 한 노드에서 다른 한 노드로 연결되는 길이 하나라서, 그 가운데 한 노드라도 트래픽이 집중되거나 고장 나는 등 문제가 발생하면 통신에 영향을 받는다. 버스 토폴로지중앙 통신 회선 하나에 여러 개의 노드가 연결되어 공유하는 네트워크 구성이다.장점: 노드의 추가와 삭제가 쉬우며, 노드의 고장이 통신망에 영향을 주지 않는다.단점: 패킷을 악의적으로 다른 노드로 전달하는 공격인 스푸핑이 가능해진다. 스타 토폴로지중앙에 있는 노드(허브)에 다른 모든 노드가 연결된 네트워크 구성이다.장점: 중앙 집중 제어로 노드의 추가 삭제 및 에러 탐지가 쉽다. 허브를 제외한 노드의 고장이 통신에 영향을 주지 않는다.단점: 허브가 고장나면 모든 통신이 마비된다. 설치 비용이 높다. 링형 토폴로지각각의 노드가 양 옆의 두 노드와 연결되어 하나의 연속된 길을 통해 통신하는 네트워크 구성이다.장점: 노드 수가 증가해도 네트워크상의 손실이 거의 없고, 충돌 발생 가능성도 적다.단점: 네트워크 구성 변경이 어렵고, 장애 발생시 전체 네트워크에 영향을 크게 끼친다. 메시 토폴로지그물망처럼 연결된 네트워크 구성이다.장점: 노드로 통하는 경로가 여러가지 존재해서, 한 노드에 장애가 발생해도 전체 네트워크가 받는 영향은 상대적으로 적다. 트래픽도 분산 처리할 수 있다.단점: 노드의 추가가 어렵고, 구축과 운용 비용이 높다.병목현상병목 현상은 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상을 말한다. 서비스에서 이벤트를 열었을 때 트래픽이 많이 생기고 그 트래픽을 잘 관리하지 못하면 병목 현상이 일어난다. 사용자는 늘어진 지연 시간을 겪거나, 심하면 서비스에 접근하지 못하게 된다.네트워크 토폴로지는 이 병목 현상을 찾을 때 중요한 기준이 된다. 특정 노드에 트래픽이 몰려 병목 현상이 발생했을 때, 어떤 노드 사이에 회선을 추가해야 병목 현상을 해결할 수 있는지 판별할 수 있기 때문이다.네트워크 토폴로지 외에도, 네트워크 대역폭, 서버 CPU 및 메모리 사용량, 비효율적 네트워크 구성 등이 병목 현상의 주된 원인이다.네트워크 분류네트워크는 규모를 기준으로 LAN, MAN, WAN 으로 나눌 수 있다. LAN (Local Area Network)은 근거리 영역 네트워크를 의미한다. 건물이나 캠퍼스 등의 좁은 공간에서 운영되어 전송 속도가 빠르고 혼잡하지 않다. MAN (Metropolitan Area Network)은 대도시 영역 네트워크를 의미한다. 전송 속도는 평균이며, LAN보다는 더 혼잡하다. WAN (Wide Ares Network)은 광대역 네트워크를 의미한다. 국가 또는 대륙 같은 넓은 지역에서 운영되어 전송 속도는 낮으며, MAN보다 더 혼잡하다.네트워크 성능 분석 명령어애플리케이션 코드 상에는 전혀 문제가 없는데 사용자가 서비스로부터 데이터를 가져오지 못하는 상황이 발생한다면, 이는 네트워크 병목현상일 가능성이 있다. 그런 상황에서 네트워크 성능 분석에 도움이 되는 명령어들로 다음과 같은 명령어가 있다.pingping(Packet INternet Groper)은 네트워크 상태를 확인하려는 대상 노드를 향해 일정 크기의 패킷을 전송하는 명령어이다. 해당 노드까지 네트워크가 잘 연결 되어 있는지, 또 패킷 수신 상태와 소요 시간 등을 알 수 있다.ping은 TCP/IP 프로토콜 중 ICMP 프로토콜을 통해 동작하기 때문에, 다음 두 경우에는 ping 테스트가 불가능하다: ICMP 프로토콜을 지원하지 않는 기기를 대상으로 테스트할 경우 네트워크 정책상 ICMP나 traceroute를 차단하는 대상의 경우ping 테스트는 ping [IP 혹은 도메인 주소] 를 입력해 실행할 수 있다.$ ping www.google.com -n 12Ping www.google.com [142.250.207.100] 32바이트 데이터 사용:142.250.207.100의 응답: 바이트=32 시간=30ms TTL=55142.250.207.100의 응답: 바이트=32 시간=30ms TTL=55142.250.207.100의 응답: 바이트=32 시간=29ms TTL=55142.250.207.100의 응답: 바이트=32 시간=29ms TTL=55142.250.207.100의 응답: 바이트=32 시간=29ms TTL=55142.250.207.100의 응답: 바이트=32 시간=30ms TTL=55142.250.207.100의 응답: 바이트=32 시간=30ms TTL=55142.250.207.100의 응답: 바이트=32 시간=30ms TTL=55142.250.207.100의 응답: 바이트=32 시간=30ms TTL=55142.250.207.100의 응답: 바이트=32 시간=30ms TTL=55142.250.207.100의 응답: 바이트=32 시간=29ms TTL=55142.250.207.100의 응답: 바이트=32 시간=30ms TTL=55142.250.207.100에 대한 Ping 통계: 패킷: 보냄 = 12, 받음 = 12, 손실 = 0 (0% 손실),왕복 시간(밀리초): 최소 = 29ms, 최대 = 30ms, 평균 = 29ms위 코드 블럭은 구글에 대해 12번의 ping 테스트를 진행하는 ping www.google.com -n 12 명령어에 대한 결과이다.TTL(Time To Live)은 패킷의 남은 수명을 의미한다. 설정값이 64고, 받은 패킷의 TTL이 55라면, 9개의 노드를 거쳐 도달했다는 의미이다.netstatnetstat 명령어는 접속되어 있는 서비스들의 네트워크 상태를 표시하는 데 사용된다. 네트워크 접속, 라우팅 테이블, 네트워크 프로토콜 등 리스트를 보여준다.$ netstat활성 연결 프로토콜 로컬 주소 외부 주소 상태 TCP 127.0.0.1:1024 kubernetes:1025 ESTABLISHED TCP 192.168.45.###:2769 20.198.119.###:https ESTABLISHED TCP 192.168.45.###:9564 211.115.106.###:http CLOSE_WAIT TCP 192.168.45.###:9566 20.198.2.###:https TIME_WAIT...위 코드 블럭은 netstat 입력했을 때 보여주는 네트워크 상태 리스트 중 일부이다.nslookupnslookup 명령어는 DNS에 관련된 내용을 확인할 때 사용하는 명령어다. 특정 도메인에 매핑된 IP를 확인할 수 있다.$ nslookup기본 서버: bns1.hananet.netAddress: 210.220.163.82&gt; google.com서버: bns1.hananet.netAddress: 210.220.163.82권한 없는 응답:이름: google.comAddresses: 2404:6800:400a:805::200e 142.250.206.206tracerttracert(리눅스에선 traceroute)는 지정된 호스트에 도달할 때까지 통과하는 경로의 정보와 각 경로에서의 지연 시간을 추적하는 네트워크 명령어이다. 목적지 노드까지 네트워크 경로를 확인하거나, 그 구간 중 어디에서 지연이 발생하는지 확인할 수 있다.$ tracert www.google.com최대 30홉 이상의www.google.com [172.217.161.228](으)로 가는 경로 추적: 1 &lt;1 ms &lt;1 ms &lt;1 ms 192.168.45.1 2 * * * 요청 시간이 만료되었습니다. 3 5 ms 5 ms 5 ms 1.229.241.65 4 5 ms 2 ms 3 ms 100.79.121.93 5 2 ms 1 ms 2 ms 100.79.220.85 6 2 ms 1 ms 2 ms 10.45.253.64 7 2 ms 2 ms 2 ms 10.222.25.64 8 2 ms 2 ms 2 ms 10.222.20.143 9 34 ms 33 ms 33 ms 142.250.162.182 10 33 ms 34 ms 33 ms 108.170.242.193...위 코드 블럭은 구글 사이트에 도달하기 까지의 경로를 추적한 모습 중 일부이다.네트워크 프로토콜 표준화네트워크 프로토콜이란, 다른 장치들끼리 데이터를 주고받기 위해 설정된 공통된 인터페이스를 말한다. 해당 표준은 IEEE(전기 전자 기술자 협회)와 같은 표준화 단체가 결정한다.프로토콜의 대표적인 예로는 다음과 같은 것들이 있다: HTTP: 하이퍼텍스트(HTML)를 통해 전송하는 규약 FTP: 파일을 주고 받기 위한 규약 SSL: 인증, 암호화 등의 규약 TCP: 정보 전달을 안전하게 할 수 있도록 하는 규약 UDP: 빠르게 데이터를 주고 받을 수 있도록 하는 규약 IP: 호스트의 주소 지정과 패킷을 분할하고 조립하는 규약예상 질문 네트워크에 대해 설명해 주세요.답변둘 이상의 장치가 유선 또는 무선으로 연결되어 같은 리소스를 공유하는 집합입니다.참고 자료 Network bandwidth의 개념과 Throughput 과의 차이 트래픽, 처리량, 대역폭에 대한 질문 [네트워크 기초] 네트워크 기초 명령어(ping, tracert등) [Network] 프로토콜(Protocol)이란? (What is a protocol?)" }, { "title": "[CS] 프로그래밍 패러다임: 객체 지향은 뭐고, 함수형은 뭔데?", "url": "/posts/CS_ProgrammingParadigm/", "categories": "CS, Programming Paradigm", "tags": "CS, Programming Paradigm", "date": "2023-02-03 09:00:00 +0900", "snippet": "개요어떤 문제를 코딩으로 해결하는 접근 방법은 한 가지만 존재하지 않는다. 같은 문제라도 단순히 A의 실행이 끝나면 B를 실행하도록 하는 방법이 있는가 하면, 실생활의 사물에 빗대어 서로 상호작용하는 것처럼 만드는 방법도 있다. 이렇게 프로그램을 개발하는 방법들을 프로그래밍 패러다임 이라고 부른다. 이번에는 각각의 패러다임이 지니는 특징과 지켜야할 원칙 등을 알아보도록 하겠다.분류프로그래밍 패러다임은 크게 명령형(Imperative), 선언형(Declarative)으로 나뉘고, 또 명령형은 절차지향(Procedural), 객체지향(Object-Oriented) 등의 하위 집합으로, 선언형은 함수형(Functional), 논리형(Logic) 등으로 나뉜다. 각각의 소분류에서 대표적인 패러다임 몇 가지만 소개하겠다.절차형 프로그래밍개념절차적 프로그래밍 패러다임(Procedural Programming Paradigm)은 가장 원시적인 접근법으로, 문제 해결에 필요한 절차들을 차례대로 해결해 나가도록 구성하는 패러다임이다.특징 과정이 그대로 코드로 구현되어있기 때문에 가독성이 좋고, 실행 속도가 빠르다. 겹치는 부분이 많은 두 개의 비슷한 로직이라도 모두 처음부터 끝까지 구현되어있어 모듈화 하기가 어렵고, 때문에 유지 보수가 어렵다.대표 언어 C, C++객체 지향 프로그래밍개념객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 프로그램을 상태와 행위로 이루어진 객체로 만들어, 그 객체끼리 상호작용을 하며 문제를 해결하도록 구성하는 패러다임이다.특징 객체 지향 프로그래밍의 특징 4가지: 캡슐화: 객체의 속성(= 데이터)와 메서드(= 데이터를 처리하는 행위)를 하나로 묶고, 외부에는 그 세부 내용을 공개하지 않음으로 데이터의 직접 접근을 막는 것. 자바의 퍼블릭과 프라이빗 상속성: 다른 클래스가 가진 속성와 메서드를 받아 재사용하거나, 필요한 것을 더 추가할 수 있는 것. 자바의 익스텐드 추상화: 복잡한 객체로부터 핵심적인 개념이나 기능을 간추려내는 것. 자바의 인터페이스와 임플리먼트 다형성: 같은 메서드가 상황에 따라 다른 기능을 수행하는 것. 자바의 오버로딩과 오버라이딩 오버로딩: 같은 이름을 가지지만 다른 매개변수(갯수나 타입)를 받는 메서드를 여러 개 만들어, 같은 클래스에서 같은 메서드를 호출해도 다른 매개변수를 받을 때 다른 기능을 수행할 수 있도록 만드는 것. 커피 메이커라는 클래스의 커피_줘() 라는 메서드는 커피콩만 받으면 아메리카노를, 커피콩과 우유를 받으면 라떼를 준다. 오버라이딩: 다른 클래스로부터 받은 메서드를 다시 만들어, 다른 클래스에서 같은 메서드를 호출할 때 다른 기능을 수행할 수 있도록 만드는 것. 커피 메이커를 상속받은 아메리카노 메이커와, 라떼 메이커는 커피_줘()라는 같은 이름의 메서드를 가지고 있지만, 실행하면 각각 아메리카노와 라떼를 준다. 위의 특징들 덕분에 모듈화가 쉽고, 때문에 유지보수가 쉽다. 설계에 많은 시간이 소요되며, 처리 속도가 다른 패러다임에 비해 느리다.설계 원칙위에서 언급한 특징을 지니게 하려면 다섯 가지 설계 원칙을 지켜야 하는데, 이 다섯가지 원칙의 영어 이니셜을 따와 SOLID 원칙이라고 부른다. Single Responsibility Principle(단일 책임 원칙, SRP) 모든 클래스는 각각 하나의 책임만 가져야 한다는 원칙이다. 각각 기능A와 기능B를 위해 만들어진 클래스1과 클래스2가 있다고 할 때, 기능B의 수정이 클래스2에서 일어난다 해도 클래스1에서는 수정이 일어나지 않도록 설계하는 것이다. Open Closed Principle(개방 폐쇄 원칙, OCP) 수정에는 닫혀있고, 확장에는 열려있도록 해야 한다는 원칙이다. 어떤 기능을 추가할 때 기존 코드를 수정하지 않고도 추가할 수 있게 설계하는 것이다. Liskov Substitution Principle(리스코프 치환 원칙, LSP) 상위 클래스를 상속받은 하위 클래스는 상위 클래스의 자리에 대신해 들어가도 문제없이 작동할 수 있도록 만들어야 한다는 원칙이다. Interface Segregation Principle(인터페이스 분리 원칙, ISP) 하나의 일반적인 인터페이스보다, 구체적인 여러 개의 인터페이스를 만들어야 한다는 원칙이다. 인터페이스를 너무 범용적으로 만들어서 사용하지도 않는 메서드를 구현하지 않도록, 인터페이스를 작고 구체적이게 설계하는 것이다. Dependency Inversion Principle(의존 역전 원칙, DIP) 상위 패키지가 변하기 쉬운 하위 패키지를 의존하지 않도록 만들어야 한다는 원칙이다. 인터페이스는 상위 패키지에, 그 구현체는 하위 패키지에 두어 인터페이스가 하위 패키지에서 구현되도록 설계하는 것이다. 이렇게 만들면 하위 패키지에 수정이 필요해도, 하위 패키지를 직접 수정하지 않고 새로운 패키지를 만들어 갈아 끼울 수 있다. 대표 언어Java, C# 등함수형 프로그래밍개념문제를 작게 나누고 그 작은 문제를 해결하는 함수들을 연결하는 것으로 문제를 해결하는 패러다임이다.예를 들어, 입력값 x와 y를 받아 x^y의 값을 반환하는 기능을 구현한다고 하자. 절차형 프로그래밍은 x값을 받아 저장해놓고 y값을 받아 x^y의 계산 값을 반환하는 방식이다. 함수형 프로그래밍은 x값을 받아 x^?를 계산하는 함수를 만들고, 그 반환된 함수를 실행시켜 나머지 y값을 받아 계산해서 값을 반환하는 방식이다.특징 순수 함수로만 이루어져 있다. 순수 함수란, 출력이 입출력에만 의존하고, 다른 저장된 값을 사용하지 않는다는 것을 의미한다. 부수 효과가 없다. 부수 효과란, 함수가 다른 저장된 값을 사용해 그 값이 바뀌면 반환 값이 바뀌는 것을 의미한다. 고차 함수로 로직을 구현한다. 고차함수란 함수 자체를 값처럼 매개변수로 받아 로직을 생성하는 함수를 말한다. 고차 함수를 쓰기 위해선 언어가 일급 객체라는 특징을 가져야 한다. 변수나 메서드에 함수를 할당할 수 있다. 함수 안에 함수를 매개변수로 담을 수 있다. 함수가 함수를 반환할 수 있다. 자바는 함수형 인터페이스를 제공함으로 함수형 프로그래밍을 가능케 한다. 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 해준다. 부수 효과가 없는 순수 함수로 이루어져있어, 스레드에 안정성을 보장하고, 때문에 병렬처리를 동기화 없이 진행할 수 있다.구현 언어 클로저(Clojure), 스칼라(Scala) 등예상 질문 객체 지향 언어에 대해 설명해주세요.흐름1. 객체 지향이 어떤 환경에서 사용되는 언어인지 설명2. 해당 환경에 대해 설명답변1. 객체 지향 언어는 자바나 자바스크립트와 같이 객체 지향 프로그래밍 환경에서 사용되는 프로그램 언어를 말합니다.2. 객체 지향 프로그래밍은 프로그래밍 방법론의 하나로, 프로그램을 속성과 행위로 이루어진 객체로 나눠 객체끼리 상호작용을 통해 문제를 해결해 나가도록 설계하는 방법입니다. 객체 지향 언어의 특징과 장단점을 설명해주세요.흐름1. 객체 지향 언어 특징 4가지 설명2. 장점 설명3. 단점 설명답변1. 객체 지향 프로그래밍의 특징으로는 캡슐화, 상속성, 추상화, 다형성이 있습니다. 캡슐화란 객체의 속성와 행위의 일부를 외부에 감추는 것이고, 상속성은 다른 객체의 속성과 행위를 받아와 사용하거나 재정의 함으로 재사용성을 높이는 것, 추상화란 복잡한 시스템으로부터 핵심적인 기능만 간추려내는 것, 그리고 다형성은 객체나 그 행위가 상황에 따라 다르게 동작하는 것입니다. 2. 장점은 코드를 객체로 모듈화함으로 재사용이 쉽고, 따라서 생산성이 향상됩니다. 또, 캡슐화라는 특성 덕에 유지보수가 쉽습니다.3. 하지만 단점은 설계에 시간이 오래 걸린다는 점, 또 처리 속도가 상대적으로 느리다는 점이 있습니다. 객체 지향 프로그래밍에서 지켜야할 5가지 설계 원칙에 대해 설명해주세요.흐름1. SOLID 원칙 설명2. S 설명3. O 설명4. L 설명5. I 설명6. D 설명답변1. 객체 지향적으로 설계하려면 SOLID 원칙을 지켜야합니다. SOLID 원칙은 5가지 원칙의 앞글자를 따온 단어인데, 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 그리고 의존성 역전 원칙입니다.2. 단일 책임 원칙은 하나의 클래스는 하나의 책임만 맡아, 수정이 일어나는 이유도 그 책임에 대한 것이어야 한다는 것입니다. 3. 개방 폐쇄 원칙은 수정에는 닫혀있고, 확장에는 열려있어야 한다는 것입니다. 4. 리스코프 치환 원칙은 상위 객체를 상속받은 하위 객체는 상위 객체 자리에 대신 들어가도 문제 없어야 한다는 것입니다. 5. 인터페이스 분리 원칙은 하나의 범용적인 인터페이스를 만들어 쓸 데 없는 메서드를 구현시키는 것보다 작게 나뉜 구체적인 인터페이스를 사용하는게 더 낫다는 것입니다. 6. 의존성 역전 원칙은 잘 변하지 않는 상위 객체는 변하기 쉬운 하위 객체에 의존하면 안된다는 것입니다. 함수형 프로그래밍에 대해 설명해주세요흐름1. 패러다임 대분류 중 어느 것에 속하는지 설명2. 프로그램 구현 방법에 대해 설명3. 특징 설명4. 장점 설명5. 단점 설명답변1. 함수형 프로그래밍은 선언적 프로그래밍 패러다임에 속하는 방법론입니다.2. 함수형 프로그래밍은 문제해결에 필요한 로직을 \"순수 함수\"라는 부수효과가 없는 작은 함수로 나눠 블록처럼 쌓아 구현하는 방식으로 설계합니다.3. 함수형 프로그래밍은 함수가 함수를 매개변수로 받고 함수를 반환값으로 내보낼 수 있는 \"고차 함수\"를 통해 재사용성을 높입니다. 4. 함수형 프로그래밍으로 설계된 함수는 외부에 영향을 받지 않으므로 동작을 예측하기 쉽고, 스레드끼리 상태를 공유하지 않아 동시성 프로그램을 작성하기 쉽습니다. 순수 함수, 고차 함수에 대해 설명해주세요.흐름1. 순수 함수 설명, 어떤 경우 순수 함수가 아닌지 설명2. 고차 함수 설명, 고차 함수 제한 설명답변1. 순수 함수란 출력이 입력에만 의존하는 함수를 의미합니다. 만약 함수가 외부의 다른 변수를 사용해서 출력에 영향을 주면 순수 함수가 아닙니다.2. 고차 함수는 함수가 함수를 매개 변수처럼 받아 사용하고, 또 반환값으로 함수를 내보낼 수 있는 함수를 의미합니다. 고차 함수를 사용하기 위해선 언어가 일급 객체라는 특성을 가지고 있어야 합니다.참고 자료 Programming paradigm - Wikipedia [Java]프로그래밍 패러다임이란? 프로그래밍 언어 패러다임" }, { "title": "[백엔드|스프링부트] 서버와 서버사이 요청은 어떻게 주고 받을까?", "url": "/posts/SpringBoot_HowToCommunicateBetweenServers/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, RestTemplate, WebClient", "date": "2023-02-01 09:00:00 +0900", "snippet": "개요지금까지 공부해왔던 웹 API는 클라이언트에서 데이터가 필요하면, 서버 하나에서 응답에 필요한 데이터를 지지고 볶아 내어주는 “모놀리식 아키텍처(Monolithic Architecture)” 로 구현해왔다. 하지만 최근에 개발되는 서비스들은 서로 다른 데이터를 처리하는 서버를 여러 개 두고 서버끼리 통신해 데이터를 만들어나가는 “마이크로서비스 아키텍처(Microservice Architecture)”를 주로 채택하고 있다. 그렇다는 것은 클라이언트에서 서버로 요청을 보내는 것 뿐만이 아니라 서버에서 서버로 요청을 보낼 수 있어야 한다는 말인데, 이런 웹 요청은 어떻게 자바 코드로 보낼 수 있을까? 스프링부트는 RestTemplate, WebClient를 통해 다른 서버로 웹 요청을 보내고 응답을 받을 수 있게 도와준다.Rest Template개념 RestTemplate은 스프링에서 HTTP 통신 기능을 손쉽게 사용하도록 설계된 템플릿이다. HTTP 서버와의 통신을 단순화해 RESTful 원칙을 지키는 서비스를 편하게 만들 수 있다.특징 이름처럼 RESTful 형식을 갖춘 템플릿 JSON, XML, 문자열 등 다양한 형식의 응답 제공 블로킹(blocking) I/O 기반의 동기 방식을 사용 HTTP 프로토콜의 메서드에 맞는 여러 메서드를 제공 현재는 지원 중단(deprecated)된 상태로 WebClient 방식을 사용하는걸 추천하나, 현업에서는 아직 많이 사용됨동작 원리위 그림의 왼쪽 파란 사각형이 우리가 작성하는 애플리케이션 코드이고, 오른쪽 끝의 REST API가 다른 서버에 존재하는 API 이다. 여기서 RestTemplate 메서드를 호출하면 그 둘 사이에서 무슨 일이 일어나는지 알아보자. 어플리케이션이 RestTemplate를 생성하고, URI, HTTP 메소드 등의 헤더를 담아 요청 RestTemplate는 HttpMessageConverter를 사용하여 requestEntity를 요청 메세지로 변환 RestTemplate는 ClientHttpRequestFactory로 부터 ClientHttpRequest를 가져와서 요청을 보냄 ClientHttpRequest 는 요청메세지를 만들어 HTTP 프로토콜을 통해 서버와 통신 RestTemplate 는 ResponseErrorHandler 로 오류를 확인하고 있다면 처리로직을 실행 ResponseErrorHandler 는 오류가 있다면 ClientHttpResponse 에서 응답데이터를 가져와서 처리 RestTemplate 는 HttpMessageConverter 를 이용해서 응답메세지를 java object(Class responseType) 로 변환 어플리케이션에 반환 메서드 종류 메서드 HTTP 형태 설명 getForObject GET GET 형식으로 요청한 결과를 객체로 반환 getForEntity GET GET 형식으로 요청한 결과를 ResponseEntity로 반환 postForLocation POST POST 형식으로 요청한 결과를 헤더에 저장된 URI로 반환 postForObject POST POST 형식으로 요청한 결과를 객체로 반환 postForEntity POST POST 형식으로 요청한 결과를 ResponseEntity로 반환 delete DELETE DELETE 형식으로 요청 put PUT PUT 형식으로 요청 patchForObject PATCH PATCH 형식으로 요청한 결과를 객체로 반환 optionsForAllow OPTION 해당 URI에서 지원하는 HTTP 메서드를 조회 exchange any HTTP 헤더를 임의로 추가할 수 있고, 어떤 메서드 형식에서도 사용할 수 있음 execute any 요청과 응담에 대한 콜백을 수정 구현클라이언트가 서버1에게 요청을 보내면, 서버1은 RestTemplate을 사용해 서버2의 REST API를 호출하는 형식으로 구현해보았다. 서버2 컨트롤러서버2는 API가 호출당하는 서버다. 웹 서비스라면 컨트롤러 이외에도 여러 계층이 존재하겠지만, 간단히 테스트 하기 위해 컨트롤러만 작성했다.@RestController@RequestMapping(\"api/v1/test\") // application.properties 를 통해 포트 9090 할당public class Server2Controller { // 아무것도 추가 안된 GET 메서드 @GetMapping public String getSomething() { return \"Something\"; } // PathVariable을 받는 GET 메서드 @GetMapping(value = \"/{variable}\") public String doSomethingWithPathVariable(@PathVariable String variable) { return variable; } // RequestParam을 받는 GET 메서드 @GetMapping(\"/param\") public String doSomethingWithParam(@RequestParam String parameter) { return parameter; } // RequestBody를 받는 POST 메서드 @PostMapping public ResponseEntity&lt;Dto&gt; getDto( @RequestBody RequestDto requestDto ) { Dto dto = new Dto(); // name과 email에 대한 getter, setter만 존재하는 DTO dto.setName(requestDto.getName()); dto.setEmail(requestDto.getEmail()); return ResponseEntity.status(HttpStatus.OK).body(dto); } // RequestHeader 로 HTTP 헤더를 받는 POST 메서드 @PostMapping(value = \"/header\") public ResponseEntity&lt;Dto&gt; doSomethingWithHeader( @RequestHeader(\"my-header\") String header, @RequestBody RequestDto requestDto ) { return ResponseEntity.status(HttpStatus.OK).body(requestDto); }} 서버1 컨트롤러Postman으로 클라이언트 측에서 요청을 보내는 것 처럼 하기 위해 간략히 작성한 컨트롤러이다.@RestController@RequestMapping(\"/rest-template\")@AllArgsConstructorpublic class Server1Controller { private final Server1Service server1Service; @GetMapping public String getSomething() { return server1Service.getSomething(); } @GetMapping(\"/path-variable\") public String doSomethingWithPathVariable() { return server1Service.doSomethingWithPathVariable(); } @GetMapping(\"/parameter\") public String doSomethingWithParam() { return server1Service.doSomethingWithParam(); } @PostMapping public ResponseEntity&lt;Dto&gt; postWithBody() { return server1Service.postWithBody(); } @PostMapping(\"/header\") public ResponseEntity&lt;Dto&gt; postWithHeader() { return server1Service.postWithHeader(); }} 서버1 서비스서비스 계층에서 RestTemplate 을 사용해 서버2의 API를 호출하도록 작성했다. RestTemplate을 생성해 사용하는 방법은 여러가지가 있는데, 그 중 가장 보편적으로 사용하는 것은 UriComponentsBuilder이다. UriComponentsBuilder는 스프링 프레임워크에서 제공하는 클래스로, 여러 파라미터를 연결해서 URI 형식으로 만드는 기능을 수행한다.@Servicepublic class Server1Service { // GET 형식의 RestTemplate // 1. PathVariable 이나 파라미터를 사용하지 않는 호출 방법 public String getSomething() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/v1/test\") .encode() // 인코딩 문자셋, 디폴트는 UTF-8 .build() .toUri(); RestTemplate restTemplate = new RestTemplate(); ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(uri, String.class); return responseEntity.getBody(); } // 2. PathVariable을 사용한 호출 방법 public String doSomethingWithPathVariable() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/v1/test/{variable}\") // path 에서 중괄호를 사용해 변수명을 입력 .encode() .build() .expand(\"foobar\") // expand 에서 순서대로 값 입력 (복수의 값을 넣어야 할 경우 쉼표(,)로 추가) .toUri(); RestTemplate restTemplate = new RestTemplate(); ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(uri, String.class); return responseEntity.getBody(); } // 3. 파라미터를 사용한 호출 방법 public String doSomethingWithParameter() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/v1/test/param\") .queryParam(\"parameter\", \"foobaz\") .encode() .build() .toUri(); RestTemplate restTemplate = new RestTemplate(); ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(uri, String.class); return responseEntity.getBody(); } // POST 형식의 RestTemplate // 1. RequestBody를 넣는 호출 방법 public ResponseEntity&lt;Dto&gt; postWithBody() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/v1/test\") .encode() .build() .toUri(); Dto dto = new Dto(); dto.setName(\"name\"); dto.setEmail(\"email@mail.com\"); RestTemplate restTemplate = new RestTemplate(); return restTemplate.postForEntity(uri, dto, Dto.class); } // 2. Header를 넣는 호출 방법 public ResponseEntity&lt;MemberDto&gt; postWithHeader() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/v1/test/header\") .encode() .build() .toUri(); Dto dto = new Dto(); dto.setName(\"name\"); dto.setEmail(\"email@mail.com\"); RequestEntity&lt;MemberDto&gt; requestEntity = RequestEntity .post(uri) .header(\"my-header\", \"barbaz\") .body(dto); RestTemplate restTemplate = new RestTemplate(); return restTemplate.exchange(requestEntity, Dto.class); }}WebClient개념WebClient 역시 웹 요청을 수행하기 위해 사용되는 인터페이스이다.특징 싱글 스레드 방식 논블로킹(Non-Blocking) IO 리액티브 스트림(Reactive Streams)의 백 프레셔를 지원 함수형 API 지원 (AWS 람다) 동기, 비동기 상호작용 지원 스트리밍 지원구현 pom.xmlWebClient를 사용하려면 WebFlux 모듈에 대한 의존성을 추가해야 한다.&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt; 서버1 서비스위의 서비스 코드에서 WebClient를 사용하도록 수정해 본 코드이다.@Servicepublic class Server1Service { // GET 형식의 WebClient // 1. PathVariable 이나 파라미터를 사용하지 않는 호출 방법 (builder() 방식 사용) public String getSomething() { WebClient webClient = WebClient.builder() // 빌더 호출 후 메서드로 확장 .baseUrl(\"http://localhost:9090\") .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); return webClient.get() .uri(\"/api/v1/test\") .retrieve() .bodyToMono(String.class) // 리턴타입 설정 (Mono란 데이터를 제공하는 발행자) .block(); // 기본적으로 논블로킹으로 동작하므로, block() 을 통해 블로킹으로 전환 } // 2. PathVariable을 사용한 호출 방법 (create() 방식 사용) public String doSomethingWithPathVariable() { WebClient webClient = WebClient.create(\"http://localhost:9090\"); // 객체 생성 후 ResponseEntity&lt;String&gt; responseEntity = webClient.get() .uri(uriBuilder -&gt; uriBuilder.path(\"/api/v1/test/{variable}\") .build(\"foobar\")) .retrieve() // 요청에 대한 응답값 추출 .toEntity(String.class) // ResponseEntity 타입으로 받을 수 있음 .block(); return responseEntity.getBody() } // 3. 파라미터를 사용한 호출 방법 public String doSomethingWithParameter() { WebClient webClient = WebClient.create(\"http://localhost:9090\"); return webClient.get().uri(uriBuilder -&gt; uriBuilder.path(\"/api/v1/test/param\") .queryParam(\"parameter\", \"foobaz\") .build()) .exchangeToMono(clientResponse -&gt; { // exchange는 응답 결과 코드에 따라 다르게 응답을 설정하고 싶을 때 사용 가능 if (clientResponse.statusCode().equals(HttpStatus.OK)) { return clientResponse.bodyToMono(String.class); return clientResponse.createException().flatMap(Mono::error); } }) .block(); } // POST 형식의 RestTemplate // 1. RequestBody를 넣는 호출 방법 public ResponseEntity&lt;Dto&gt; postWithBody() { WebClient webClient = WebClient.builder() .baseUrl(\"http://localhost:9090\") .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); Dto dto = new Dto(); dto.setName(\"name\"); dto.setEmail(\"email@mail.com\"); return webClient.post() .uri(\"/api/v1/test\") .bodyValue(dto) // bodyValue로 post와 함께 전송할 body 값 추가 .retrieve() .toEntity(Dto.class) // Dto로 추출 .block(); } // 2. Header를 넣는 호출 방법 public ResponseEntity&lt;MemberDto&gt; postWithHeader() { WebClient webClient = WebClient.builder() .baseUrl(\"http://localhost:9090\") .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); Dto dto = new Dto(); dto.setName(\"name\"); dto.setEmail(\"email@mail.com\"); return webClient.post() .uri(\"/api/v1/test\") .header(\"my-header\", \"barbaz\") // header 로 헤더 추가 .bodyValue(dto) .retrieve() .toEntity(Dto.class) .block(); }} 먼저 WebClient 객체를 생성한다. WebClient는 .builder() 와 .create(), 두 가지 방법으로 생성할 수 있다. create 방식은 기본 설정값으로 객체를 생성하지만, builder 방식은 빌더 패턴으로 작동해 설정값을 직접 넣어줄 수 있다. builder 사용법은 .baseUrl() 메서드에서 기본 URL을 설정한 후 다음과 같은 메서드들을 통해 확장한다: .defaultHeader(): 기본 헤더 설정 .defaultCookie(): 기본 쿠키 설정 .defaultUriVariable(): 기본 URI 확장값 설정 .filter(): WebClient에서 발생하는 요청에 대한 필터 설정 생성된 객체에서 요청에 사용할 HTTP 메서드에 따라 .get(), .post(), .put(), .delete() 를 호출한다. 다음 uri 메서드로 접근하고자 하는 URI를 설정한다. 기본적으로 String 형식으로 입력 할 수 있지만, uriBuilder를 사용해 전달할 수도 있다. 응답 결과를 가져오는 방법도 .retrieve() 와 .exchange() 가 있다. retrieve 를 이용하면 바로 ResponseBody를 처리 할 수 있지만, exchange 를 이용하면 응답 코드에 따른 결괏값을 다르게 설정하는 등 세세한 컨트롤이 가능하다. 가져온 응답 결과에 .toEntity()를 호출해 어떤 타입으로 변환할지 정한다. 만약 블로킹 구조로 동작하게 하려면 .block() 메서드를 추가해주면 된다. 참고 자료 스프링 RestTemplate 정리(요청 함) Spring-boot 공부 8 - RestTemplate(Server to Server 간의 통신) Spring 5 WebClient" }, { "title": "[CS] 디자인패턴이란? Part 01", "url": "/posts/CS_DesignPattern/", "categories": "CS, Design Pattern", "tags": "CS, Design Pattern", "date": "2023-01-30 09:00:00 +0900", "snippet": "디자인 패턴이란?디자인 패턴이란, 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용해 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것을 의미한다.종류‘GoF 디자인 패턴’ 에 따라 분류하면 디자인 패턴은 3가지 종류로 나뉜다: 생성(Creational), 구조(Structural), 행위(Behavioral)생성 패턴은 객체 생성에 사용되는 패턴으로, 의존성을 낮추도록(객체를 수정해도 호출부가 영향을 받지 않도록) 개발된 패턴들이다.구조 패턴은 객체를 조합해서 더 큰 구조를 만드는 패턴이다.행위 패턴은 객체 간의 알고리즘이나 책임 분배에 관한 패턴으로, 객체 하나로 수행할 수 없는 작업을 여러 객체를 이용해 작업을 분배하는 패턴이다.싱글톤 패턴개념생성 패턴 중 하나인 싱글톤 패턴(Singleton Pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다. 인스턴스를 여러 개 만들게 되면 자원을 낭비하게 되거나 버그를 발생시킬 수 있는 모듈에 사용된다.사용DB 연결 모듈, 커넥션 풀, 스레드 풀 등에 사용.구현싱글톤 패턴을 구현하는 방법에는 여러가지가 있고, 그 중 가장 최적화된 패턴을 상황에 맞게 사용하는 게 가장 좋다.이 글에서는 검증된 싱글톤 패턴 코드 두 가지를 다룰 것이다. Bill Pugh (성능) 멀티스레드 환경에서 안전하고 Lazy Loading(나중에 객체 생성)도 가능 클래스 안에 내부 클래스를 두어 클래스가 로드되는 시점에 만들어지도록 함 다만 클라이언트가 임의로 싱글톤을 파괴할 수 있다는 단점을 지님 (Reflection API, 직렬화/역직렬화를 통해) class Singleton { private Singleton() {} // static 내부 클래스를 이용 // Holder로 만들어, 클래스가 메모리에 로드되지 않고 getInstance 메서드가 호출되어야 로드됨 private static class SingleInstanceHolder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingleInstanceHolder.INSTANCE; }} Enum 클래스 초기화가 한 번만 이루어져 멀티스레드 환경에서 안전하고, 위의 싱글톤 파괴 공격에도 안전 다시 일반적인 클래스로 변환해야 할 경우, 코드를 처음부터 다시 짜야 함 클래스 상속이 불가 enum SingletonEnum { INSTANCE; private final Client dbClient;\t SingletonEnum() { dbClient = Database.getClient(); } public static SingletonEnum getInstance() { return INSTANCE; } public Client getClient() { return dbClient; }} public class Main { public static void main(String[] args) { SingletonEnum singleton = SingletonEnum.getInstance(); singleton.getClient(); }}문제점 TDD 단위 테스트가 힘듦싱글톤 패턴은 TDD(Test Driven Development)를 할 때 걸림돌이 된다. TDD를 할 때 주로 단위 테스트를 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 한다.하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 ‘독립적인’ 인스턴스를 만들기 어렵다. 모듈간 의존성이 높아짐싱글톤 패턴의 대부분은 인터페이스가 아닌 클래스의 객체를 미리 생성해 놓고 정적 메소드를 이용하는 방식을 사용하기 때문에, 클래스 사이에 강한 의존성과 높은 결합이 생기게 된다. 의존성이 높다는 것은, 하나의 모듈을 수정함으로 그 모듈을 참조하는 다른 모듈들도 수정이 필요하게 된다는 것이다.이는 의존성 주입(DI, Dependency Injection)을 통해 모듈간의 결합을 조금 더 느슨하게 만들어 해결할 수 있다. 의존성 주입이란, 클래스가 필요한 객체를 클래스 외부에서 생성하여 클래스 내부로 파라미터를 통해 내부로 주입 시키는 것이다.팩토리 패턴개념생성 패턴 중 하나인 팩토리 패턴(Factory pattern)은 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴으로, 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다. 즉, 상위 클래스의 인스턴스를 하위 클래스가 생성하는 것이다.구현커피 주문을 받아 각기 다른 커피를 생산하는 커피 팩토리 코드를 구축해보자.abstract class Coffee { public abstract int getPrice(); @Override public String toString() { return this.getPrice() + \"원 입니다.\" }}class CoffeeFactory { public static Coffee getCoffee(String type, int price){ if (\"Latte\".equalsIgnoreCase(type)) return new Latte(price); else if (\"Americano\".equalsIgnoreCase(type)) return new Americano(price); else { return new DefaultCoffee(); } }}class DefaultCoffee extends Coffee { private int price; public DefaultCoffee() { this.price = -1; } @Override public int getPrice() { return this.price; }}class Latte extends Coffee { private int price; public Latte(int price){ this.price = price; } @Override public int getPrice() { return this.price; } }class Americano extends Coffee { private int price; public Americano(int price){ this.price = price; } @Override public int getPrice() { return this.price; } } public class CoffeeTest{ public static void main(String [] args){ Coffee latte = CoffeeFactory.getCoffee(\"Latte\", 4000); Coffee americano = CoffeeFactory.getCoffee(\"Americano\", 3000); System.out.println(\"라떼는 \" + latte); System.out.println(\"아메리카노는 \" + americano); }} /*라떼는 4000원 입니다.아메리카노는 3000원 입니다.*/위 코드를 보면, 커피 객체를 메인 메서드가 아닌 CoffeeFactory 클래스에서 생성하는 것을 알 수 있다. 이러면 SOLID 원칙 중 의존성 역전 원칙(DIP, Dependency Inversion Principle)을 지킬 수 있다.전략 패턴개념행위 패턴 중 하나인 전략 패턴(Strategy pattern)은 실행(런타임) 중에 알고리즘 전략(기능, 동작)을 선택하여 객체 동작을 실시간으로 바뀌도록 할 수 있게 하는 행위 디자인 패턴이다. 같은 문제를 해결하는 여러 알고리즘을 클래스별로 캡슐화 해 놓고, 이들이 필요할 때 교체할 수 있도록 하는 방식으로 구현한다.사용인증 모듈, 결제 시스템구현다음은 쇼핑 카트에 아이템을 담아 LUNA 신용카드 또는 KAKAO 신용카드라는 두 개의 전략을 이용해 상황에 따라 결제를 진행하는 예제이다.class Item { public String name; public int price; public Item(String name, int cost) { this.name = name; this.price = cost; }}// 전략 - 추상화된 알고리즘interface PaymentStrategy { void pay(int amount);} class KAKAOCardStrategy implements PaymentStrategy { private String name; private String cardNumber; private String cvv; private String dateOfExpiry; public KAKAOCardStrategy(String nm, String ccNum, String cvv, String expiryDate) { this.name = nm; this.cardNumber = ccNum; this.cvv = cvv; this.dateOfExpiry = expiryDate; } @Override public void pay(int amount) { System.out.println(\"카카오 카드를 이용해 \" + amount + \"원을 결제했습니다.\"); }} class LUNACardStrategy implements PaymentStrategy { private String emailId; private String password; public LUNACardStrategy(String email, String pwd) { this.emailId = email; this.password = pwd; } @Override public void pay(int amount) { System.out.println(\"루나 카드를 이용해 \" + amount + \"원을 결제했습니다.\"); }} // 컨텍스트 - 전략을 등록하고 실행class ShoppingCart { List&lt;Item&gt; items; public ShoppingCart() { this.items = new ArrayList&lt;Item&gt;(); } public void addItem(Item item) { this.items.add(item); }\t // 전략을 매개변수로 받아서 실행 public void pay(PaymentStrategy paymentMethod) { int amount = 0; for (Item item : items) { amount += item.price; } paymentMethod.pay(amount); }}// 클라이언트 - 전략 제공/설정class User { private final ShoppingCart cart = new ShoppingCart(); // 물건 담기 public void choose(Item item) { cart.addItem(item); } // 결제 전략 실행 public void pay(PaymentStrategy paymentMethod) { cart.pay(paymentMethod); }}예제 코드를 보면 알 수 있듯이, 전략 패턴을 이용하면 카드사 정책에 따라 필요한 정보를 다르게 받을 수 있다. 또, 만약 다른 카드를 추가하고 싶으면 PaymentStrategy를 상속받아 쉽게 추가 가능하다.옵저버 패턴개념옵저버 패턴(Observer Pattern)은 특정 주체가 다른 객체의 상태 변화를 관찰하다가, 상태 변화가 생기면 옵저버들에게 변화를 알려주는 디자인 패턴이다.사용알림 기능, MVC 패턴구현// 주체의 기능 정의public interface Subject { public void register(Observer obj); public void unregister(Observer obj); public void notify(); public Object getUpdate();}// 객체의 기능 정의public interface Observer { public void update();}// 특정 주제에 대한 옵저버들을 관리class Topic implements Subject { private List&lt;Observer&gt; observers; private String message; public Topic() { this.observers = new ArrayList&lt;&gt;(); this.message = \"\"; } // 옵저버 추가 @Override public void register(Observer obj) { if (!observers.contains(obj)) { observers.add(obj); } } // 옵저버 제거 @Override public void unregister(Observer obj) { observers.remove(obj); } // 옵저버에게 알림 @Override public void notify() { this.observers.forEach(Observer::update); } // 업데이트 내역 받기 @Override public String getUpdate() { return this.message; } // 업데이트 하기 public void postMessage(String msg) { this.message = msg; notify(); }}// class TopicSubscriber implements Observer { private String name; private Subject topic; public TopicSubscriber(String name, Subject topic) { this.name = name; this.topic = topic; } // 위의 notify 에서 호출되면, topic으로부터 업데이트 내역을 받는다. @Override public void update() { String message = topic.getUpdate(); System.out.println(name + \" 유저가 받은 메시지: \" + message) }}public class Test { public static void main(String[] args) { Topic topic = new Topic(); Observer a = new TopicSubscriber(\"A\", topic); Observer b = new TopicSubscriber(\"B\", topic); Observer c = new TopicSubscriber(\"C\", topic); topic.register(a); topic.register(b); topic.register(c); topic.postMessage(\"Hello world!\") }}특정 Topic에 대한 업데이트를 감지하고 전달하는 옵저버 패턴이다. class Topic implements Subject 를 통해 Subject interface를 구현했고, Observer a = new TopicSubscriber(\"A\", topic); 으로 옵저버를 선언할 때 해당 이름과 어떤 토픽의 옵저버가 될 것인지 정했다.프록시 패턴개념프록시 패턴(Proxy pattern) 은 어떤 객체에 대한 접근을 제어하는 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴이다. 프록시 패턴은 주로 객체 생성에 비용이 많이 들어 실제 사용 시점까지 객체 생성을 미뤄두거나, 실제 객체의 제한하기 위해 사용된다.사용참고 자료 [기술 면접 질문] 기술 면접 예상 질문 대비하기 - 디자인패턴(Design Pattern)편 [Design Pattern] 싱글톤 패턴 디자인패턴 - 팩토리 패턴 (factory pattern) [GOF] 💠 전략(Strategy) 패턴 - 제대로 배워보자" }, { "title": "[백엔드|스프링부트] 운영중인 웹 서비스를 Actuator로 모니터링 해보자", "url": "/posts/SpringBoot_AboutActuator/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, Actuator", "date": "2023-01-26 09:00:00 +0900", "snippet": "개요애플리케이션을 운영하는 단계에 접어들면, 애플리케이션이 정상적으로 동작하는지 모니터링하는 환경을 만들어야 한다. 이 때 사용할 수 있는 기능이 스프링부트 액추에이터로, 애플리케이션의 건강 상태 정보, 사용 중인 메모리, 특정 엔드포인트가 받은 요청 횟수 등의 정보를 HTTP 요청을 통해 받아 볼 수 있다. 이 기능을 어떻게 추가하며, 어떻게 사용할 수 있는지 알아보자.의존성 추가액추에이터를 사용하려면 먼저 의존성을 추가해야 한다. 스프링부트 액추에이터 역시 spring-boot-starter-parent 에 포함되어 있으므로, 별도의 버전 관리 없이 쉽게 추가 할 수 있다.&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;액추에이터 엔드포인트위의 의존성을 추가했다면, 웹 서비스의 URL에 /actuator 를 포함한 여러 엔드포인트들로 요청을 보내 애플리케이션의 내부 상황을 모니터링 할 수 있다.자주 활용되는 액추에이터의 엔드포인트는 다음과 같다. HTTP 메서드 엔드포인트 설명 기본 활성화 여부 GET /auditevents 호출된 Audit 이벤트 정보를 표시한다. (AuditEventRepository 빈이 필요) X GET /beans 애플리케이션에 있는 모든 스프링 빈 리스트를 표시한다. X GET /caches 사용 가능한 캐시를 표시한다. X GET /conditions 자동 구성 조건 내역을 생성한다. X GET /configprops @ConfigurationProperties의 속성 리스트를 표시한다. X GET,POST,DELETE /env 애플리케이션에서 사용할 수 있는 환경 속성을 표시, 수정, 삭제한다. X GET /health 애플리케이션의 상태 정보를 표시한다. O GET /httptrace 가장 최근에 이뤄진 100건의 요청 기록을 표시한다. X GET /info 애플리케이션의 정보를 표시한다 O GET /integrationgraph 스프링 통합 그래프를 표시한다. (spring-integration-core 모듈에 대한 의존성을 추가해야 동작) X GET,POST /loggers 애플리케이션의 로거 구성을 표시하고 수정한다. X GET /mappings 모든 @RequestMapping의 매핑 정보를 표시한다. X GET /metrics 애플리케이션의 메트릭 정보를 표시한다. X GET /quartz Quartz 스케줄러 작업에 대한 정보를 표시한다. X GET /scheduledtasks 애플리케이션에서 예약된 작업을 표시한다. X GET,DELETE /sessions 스프링 세션 저장소에서 사용자의 세션을 검색하고 삭제할 수 있다.(스프링 세션을 사용하는 서블릿 기반 웹 애플리케이션 필요) X POST /shutdown 애플리케이션을 정상적으로 종료할 수 있다. X GET /startup 애플리케이션이 시작될 때 수집된 시작 단계 데이터를 표시한다.(BufferingApplicationStartup으로 구성된 스프링 애플리케이션 필요) X GET /threaddump 스레드 덤프를 수행한다. X 엔드포인트의 활성화와 비활성화위의 표를 보면, 기본적으로 활성화 되어 있는 엔드포인트는 /health와 /info 밖에 없다는 것을 알 수 있다. 대부분의 액추에이터 엔드포인트는 민감한 정보를 제공하므로 보안 처리가 되어야 하기 때문에, 기본적으로 활성화 되어 있지 않다. 이 부분은 스프링 시큐리티를 사용해 보안을 강화할 수 있다. 그러나 액추에이터 자체는 보안 처리가 되어 있지 않기 때문에 활성화에 주의가 필요하다.엔드포인트 노출 관리는 .properties혹은 .yaml에서 할 수 있고, 노출 여부는 management.endpoints.web.exposure.include와 management.endpoints.web.exposure.exclude 구성 속성을 사용해 제어한다.management.endpoints.web.exposure.include=health, info, beans, conditionsmanagement.endpoints.web.exposure.exclude=heapdump, threaddump액추에이터 기능(추후 작성 예정)액추에이터 보안 문제애플리케이션 모니터링 및 관리 측면에서 개발자에게 편의를 주는 기능이나, 잘못 사용할 경우 비밀번호, API KEY, Token 등 Credential들이나 내부 서비스 도메인, IP 주소와 같은 중요 정보들이 유출될 수 있다. 자세한 정보는 여기서 확인하자.참고 자료 스프링 부트 액추에이터 사용하기 Actuator 안전하게 사용하기" }, { "title": "[백엔드|스프링부트] 프록시 객체때문에 발생할 수 있는 equals 예외", "url": "/posts/SpringBoot_JpaAndEquals/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, JPA, Hibernate, Proxy", "date": "2023-01-25 09:00:00 +0900", "snippet": "개요JPA를 통해 객체를 불러오면서도 모든 연관된 엔티티를 전부 불러오고 싶지는 않다면, JPA가 지원하는 지연로딩 방식을 사용하면 된다. 그러면 JPA는 하이버네이트 구현체가 만든 프록시 객체로 불러와 데이터의 자리를 메워준다. 이 프록시 객체는 실제 데이터를 DB에서 불러오지 않고도 데이터가 존재하는 것처럼 해줘서, 해당 데이터를 실제로 접근하기 전까지 불러오는 걸 미뤄둘 수 있도록 해주는 유용한 객체이다. 하지만 그런 차이점 때문에 프록시 객체를 실제 객체처럼 대하다가는 오류가 발생할 수 있다. 이번 글에서는 그렇게 발생할 수 있는 오류에 대해 알아보고자 한다.프록시의 equals자바에서 객체 비교를 하기 위해 보통 인텔리제이의 기능을 빌려 equals 메서드를 오버라이딩 한다. 그렇게 작성된 엔티티는 다음과 같다.@Getter@Entitypublic class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Setter @JoinColumn(name = \"userId\") @ManyToOne(fetch = FetchType.LAZY, optional = false) private UserAccount userAccount; // 기타 필드 생략...}@Getter@Entitypublic class UserAccount { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long userId; //... 생략 @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } UserAccount userAccount = (UserAccount) o; return Objects.equals(id, userAccount.id); }}이 때, 다음과 같이 하나의 Post에서 동일한 UserAccount를 호출해 비교하는 테스트 코드를 실행시켜보자.@Testvoid name() { Post post = postRepository.findById(1L).orElseThrow(); UserAccount userAccount1 = post.getUserAccount(); UserAccount userAccount2 = post.getUserAccount(); assertThat(userAccount1).isEqualTo(userAccount2);}하나의 엔티티에서 가져온 동일한 엔티티여야 하지만, 테스트 코드는 실패를 반환한다.org.opentest4j.AssertionFailedError: expected: \"UserAccount(userId=1) (UserAccount$HibernateProxy$luj7HgwZ@5f8d4b51)\" but was: \"UserAccount(userId=1) (UserAccount$HibernateProxy$luj7HgwZ@5f8d4b51)\"메시지를 보면 필드도 주솟값도 같은 객체인데도, 테스트에 실패한다는 메시지를 보여준다. 어디에서 문제가 있는 걸까?원인은 getClass() 에 있다. equals()를 호출하는 객체를 A라 하고, 그 인자로 받은 객체는 B라 하자. A는 확실히 UserAccount 클래스가 맞다. 하지만 B의 클래스는 UserAccount가 아닌, 하이버네이트가 만든 프록시 객체인 것. 고치려면 조건문을 if (!(o instanceof UserAccount)) 로 바꾸면 된다.그렇다면 클래스 비교만이 문제일까? 코드를 고치고 다시 테스트 코드를 실행해보면 똑같은 오류가 또 다시 나온다. Objects.equals(id, userAccount.id) 에도 문제가 있다는 뜻이다.하이버네이트가 만들어주는 프록시 객체는 실제 객체의 상속본이며, 실제 객체와 다르게 필드가 존재하지 않고 메서드로만 값을 조회할 수 있다. 따라서 인자로 받은 객체 B의 id를 userAccount.id 로 접근하면 id 필드가 존재하지 않아 null을 반환하게 되는 것이다. 고치려면 getter 메서드를 이용해 필드를 조회하도록 바꾸면 된다.위 두 오류를 고쳐 다음과 같이 작성하면 드디어 테스트 코드를 통과하게 된다. @Override public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof UserAccount that)) { // that을 패턴 변수로 변환해 한 줄을 줄였다. return false; } return this.getUserId() != null &amp;&amp; this.getUserId().equals(that.getUserId()); }참고 자료 JPA Hibernate 프록시 제대로 알고 쓰기 엔티티 관련 질문글" }, { "title": "[백엔드|스프링부트] 서버로 들어오는 값에 대한 유효성 간단하게 검사하는 법", "url": "/posts/SpringBoot_AboutValidation/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, Validation", "date": "2023-01-20 18:00:00 +0900", "snippet": "개요회원 가입 같은 기능들은 유저가 값을 제대로 입력 했는지 검사를 해야한다. 보통 이런 경우는 프론트엔드에서 입력 값에 대한 검증을 하고 서버로 보내지만, 그렇다고 프론트엔드에서’만’ 유효성 검사를 해도 문제가 생길 수 있다. 따라서 백엔드 측에서도 검증 코드를 작성해야만 한다.스프링부트는 필드에 어노테이션을 붙이는 것만으로 검증 로직을 만들 수 있다. 어떻게 하는지 알아보도록 하자.유효성 검사 방법의존성 추가스프링부트의 유효성 검사 기능을 사용하려면 먼저 아래와 같은 의존성을 추가해주면 된다. 추가 후에 Refresh 하는걸 잊지 말자.&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;어노테이션 추가컨트롤러 계층에서 파라미터에 @RequestBody 가 붙은 DTO 클래스로 이동해 검증이 필요한 필드에 어노테이션을 붙여주면 된다.다음은 회원 가입시 필요한 정보에 검증 어노테이션을 붙인 간단한 예제이다. 먼저 컨트롤러에 검증이 필요한 객체(@RequestBody가 붙어있는)에 @Valid 어노테이션을 붙인다.@RestController@AllArgsConstructor@RequestMapping(\"/user\")public class ValidationController { private final Logger LOGGER = LoggerFactory.getLogger(ValidationController.class); private final UserService userService; @PostMapping(\"/join\") public ResponseEntity&lt;String&gt; join( @Valid @RequestBody JoinRequestDto dto) { return ResponseEntity.status(HttpStatus.OK).body(userService.join(UserDto.from(dto))); } 다음, 유효성 검사가 필요한 객체 필드에 어노테이션을 붙인다.@Data@NoArgsConstructor@AllArgsConstructor@ToString@Builderpublic class JoinRequestDto { @NotBlank String id; @Email String email; @Pattern(regexp = \"01(?:0|1|[6-9])[.-]?(\\\\d{3}|\\\\d{4})[.-]?(\\\\d{4})$\") String phoneNumber; @Min(value = 0) @Max(value = 150) int age; @Size(min = 0, max = 40) String description;}위처럼 각 필드에 어노테이션을 선언함으로 유효성 검사를 위한 조건을 설정할 수 있다.대표적인 어노테이션은 다음과 같다. 문자열 검증 (String) @Null: null 값만 허용한다. @NotNull : null을 허용하지 않는다. 빈 문자열은 허용한다. @NotEmpty : null과 ““을 허용하지 않는다. 공백(“ “)은 허용한다. @NotBlank : null, “”, “ “ 모두 허용하지 않는다. 최댓값/최솟값 검증 (BigDecimal, BigInteger, Integer, Long) @DecimalMax(value = \"[숫자형 문자열]\" : [숫자형 문자열] 보다 작은 값을 허용한다. @DecimalMin(value = \"[숫자형 문자열]\" : [숫자형 문자열] 보다 큰 값을 허용한다. @Max(value = [숫자] : [숫자] 보다 작은 값을 허용한다. @Min(value = [숫자] : [숫자] 보다 큰 값을 허용한다. 값의 범위 검증 (BigDecimal, BigInteger, Integer, Long) @Positive : 양수를 허용한다. @PositiveOrZero : 0을 포함한 양수를 허용한다. @Negative : 음수를 허용한다. @NegativeOrZero : 0을 포함한 음수를 허용한다. 시간에 대한 검증 (Date, LocalDate, LocalDateTime) @Future : 현재보다 미래의 날짜를 허용한다. @FutureOrPresent : 현재를 포함한 미래의 날짜를 허용한다. @Past : 현재보다 과거의 날짜를 허용한다. @PastOrPresent : 현재를 포함한 과거의 날짜를 허용한다. 이메일 검증 (String) @Email : 이메일 형식을 검사한다. ““는 허용한다. 자릿수 범위 검증 (BigDecimal, BigInteger, Integer, Long) @Digits(integer = [정수 자릿수], fraction = [소수 자릿수]) : [정수 자릿수] 와 [소수 자릿수]를 허용한다. Boolean 검증 (Boolean) @AssertTrue : true인지 체크한다. null은 체크하지 않는다. @AssertFalse : false인지 체크한다. null은 체크하지 않는다. 문자열 길이 검증 (String) @Size(min = [최솟값], max = [최댓값]) : 문자열의 길이가 [최솟값] 이상, [최댓값] 이하인지 확인한다. 정규식 검증 (String) @Pattern(regexp = \"[정규표현식]\") : 문자열이 정규표현식으로 일치하는지 확인한다. 이 외에도 카드 번호의 형식을 확인하거나, URL의 형식을 확인하는 등 여러가지 어노테이션이 있다.해당 어노테이션은 IntelliJ 에서 화면 우측의 [Bean Validation] 탭을 눌러 확인 가능하다.예외 처리위 처럼만 작성해도 유효성 검사에 실패할 데이터가 들어오면 컨트롤러에서 막아준다. 하지만 이렇게 끝내면 응답으로 400 Bad Request만 줄 뿐, 어느 필드가 어떤 이유 때문에 실패한 건지 알려주지 않는다.따라서 해당 정보들을 보내주기 위해서는 @RestControllerAdvice를 이용해서 예외를 처리하는 코드를 작성해주어야 한다.@RestControllerAdvicepublic class GlobalControllerAdvice { @ExceptionHandler({MethodArgumentNotValidException.class}) public ResponseEntity&lt;Map&lt;String, List&lt;String&gt;&gt;&gt; validException( MethodArgumentNotValidException ex) { List&lt;String&gt; errors = ex.getBindingResult().getFieldErrors() .stream().map(FieldError::getDefaultMessage).collect(Collectors.toList()); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(getErrorsMap(errors)); } private Map&lt;String, List&lt;String&gt;&gt; getErrorsMap(List&lt;String&gt; errors) { Map&lt;String, List&lt;String&gt;&gt; errorResponse = new HashMap&lt;&gt;(); errorResponse.put(\"errors\", errors); return errorResponse; }}@RestControllerAdvice 어노테이션이 붙은 전역 예외처리 클래스에서 @ExceptionHandler 로 발생할 예외를 잡아 처리해주는 코드이다. 그 바로 다음을 보면 알겠지만, 검증 실패시 발생하는 예외는 MethodArgumentNotValidException 이다.검사에 탈락한 필드들에 대한 정보는 ex.getBindingResult().getFieldErrors() 를 통해 접근할 수 있다. 여기서 스트림을 통해 .getDefaultMessage() 메서드를 실행시키면, 검증 실패시 기본적으로 설정된 메시지를 받을 수 있다.만약 이 기본 메시지를 직접 편집하고 싶다면, 다시 검증 어노테이션이 붙은 DTO로 찾아가 각 어노테이션마다 message = \"[검증 실패시 보여질 메시지]\" 속성을 붙이면 된다.public class JoinRequestDto { @NotBlank(message = \"아이디가 공백입니다.\") String id; //...}참고 자료 프론트엔드에서”만” 유효성 검사가 문제인 이유 SpringBoot API 요청 값 검증하고 Validation Exception Handing하기 Validation and Exception Handling in Spring Boot" }, { "title": "[백엔드|스프링부트] 알림 기능은 어떻게 구현하는게 좋을까?", "url": "/posts/Implementing_Notification/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, SSE", "date": "2023-01-19 09:00:00 +0900", "snippet": "개요댓글이나 좋아요 알림은 유저의 요청 없이도 실시간으로 서버의 변경 사항을 웹 브라우저에 갱신해줘야 하는 서비스이다. 하지만 전통적인 Client-Server 모델의 HTTP 통신에서는 이런 기능을 구현하기가 어렵다. 클라이언트의 요청이 있어야만 서버가 응답을 할 수 있기 때문이다.HTTP 기반으로 해당 문제를 해결하려면 다음과 같은 방식들이 있다.실시간 통신의 방법Polling일정 주기를 가지고 서버의 API를 호출하는 방법이다. 예를 들어, 클라이언트에서 5초마다 한 번씩 알림 목록을 호출한다면, 업데이트 내역이 5초마다 갱신되며 변경 사항을 적용할 수 있다. 이 방식은 기본적인 HTTP 통신을 기반으로 하기 때문에 호환성이 좋다는 장점이 있다.하지만 해당 방식은 업데이트 주기가 길다면 실시간으로 데이터가 갱신 되지 않고, 또 짧다면 갱신 사항이 없음에도 서버에 요청이 들어와 불필요한 서버 부하가 발생한다는 것이다.Long-PollingPolling과 비슷하나, 업데이트 발생시에만 응답을 보내는 방식이다. 서버로 요청이 들어올 경우, 일정 시간동안 대기하였다가 요청한 데이터가 업데이트 되면 웹 브라우저에게 응답을 보낸다. Polling에서 불필요한 응답을 주는 경우를 줄이기 위해 사용할 수 있는 방법이다. 따라서 연결이 된 경우엔 실시간으로 데이터가 들어올 수 있다는 장점이 있다.하지만 이 방식 또한 데이터 업데이트가 빈번하게 일어난다면 연결을 위한 요청도 똑같이 발생하므로, Polling과 유사하게 서버에 부하가 일어날 수 있다.SSE (Server-Sent Event)웹 브라우저에서 서버쪽으로 특정 이벤트를 구독하면, 서버에서는 해당 이벤트 발생시 웹브라우저 쪽으로 이벤트를 보내주는 방식이다. 따라서 한 번만 연결 요청을 보내면, 연결이 종료될 때까지 재연결 과정 없이 서버에서 웹 브라우저로 데이터를 계속해서 보낼 수 있다.다만, 서버에서 웹 브라우저로만 데이터 전송이 가능하고, 그 반대는 불가능하다는 단점이 있다. 또, 최대 동시 접속 횟수가 제한되어 있다.Web Socket서버와 웹브라우저 사이 양방향 통신이 가능한 방법이다. 변경 사항에 빠르게 반응해야하는 채팅이나, 리소스 상태에 대한 지속적 업데이트가 필요한 문서 동시 편집과 같은 서비스에 많이 사용되는 방식이다.이 방식은 양방향 통신이 지속적으로 이루어질 수는 있으나, 연결을 유지하는 것 자체가 비용이 들기 때문에 트래픽 양이 많아진다면 서버에 큰 부담이 된다는 단점이 있다.결론Polling 방식은 실시간성을 높이려면 그 주기를 짧게 해야 하는데, 트래픽이 많아질 경우 서버에 걸리는 부하가 커지기 때문에 알림 서비스에는 부적합하고 할 수 있다. Long-Polling 역시 마찬가지로, 트래픽이 많아지면 요청도 그만큼 많아지므로 부적합하다.그렇다면 HTTP 연결 방식에 대한 부담이 적은 SSE와 WebSocket 방식이 남는데, 알림 서비스의 경우 클라이언트에서 서버로 데이터를 전송하지 않아도 되어서 단방향 통신만으로도 구현할 수 있으므로, SSE 방식을 택하는 것이 좋겠다.구현spring framework 4.2부터 SSE 통신을 지원하는 SseEmitter 클래스를 이용해 구현할 계획이다.연결 생성 컨트롤러클라이언트에서 구독하는 요청을 보내면, 컨트롤러는 SseEmitter를 만들어주는 서비스 레이어를 통해 전달 받은 SseEmitter를 반환한다.@RestController@RequestMapping(\"/api/v1/users/notification\")@RequiredArgsConstructorpublic class NotificationController { private final NotificationService notificationService; @GetMapping(\"/subscribe\") public SseEmitter subscribe(Authentication authentication) { // Authentication을 UserDto로 업캐스팅 UserDto userDto = ClassUtils.getCastInstance(authentication.getPrincipal(), UserDto.class) .orElseThrow(() -&gt; new ApplicationException(ErrorCode.INTERNAL_SERVER_ERROR, \"Casting to UserDto class failed\")); // 서비스를 통해 생성된 SseEmitter를 반환 return notificationService.connectNotification(userDto.getId()); }} 서비스새로운 연결을 생성할 때에는 유저의 ID를 받아 SSE Emitter를 리포지토리에 저장하도록 했다. 이후, SSE 응답을 할 때 아무런 이벤트도 보내지 않으면 재연결 요청을 보낼때나, 아니면 연결 요청 자체에서 오류가 발생하기 때문에, 첫 응답을 보내주었다.@Slf4j@Service@RequiredArgsConstructorpublic class NotificationService { private final static Long DEFAULT_TIMEOUT = 3600000L; private final static String NOTIFICATION_NAME = \"notify\"; private final EmitterRepository emitterRepository; public SseEmitter connectNotification(Long userId) { // 새로운 SseEmitter를 만든다 SseEmitter sseEmitter = new SseEmitter(DEFAULT_TIMEOUT); // 유저 ID로 SseEmitter를 저장한다. emitterRepository.save(userId, sseEmitter); // 세션이 종료될 경우 저장한 SseEmitter를 삭제한다. sseEmitter.onCompletion(() -&gt; emitterRepository.delete(userId)); sseEmitter.onTimeout(() -&gt; emitterRepository.delete(userId)); // 503 Service Unavailable 오류가 발생하지 않도록 첫 데이터를 보낸다. try { sseEmitter.send(SseEmitter.event().id(\"\").name(NOTIFICATION_NAME).data(\"Connection completed\")); } catch (IOException exception) { throw new ApplicationException(ErrorCode.NOTIFICATION_CONNECTION_ERROR); } return sseEmitter; }} 리포지토리유저 ID로 저장하고 불러올 수 있도록 간단하게 HashMap으로 구현했다. 불러올 SSE Emitter가 없을 경우를 대비해 Optional.ofNullable로 반환하도록 했다.@Slf4j@Repositorypublic class EmitterRepository { // 유저ID를 키로 SseEmitter를 해시맵에 저장할 수 있도록 구현했다. private Map&lt;String, SseEmitter&gt; emitterMap = new HashMap&lt;&gt;(); public SseEmitter save(Long userId, SseEmitter sseEmitter) { emitterMap.put(getKey(userId), sseEmitter); log.info(\"Saved SseEmitter for {}\", userId); return sseEmitter; } public Optional&lt;SseEmitter&gt; get(Long userId) { log.info(\"Got SseEmitter for {}\", userId); return Optional.ofNullable(emitterMap.get(getKey(userId))); } public void delete(Long userId) { emitterMap.remove(getKey(userId)); log.info(\"Deleted SseEmitter for {}\", userId); } private String getKey(Long userId) { return \"Emitter:UID:\" + userId; }}알림 전송 서비스알림 서비스에 메서드를 추가하고, 알림이 발생할 때마다 해당 메서드를 호출하도록 구현했다.@Slf4j@Service@RequiredArgsConstructorpublic class NotificationService { private final static Long DEFAULT_TIMEOUT = 3600000L; private final static String NOTIFICATION_NAME = \"notify\"; private final EmitterRepository emitterRepository; public void send(Long userId, Long notificationId) { // 유저 ID로 SseEmitter를 찾아 이벤트를 발생 시킨다. emitterRepository.get(userId).ifPresentOrElse(sseEmitter -&gt; { try { sseEmitter.send(SseEmitter.event().id(notificationId.toString()).name(NOTIFICATION_NAME).data(\"New notification\")); } catch (IOException exception) { // IOException이 발생하면 저장된 SseEmitter를 삭제하고 예외를 발생시킨다. emitterRepository.delete(userId); throw new ApplicationException(ErrorCode.NOTIFICATION_CONNECTION_ERROR); } }, () -&gt; log.info(\"No emitter found\")); }}참고 자료 Spring에서 Server-Sent-Events 구현하기 [HTTP vs Socket] HTTP와 소켓 통신의 장단점 [Spring + SSE] Server-Sent Events를 이용한 실시간 알림" }, { "title": "[백엔드] 캐시 서버로 사용되는 Redis를 알아보자", "url": "/posts/About_Redis/", "categories": "Backend, Database", "tags": "Backend, Database, DB, Redis", "date": "2023-01-18 09:00:00 +0900", "snippet": "현재 진행하는 프로젝트에서 대규모 트래픽 처리를 어떻게 할지 고민해보았다. 코드 최적화, 규모 확장, 로드밸런서 도입 등의 방법들이 있지만, 이번에는 캐시 서버 도입에 대해, 그 중에서도 Redis에 대해 알아보려고 한다. 캐시 서버는 무엇이며 왜 대규모 트래픽 처리에 사용되는지, 또 Redis는 어떤 특징을 가지고 있는지를 하나씩 기록해 보자.캐시 서버란?먼저 캐시란, 자주 사용하는 데이터나 연산의 결과값을 좀 더 접근하기 쉬운 곳에 미리 복사해 놓고, 필요할 때마다 빠르게 꺼내 쓸 수 있도록 하는 저장소를 말한다. 컴퓨터에서는 읽는 속도가 느린 디스크의 데이터를, 읽는 속도가 빠른 메모리로 가져와서 메모리상에서 읽고 쓰며 컴퓨터의 성능을 향상시킨다.캐시 서버도 마찬가지다. 이미 처리된 적 있는 쿼리의 결과를 캐시 서버에 저장해놓고, 같은 쿼리가 호출될 때마다 쿼리를 실행하지 않고 그 결과를 가져오기만 한다면 응답을 훨씬 빠르게 줄 수 있게 된다.때문에 대규모 트래픽을 처리하는데 캐시 서버가 필요한 것이다. 만약 캐시 서버가 없다면, 데이터를 조회할 때 ORM을 통해 DB에 모든 요청에 대한 쿼리가 나가게 되는데, 동시 사용자수가 증가해 요청이 많아지면 그만큼 쿼리가 많아지고 DB에 부하가 커져 서비스가 느려지게 되기 때문이다.캐시 전략 Look aside Cache 클라이언트는 서버에 데이터 조회 요청을 보낸다. 웹 서버는 캐시에 해당 요청 결과값이 존재하는지 확인한다. 캐시는 조회 결과를 반환한다. 존재 한다면 7번으로 존재 하지 않는다면 4번으로 웹 서버는 DB에 데이터가 존재하는지 확인한다. DB는 조회 결과를 반환한다. 웹 서버는 DB의 결과 값을 캐시에 저장한다. 웹 서버는 클라이언트에게 데이터 조회에 대한 응답을 보낸다. Write Back 웹 서버는 저장할 모든 데이터를 캐시에 쌓아둔다. 특정 시점에 쌓여있는 모든 데이터를 한번에 DB에 저장한다. 저장이 완료되면 캐시를 비워 캐시에 쌓인 데이터를 삭제한다. Redis란?Redis(REmote DIctionary Server)는 Remote(원격)에 위치하고 프로세스로 존재하는 In-Memory 기반의 Dictionary(key-value) 구조 데이터 관리 Server 시스템이다.Dictionary 구조, 즉, 데이터를 ‘키-값’ 형태로 단순하게 저장하기 때문에, 관계형 데이터베이스처럼 쿼리 연산을 지원하지는 않지만, 대신 데이터의 고속 읽기와 쓰기에 최적화 되어 있다.또, Redis는 인 메모리(In-Memory) DB로, 일반 데이터베이스 같이 디스크(ssd)에 데이터를 쓰는 구조가 아니라 메모리(dram)에서 데이터를 처리하기 때문에 작업 속도가 상당히 빠르다. 하지만, 데이터가 메모리에만 저장되어 있기 때문에, 백업 옵션을 두지 않았다면, 오류로 캐시에 장애가 발생했을 때 저장되지 않은 데이터는 유실될 위험이 있다.Redis의 특징 List, Set, Sorted Set, Hash 등과 같은 Collection을 지원한다. Collection 들에 대한 읽기/쓰기 작업이 O(1)의 성능을 보장한다. Redis는 Single Thread를 사용한다. Context Switching 에 대한 비용을 줄일 수 있다. Race condition에 빠지는 것을 방지한다. 하지만 긴 시간을 요하는(long-time) 명령어 수행시 다른 명령어들을 처리 할 수 없는 상태가 되어 비효율적으로 동작하게 된다. Redis Cluster를 구성해 데이터 분산 처리를 할 수 있다. 데이터를 여러 노드로 분산시켜 사용 메모리를 분산할 수 있다. Redis Sentinel과 Redis Replication으로 장애 진단 및 복구를 할 수 있다. Master - Slave의 Replication으로 구성하고, Master에서 장애가 발생하면 Slave를 Master로 승격시켜 복구한다. 참고 자료 [우아한테크세미나] 191121 우아한레디스 by 강대명님 레디스 소개 &amp; 사용처 (캐시 / 세션) - 한눈에 쏙 정리 Redis로 Cache Server를 만들어 보자!" }, { "title": "[백엔드|스프링부트] 연관 관계 매핑과 영속성 전이", "url": "/posts/SpringBoot_Relationship_mapping/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, Relationship Mapping", "date": "2023-01-15 10:00:00 +0900", "snippet": "연관관계 매핑 연관관계 매핑이란? @Entity public class Post { // 게시글과 댓글의 경우 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long postId; @Column(nullable = false) private String content; @OneToMany private Comment comment; // 댓글 엔티티를 그대로 넣어도 된다! } 하나의 엔티티에서 다른 엔티티를 참조할 수 있도록, 엔티티의 필드에 다른 엔티티를 대응시켜주는 것. 연관관계 매핑 사용 이유 테이블의 외래키를 그대로 사용할 수도 있지만, 외래키 식별자를 직접 다루어야 하기 때문에 객체지향적이지 않음. 연관관계 매핑의 종류 참조의 방향에 따라 단방향, 양방향 엔티티의 관계에 따라 일대일, 일대다, 다대일, 다대다 엔티티 작성 방법 엔티티의 관계를 정의하고, 관계에 따라 @OneToOne(일대일), @OneToMany(일대다), @ManyToOne(다대일), @ManyToMany(다대다) 어노테이션을 넣는다. @JoinColumn 어노테이션을 사용해 매핑할 외래키를 설정한다. 속성 기능 기본값 name 매핑할 외래키의 이름 설정 [필드 명]_[참조하는 테이블의 기본 키 컬럼명] referencedColumnName 외래키가 참조할 상대 테이블의 컬럼명 [참조하는 테이블의 기본 키 컬럼명] foreignKey 외래키를 생성하면서 지정할 제약 조건   단방향과 양방향 매핑 단방향 매핑 만약 한 쪽 엔티티에서 다른 엔티티를 참조할 필요는 있는데, 다른 쪽에서는 그럴 필요가 없을 때 맺음. Eg) 게시글과 회원 관계를 생각해보자. @Entity public class Order { // 주문 정보과 주문 상품의 경우 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long orderId; @OneToMany private List&lt;Product&gt; products = new List&lt;&gt;(); // 주문 정보에서는 주문 상품을 조회할 필요는 있지만, } // ----- @Entity public class Product { // 상품에선 주문을 몰라도 된다. @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long productId; @Column(nullable = false) private Integer price; } 양방향 매핑 단방향과 반대로, 서로가 서로를 참조할 수 있어야 할 경우 맺음. Eg) 게시글과 댓글의 관계를 생각해보자. @Entity public class Post { // 게시글과 회원의 경우 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long postId; @OneToMany private User user; // 게시글을 어떤 회원이 작성했는지도 알아야 하지만, } // ----- @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long userId; @ManyToOne private List&lt;Post&gt; posts = new ArrayList&lt;&gt;(); // 회원이 어떤 글을 작성했는지도 알아야 한다. } 일대일 매핑* 다른 엔티티 객체를 필드로 정의했을 때다대일, 일대다 매핑다대다 매핑 Eg) 회원은 여러 게시글을 좋아요 할 수 있고, 게시글도 여러 회원에게 좋아요 받을 수 있다.@Entitypublic class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long postId; // ... @ManyToMany private List&lt;User&gt; likedUsers = new ArrayList&lt;&gt;();}// -----@Entitypublic class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long userId; // ... @ManyToMany private List&lt;Post&gt; likedPosts = new ArrayList&lt;&gt;();} 위처럼 다대다(M:N) 연관관계는 어노테이션 @ManyToMany로 구현 가능하나, 실무에서 거의 사용되지 않는 구조이다. 이유는 다음과 같다: 관계형 데이터베이스는 정규화된 테이블 2개로 다대다를 표현할 수 없기 때문에 중간 테이블을 생성해주긴 하지만 묵시적으로 생성해주기 때문에, 자기도 모르는 복잡한 조인의 쿼리가 발생하는 경우가 생길 수 있고, 필요한 추가 컬럼을 사용할 수 없다. 따라서, 이 중간 테이블을 엔티티로 새로 만들어 일대다, 다대일 관계로 풀어 직접 사용하는 것이 보통이다. @Entitypublic class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long postId;}// -----@Entitypublic class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long userId;}// -----@Entitypublic class PostLike { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long likeId; @ManyToOne private User user; @ManyToOne private Post post; private LocalDateTime likedTime; // 필요한 메타데이터도 추가 가능}영속성 전이 영속성 전이란? 영속성 전이란, 특정 엔티티의 영속성 상태를 변경할 때, 그 엔티티와 연관된 엔티티의 영속성에도 영향을 미쳐 영속성 상태를 같이 변경하는 것을 의미한다. 영속성 전이 사용 방법 @OneToOne 과 같은 연관관계를 매핑한 후, cascade = 요소를 추가해주면 된다. 사용 가능한 전이 타입은 다음과 같다: 종류 설명 PERSIST 영속화할 때 같이 영속화 MERGE 영속성 컨텍스트에 변합할 때 같이 병합 REMOVE 엔티티를 제거할 때 같이 제거 REFRESH 엔티티를 새로고침할 때 같이 새로고침 DETACH 영속성 컨텍스트에서 제외하면 같이 제외 ALL 위의 모든 상태 변경을 같이 적용 @Entitypublic class Post { // 게시글과 댓글의 경우 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long postId; @OneToMany(cascade = CascadeType.ALL) // 게시글이 삭제되면 댓글도 같이 삭제되어야 하지만, private List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();}// -----@Entitypublic class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long userId; @ManyToOne // 댓글이 삭제되어도 게시글은 여전히 존재해야 한다. private Post post; }" }, { "title": "[SNS 클론코딩] 회원가입과 로그인 기능 개발", "url": "/posts/CloneCodingSNS_Part02/", "categories": "Backend, SpringBoot", "tags": "Backend, Spring, SpringBoot, Java, CloneCoding, SNS", "date": "2023-01-10 20:00:00 +0900", "snippet": " |— | — |진행 상황 위의 시퀀스 다이어그램을 따라 회원가입, 로그인 관련 테스트 코드 작성. 회원가입과 로그인 기능에 필요한 엔티티, DTO, 컨트롤러, 서비스, 리포지토리 작성. 예외를 일괄적으로 처리하기 위해 @RestControllerAdvice를 사용해 GlobalControllerAdvice 정의배운 점 JWT 구현 방법JWT란, 토큰 기반 인증 시스템의 대표적인 구현체이다. .을 기준으로 헤더.내용.서명으로 나타난다.public static String generateToken(String userName, String key, long expiredTimeMs) { //Claims: 내용 부분에 담을 것들 Claims claims = Jwts.claims(); claims.put(\"userName\", userName); return Jwts.builder() // 내용 .setClaims(claims) // 발생 일시 .setIssuedAt(new Date(System.currentTimeMillis())) // 만료 일시 .setExpiration(new Date(System.currentTimeMillis() + expiredTimeMs)) // 사용할 암호화 알고리즘 .signWith(getKey(key), SignatureAlgorithm.HS256) .compact();}private static Key getKey(String key) { byte[] keyBytes = key.getBytes(StandardCharsets.UTF_8); return Keys.hmacShaKeyFor(keyBytes);}아이디어 메모 JWT에 관해 조사해보다가, JWT 토큰이 탈취되는 경우에 대해 알게 되었다. 만약 공격자가 이 토큰을 탈취 할 경우, 토큰이 만료될 때 까지 공격자는 정상적인 사용자인 척 위장할 수 있게 된다. 이를 방어하기 위해서 인증 유지에 필요한 Access 토큰 과 Refresh 토큰을 따로 두고, Access 토큰의 유효 기간을 Refresh 토큰보다 짧게 설정해, 유효 기간이 지날 때마다 Access 토큰을 재발급 받도록 한다고 한다. 오늘 구현한 내용에 반영하기엔 방대한 내용이라 적용하진 못했지만, 프로젝트 백로그에 적어두고, 추후 구현해보아야겠다." }, { "title": "[SNS 클론코딩] 기획 및 아키텍처 설계", "url": "/posts/CloneCodingSNS_Part01/", "categories": "Backend, SpringBoot", "tags": "Backend, Spring, SpringBoot, Java, CloneCoding, SNS", "date": "2023-01-09 09:00:00 +0900", "snippet": "요구사항유즈 케이스 다이어그램 회원가입과 회원 로그인을 할 수 있어야 한다. 피드를 통해 포스트 목록을 조회할 수 있어야 한다. 로그인이 되어있다면, 포스트를 작성하고, 수정하고, 삭제할 수 있어야 한다. 로그인이 되어있다면, 다른 회원의 포스트에 좋아요를 누르면 좋아요 수가 올라가고, 다시 누르면 취소된다.아키텍처 설계데이터베이스 선택 RDBMS vs NoSQL 선택: 회원 정보와 포스트 정보를 저장할 데이터 베이스가 필요 회원A 가 포스트A를 작성했다는 관계를 저장해야 함 회원별로 작성한 포스트 정렬 기능 필요따라서 RDBMS를 사용하려 한다. 데이터베이스 엔진 선택: 학습 용도이므로, 비용이 따로 청구되지 않는 데이터 베이스 서버(TypeCloud 이용 예정)에서 지원하는 데이터베이스를 선택해야함 이미 사용해보아 익숙한 MySQL보다도, 다른 SQL을 이용해보려 함따라서 PostgreSQL을 사용하려 한다.사용자 인증 방식 선택 인증 스키마 회원 아이디와 비밀번호가 오가는데, 별도의 key 없이 복호화 가능한 방식은 안됨 회원 계정 정보가 매 요청마다 오고 갈 경우 탈취의 우려가 있으므로, 토큰 기반 인증을 사용하려 함따라서 JWT를 사용하려 한다." }, { "title": "[백엔드|스프링부트] JPQL과 JPA Repository 쿼리 메서드", "url": "/posts/SpringBoot_JPQL/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, JPQL", "date": "2023-01-03 10:00:00 +0900", "snippet": "JPQL JPQL이란? JPA에서 사용할 수 있는 쿼리를 말한다. String으로 쿼리문을 작성, EntityManager을 통해 쿼리 실행한다. String jpql = \"select product \" + \"from Product product \" + \"where product.name = '펜' \" + \"order by product.price asc, product.stock desc\"; SQL은 데이터베이스 테이블을 대상으로 쿼리하는데 반해, JPQL은 엔티티 객체를 대상으로 쿼리를 실행한다. EntityManager란? EntityManager란, 엔티티를 저장하고, 수정하고, 삭제하고 조회하는 등 엔티티와 관련된 모든 일을 처리하는 Bean. 스프링부트는 EntityManager가 자동으로 등록되어있어서, 아래와 같이 간단하게 불러올 수 있. @PersistenceContext private EntityManager em; 작성한 JPQL 문자열을 다음과 같이 메소드를 호출해 쿼리를 실행할 수 있다. List&lt;Product&gt; jpqlResult = em.createQuery(jpql, Product.class).getResultList(); JpaRepository의 쿼리 메서드리포지토리는 JPA Repository를 상속 받는 것만으로 기본적인 CRUD 메서드를 제공하지만, 이런 메서드들은 PK 기반으로 생성되기 때문에, 다른 조건으로 쿼리하려면 별도의 메서드를 정의해서 사용해야 한다. 이 때 간단한 쿼리문을 작성하기 위해 사용되는 것이 쿼리 메서드이다.쿼리 메서드는 다음과 같은 키워드들을 조합해 생성할 수 있다.public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; { // ----- 주제 키워드 ----- // 무엇을 찾을 지 정함. 반환 타입이 달라짐. /* 조회 find / read / get / query / search / stream */ List&lt;Product&gt; findByName(String name, Sort sort); /* 개수 제한 (단건 조회 가능) First&lt;number&gt; / Top&lt;number&gt; */ List&lt;Product&gt; findFirst5ByName(String name, Sort sort); Product findFirstProduct(String name); // Sort를 createdAt 기준으로 주면, 가장 최근에 생성된 데이터 조회 가능. /* 존재 유무 exists */ boolean existsProductByPrice(Integer price); /* 개수 count */ Integer countProductByStock(Integer stock); /* 삭제 (삭제된 갯수 반환 가능) delete / remove */ void deleteProductByName(String name); // ----- 조건자 키워드 ----- // 모든 조건자 앞에 Is를 넣을 수도 있다. /* 일치 (생략) / Equals */ List&lt;Product&gt; findByProductId(Long productId, Sort sort); /* 불일치 Not */ List&lt;Product&gt; findProductByProductIdNot(Long productId, Sort sort); /* 일부 일치 StartingWith / EndingWith / Containing / Like */ List&lt;Product&gt; findProductByNameStartingWith(String name, Sort sort); /* null 확인 Null / NotNull */ List&lt;Product&gt; findProductByNameNull(String name, Sort sort); /* boolean 확인 True / False */// List&lt;Product&gt; find___ByTrue(String name, Sort sort); // boolean 컬럼이 없기 때문에 주석처리 /* 대소 비교 GreaterThan / LessThan / Between 뒤 Equal 추가로 경곗값 포함 가능 */ List&lt;Product&gt; findProductByPriceGreaterThan(Integer price); /* 전후 비교 (시간) After / Before */ List&lt;Product&gt; findByCreatedAtBefore(LocalDateTime time);}" }, { "title": "[백엔드|스프링부트] 동영상 스트리밍 서비스 API 클론코딩 1주차", "url": "/posts/SpringBoot_Designing_API/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java", "date": "2022-10-25 14:00:00 +0900", "snippet": "API 설계 가이드링크기능 메인을 로드하면, 메인에 띄울 영상 ID의 리스트를 불러오고, 리스트의 ID들을 각각 조회해 썸네일, 영상 이름 등의 정보를 불러온다. 메인을 로드할 때마다 각각 다른 영상들이 뜬다. 유튜브라면 추천 알고리즘을 사용하겠지만, 현재로선 불가능하므로 랜덤으로 조합한다. 구독 페이지를 로드하면, 사용자에 따라 다른 영상 ID 리스트를 불러오고, 메인처럼 각각 조회한다. 기록 페이지도 위와 마찬가지. 영상을 클릭하면, 영상을 로드함과 동시에 유저의 시청 기록을 생성한다. 시청 중이던 영상이중단 될 경우, 영상 시청 기록을 업데이트 한다. 영상의 댓글은 영상에서 스크롤을 내리면 로드 되므로, 따로 조회하도록 한다. 좋아요나 싫어요를 누르면 유저 아이디별로 영상 기록을 조회해 안눌렸으면 +1, 이미 눌려있으면 -1을 하도록 한다. 영상 다운로드 및 업로드는 AWS S3의 API를 이용해 영상과 썸네일에 대한 CRUD 연산을 하도록 할 것이므로, 서비스할 서버에서는 해당 정보 이외의 정보들만 저장한다. 영상 업로드, 삭제시에 pub-sub 패턴을 이용해 구독자의 구독 리스트에 해당 영상 ID를 추가한다. API 설계 Resource GET POST PUT DELETE /users 회원 정보 조회 회원 가입 회원 정보 수정 회원 탈퇴 /users/login   로그인     /feed/main 메인 페이지 영상 id 조회       /feed/subscription 구독 영상 id 조회       /feed/history 시청 기록 영상 id 조회       /video 영상 정보 조회 영상 업로드 영상 정보 수정 영상 삭제 /watch 재생할 영상 로드 영상에 대한 유저 기록 생성 기록 수정 기록 삭제 /watch/comment 댓글 조회 댓글 생성 댓글 수정 댓글 삭제 /watch/like 좋아요 정보 조회   좋아요 토글   /watch/dislike 싫어요 정보 조회   싫어요 토글   /subscribe 구독 정보 조회 구독 토글     궁금한 점 영상 기록을 조회하고 없으면 생성해야하는데, POST 메소드 하나로 해 요청을 하나로 보낼지, 아니면 GET POST 따로 만들어 요청을 두번 보낼지 모르겠다." }, { "title": "[백준] 11400번: 단절선", "url": "/posts/BOJ_11400/", "categories": "Algorithm, BOJ", "tags": "Algorithm, Baekjoon_Online_Judge, Python, Pypy, 11400, 단절선", "date": "2022-10-24 12:10:00 +0900", "snippet": "문제[원문 링크]그래프가 주어졌을 때, 단절선을 모두 구해 출력하는 프로그램을 작성하시오.단절선이란 그 간선을 제거했을 때, 그래프가 두 개 또는 그 이상으로 나누어지는 간선을 말한다. 즉, 제거했을 때 그래프의 connected component의 개수가 증가하는 간선을 말한다.입력첫째 줄에 두 정수 V(1≤V≤100,000), E(1≤E≤1,000,000)가 주어진다. 이는 그래프가 V개의 정점과 E개의 간선으로 이루어져 있다는 의미이다. 다음 E개의 줄에는 간선에 대한 정보를 나타내는 두 정수 A, B가 주어진다. 이는 A번 정점과 B번 정점이 연결되어 있다는 의미이며, 방향은 양방향이다.그래프는 항상 연결되어 있으며, 같은 간선이 두 번 이상 들어오는 경우는 없다. 또, A와 B가 같은 경우도 없다.그래프의 정점은 1부터 V까지 자연수이다.출력첫째 줄에 단절선의 개수 K를 출력한다.둘째 줄부터 K개 줄에는 단절선을 사전순으로 한 줄에 하나씩 출력한다. 간선은 “A B” 형식으로 출력해야 하고, A &lt; B를 만족해야 한다. 같은 간선은 한 번만 출력하면 된다. 즉, “A B”를 출력한 경우에 “B A”는 출력할 필요가 없다.해설그래프의 단절선을 찾는 문제이다. 단절선이란, 그래프에서 간선 하나를 지웠을 때 그래프가 둘로 나뉘게 되는 간선을 말한다.단절선을 찾으려면, 주어진 그래프를 DFS로 돌면서 부모 정점, 방문 순서를 기록해두고, 다시 방문 순서 역순으로 정점을 돌면서 자신의 방문 순서가 부모 정점를 제외한 정점들의 방문 순서와 비교해 가장 이르면, 자신과 부모정점를 잇는 간선을 단절선으로 지정하고, 만약 다른 정덤 더 이르다면, 자신의 방문 순서를 그 정점의 방문순서로 갱신시켜주는 방식으로 구해줄 수 있다.한 문장으로 이해하기는 어려운 개념이므로 그림으로 설명하려고 한다. 먼저 아래 그림을 보자.위와 같은 그래프가 주어졌을 때: 간선 (1, 4)를 지우면, 그래프가 [1, 2, 3]과 [4, 5]로 나뉘고, 간선 (4, 5)를 지우면, 그래프가 [1, 2, 3, 4]와 [5]로 나뉜다.따라서 구해주어야 하는 단절선은 (1, 4)와 (4, 5)이다.먼저 1번 정점을 시작으로 DFS를 돌려주면, 아래와 같은 그림이 된다.위 그림은 높은 번호의 정점을 가장 먼저 탐색했을 때 나오는 방문 순서이다. 각 정점의 부모 정점은 해당 정점까지 도달하기 위해 방문한 바로 이전 정점이다. 1번 정점은 부모 정점이 없기 때문에, -1로 설정되었다.위 그림에서도 보면 알 수 있지만, 단절선으로 지정 가능한 간선들은 (ex. (1, 4)), 둘 중 자식 정점에 해당하는 것의 방문 순서가 (ex. 4번 정점의 방문 순서 ②), 부모 정점을 제외한 다른 정점들보다 이르다(ex. 1번 정점을 제외한 5번 정점의 방문 순서 ③보다 이르다)는 것을 알 수 있다.하지만 단절선이 아닌 간선 중에서도 주위 정점의 방문 순서가 이른 경우(ex. (2, 3)의 경우, 1번 정점이 방문 순서 ①)도 있다. 이런 경우를 걸러내기 위해서 방문 순서를 역으로 돌면서 방문 순서를 갱신시켜주는 방법을 사용해야 한다. 아래의 그림을 보자.위 그래프에서 방문 순서 갱신 처리는 다음과 같은 순서로 진행된다: 2번 정점 방문순서 = ②, 부모 정점 3번을 제외한 정점들 중 가장 이른 방문 순서 = 1번 정점의 ① 2번 정점의 방문 순서를 ①로 갱신 3번 정점 방문순서 = ④, 부모 정점 1번을 제외한 정점들 중 가장 이른 방문 순서 = 2번 정점의 ① 3번 정점의 방문 순서를 ①로 갱신 5번 정점 방문순서 = ③, 부모 정점 4번을 제외한 정점들 중 가장 이른 방문 순서 = 없음 (4, 5)는 단절선 4번 정점 방문순서 = ②, 부모 정점 1번을 제외한 정점들 중 가장 이른 방문 순서 = 5번 정점의 ③ (1, 4)는 단절선 1번 정점과 이어지는 간선들은 이미 모두 탐색되었으므로, 생략 가능이렇게 구해진 단절선 (1, 4) 와 (4, 5)를 반환하는 것이 단절선 구하는 알고리즘이다.코드위의 방법 그대로 구현한 코드이다.파이썬은 재귀적으로 그래프를 탐색하면 while문으로 탐색하는 것보다 느려지기 때문에, 해당 코드에서는 while문을 사용하는 DFS를 적용했다.import sysinput = sys.stdin.readlinedef main(): V, E = map(int, input().split()) V += 1 graph = [[] for _ in range(V)] visit = [0] * V # 방문 안했으면 0을, 방문 했으면 부모 노드를 기록 order = [0] * V # 방문 순서를 기록 count = [] # 방문한 노드 순서대로 저장 for _ in range(E): a, b = map(int, input().split()) graph[a].append(b) graph[b].append(a) # DFS 돌면서 방문 순서, 부모노드 기록 queue = [(1, -1)] while queue: curr, prev = queue.pop() if visit[curr]: continue visit[curr] = prev count.append(curr) order[curr] = len(count) for next in graph[curr]: if not visit[next]: queue.append((next, curr)) # 방문 순서 역순으로 탐색하며 순서 갱신 및 단절선 탐색 result = [] for curr in count[:0:-1]: is_bridge = True for next in graph[curr]: if next == visit[curr]: continue if order[curr] &gt; order[next]: is_bridge = False order[curr] = order[next] if is_bridge: result.append(sorted([curr, visit[curr]])) # 단절선을 사전순으로 정렬해 출력 result.sort() answer = [str(len(result))] answer.append('\\n'.join(' '.join(map(str, k)) for k in result)) return '\\n'.join(answer)if __name__ == \"__main__\": print(main())결과" }, { "title": "[알고리즘|파이썬] 코드트리: 산타의 선물 공장", "url": "/posts/CodeTree_SantaFactory/", "categories": "Algorithm, CodeTree", "tags": "Algorithm, Code_Tree, Python, Pypy, 삼성, 역테, 산타의_선물_공장", "date": "2022-10-18 17:00:00 +0900", "snippet": "문제[원문 링크]해설공장의 벨트 갯수, 선물 갯수, 그리고 선물의 ID와 무게를 주고, 각각의 연산을 처리하는 문제였다.선물 상자를 가운데서 빼오거나, 모든 선물 상자를 다른 벨트로 옮기는 등의 연산이 있었기 때문에, 배열이 아닌 연결 리스트 자료구조를 사용했다.또 각각의 벨트의 상태가 다르고, 놓여있는 상자들도 다르기 때문에 벨트를 class로 만들어 인스턴스를 찍어냈다.상자 클래스class Box: # 연결리스트 노드 생성자에 id와 무게를 추가했다. def __init__(self, box_id, weight): self.box_id = box_id self.weight = weight self.prev_box = None self.next_box = None # 노드의 앞과 뒤 주소를 넣어주는 메서드 def set_prev(self, prev_box): self.prev_box = prev_box def set_next(self, next_box): self.next_box = next_box # 앞의 노드와의 연결을 끊는 메서드 def cut_prev(self): if self.prev_box == None: return self.prev_box.next_box = None self.prev_box = None # 연결리스트 중간에서 노드를 빼오는 메서드 def take_out(self): if self.next_box: self.next_box.prev_box = self.prev_box if self.prev_box: self.prev_box.next_box = self.next_box self.next_box = None self.prev_box = None상자 클래스는 연결 리스트의 노드 역할이다. 상자 아이디와 무게를 저장하고, 이전 상자와 다음 상자를 가리키는 포인터를 저장했다. 벨트 가장 앞 상자의 prev_box와 가장 뒷 상자의 next_box는 각각 None을 가리키도록 설정했다.벨트 클래스class Belt: # 첫 상자와 끝 상자를 가리킬 변수와, # 상자 ID 검색을 빠르게 하기 위한 딕셔너리 box_dict, # 벨트 고장 여부를 저장할 broken을 선언한다. def __init__(self): self.first_box = None self.last_box = None self.box_dict = dict() self.broken = False # 벨트 끝에 상자를 추가하는 메서드. # 끝 상자와 추가할 상자를 이어주고, 벨트의 끝 상자를 추가할 상자로 바꾼다. # 상자가 없을 때 호출 된다면, 첫 상자를 해당 상자로 설정한다. def add_box(self, this_box): self.box_dict[this_box.box_id] = this_box if not self.first_box: self.first_box = this_box if self.last_box: self.last_box.set_next(this_box) this_box.set_prev(self.last_box) self.last_box = this_box # 벨트 가장 앞 상자를 빼는 메서드. 두 번째 상자를 첫 상자로 바꾸고, 앞 상자와의 연결을 끊어준다. # 상자가 1개 일 때 호출 된다면 끝 상자도 None으로 바꿔준다. def pop_box(self): box_to_pop = self.first_box self.first_box = box_to_pop.next_box if self.first_box: self.first_box.cut_prev() else: self.last_box = None del self.box_dict[box_to_pop.box_id] return box_to_pop벨트 클래스에서는 벨트 위의 첫 상자와 끝 상자를 추적하고, 상자 ID 검색을 빠르게 하기 위해 딕셔너리 자료구조를 이용해 box_dict에 저장했다. 또, 이미 망가진 벨트인지 판별하기 위해 broken을 선언했다. 벨트의 행위는 단 두가지로, 가장 뒤에 상자를 추가하는 add_box와, 가장 앞 상자를 빼오는 pop_box를 추가해주었다.팩토리 클래스class Factory: # 100 연산이자 생성자이다. 매개변수로 100을 제외한 모든 숫자를 한번에 받는다. # N과 M을 분리시키고, 한 벨트당 몇 개의 상자가 들어갈지 계산해 counts 에 저장한다. # M개의 벨트를 만들고, presents 에서 counts 만큼의 연속된 정보로 Box를 생성해 벨트에 넣어주었다. def __init__(self, args): N, M, *presents = args counts = N // M self.belts = [Belt() for _ in range(M)] for idx, belt in enumerate(self.belts): for num in range(idx * counts, (idx+1) * counts): belt.add_box(Box(presents[num], presents[num+N])) # 200 연산이다. max_weight을 매개변수로 받고, 기본 반환값은 0이다. # 벨트를 모두 돌면서 first_box가 있는 경우, pop_box 메서드로 일단 빼온다. # 빼온 상자가 max_weight 이하면 result에 무게를 더하고, # 아니라면 add_box 메서드로 뒤에 그대로 다시 추가해주면 된다. def unload(self, max_weight): result = 0 for belt in self.belts: if belt.first_box: popped_box = belt.pop_box() if popped_box.weight &lt;= max_weight: result += popped_box.weight else: belt.add_box(popped_box) return result # 300 연산이다. 제거할 id를 매개변수로 받고, 기본 반환값은 -1이다. # 벨트를 돌면서 딕셔너리에 id가 있는지 확인했다. # id를 발견하면 해당 상자가 벨트의 처음, 끝 상자인지 확인해 처리하고, # take_out 메서드로 연결 리스트에서 빼준다. # 딕셔너리에서는 id로 제거해주면 된다. def remove(self, remove_id): result = -1 for belt in self.belts: if remove_id in belt.box_dict: removed_box = belt.box_dict[remove_id] if belt.first_box == removed_box: belt.first_box = removed_box.next_box if belt.last_box == removed_box: belt.last_box = removed_box.prev_box removed_box.take_out() result = removed_box.box_id del belt.box_dict[removed_box.box_id] break return result # 400 연산이다. 찾을 id를 매개변수로 받고, 기본 반환값은 -1이다. # 역시 벨트를 돌면서 상자를 찾는다. 반환 값이 벨트의 아이디(인덱스+1)라서 enumerate를 썼다. # 상자를 찾으면, 그 위치가 벨트의 처음이 아닐 경우, 첫 상자와 끝 상자를 이어주고, # 찾은 상자를 첫 상자로, 그 앞 상자를 끝 상자로 바꿔주고 둘의 연결을 끊으면 된다. def find(self, find_id): result = -1 for belt_id, belt in enumerate(self.belts): if find_id in belt.box_dict: found_box = belt.box_dict[find_id] if belt.first_box != found_box: belt.first_box.set_prev(belt.last_box) belt.last_box.set_next(belt.first_box) belt.first_box = found_box belt.last_box = found_box.prev_box found_box.cut_prev() result = belt_id+1 break return result # 500 연산이다. 고장시킬 벨트의 아이디를 매개변수로 받고, 기본 반환값은 -1이다. # 만약 이미 고장난 벨트가 아닐 경우, 반환 값을 벨트의 아이디로 바꾸고, 고장 상태를 True로 바꾼다. # 그리고 그 위에 상자가 있을 경우, 고장 벨트 다음 벨트부터 차례로 돌며 정상 벨트를 찾고, # 고장 벨트의 딕셔너리 내용을 정상 벨트 딕셔너리에 추가, # 고장 벨트 첫 상자와 정상 벨트 끝 상자를 이어주고, # 정상 벨트 끝 상자를 고장 벨트 끝 상자로 바꿔주면 된다. # 고장 벨트의 첫 상자와 끝 상자도 잊지 않고 초기화 시켜줘야 한다. def die(self, belt_id): result = -1 belt_id -= 1 if self.belts[belt_id].broken == False: result = belt_id+1 broken_belt = self.belts[belt_id] broken_belt.broken = True if len(broken_belt.box_dict): for idx in range(belt_id, belt_id + len(self.belts)): if self.belts[idx % len(self.belts)].broken == False: found_belt = self.belts[idx % len(self.belts)] found_belt.box_dict.update(broken_belt.box_dict) broken_belt.box_dict = {} found_belt.add_box(broken_belt.first_box) found_belt.last_box = broken_belt.last_box broken_belt.first_box = broken_belt.last_box = None break return result팩토리 클래스는 각각의 연산들을 메소드로 정의한 것이 끝이다. 100은 팩토리를 만드는 생성자 200은 각 벨트에서 조건 무게 이하의 상자들을 빼는 unload 메서드 300은 벨트마다 특정 아이디를 검색해 벨트의 연결리스트에서 삭제하는 remove 메서드 400은 아이디 검색 후 해당 상자와 앞 상자의 연결을 끊고 first_box 와 last_box 를 연결시켜 앞으로 가져오는 find 메서드 500은 고장난 벨트의 first_box 와 고장 안 난 벨트의 last_box를 연결시키는 die 메서드시뮬레이션if __name__ == \"__main__\": Q = int(input().strip()) # 첫 줄은 무조건 100 연산이므로, 해당 입력으로 Factory를 생성해준다. query, *args = map(int, input().split()) factory = Factory(args) # if else보다 효율적으로 연산을 수행하기 위해 딕셔너리로 만들었다. queries = { 200: factory.unload, 300: factory.remove, 400: factory.find, 500: factory.die, } # 위의 딕셔너리로 호출한 연산을 수행한 후, 반환값을 그대로 출력하면 된다. for _ in range(Q-1): query, arg = map(int, input().split()) print(queries[query](arg))마지막으로 입력을 받으며 시뮬레이션을 돌리고, 나온 결과를 출력해주면 된다." }, { "title": "[알고리즘|파이썬] 코드트리: 싸움땅", "url": "/posts/CodeTree_BattleGround/", "categories": "Algorithm, CodeTree", "tags": "Algorithm, Code_Tree, Python, Pypy, 삼성, 역테, 싸움땅", "date": "2022-10-17 17:40:00 +0900", "snippet": "문제[원문 링크]해설과정들을 그대로 구현만 해주면 되는 간단한 문제였다.플레이어의 상태를 보다 쉽게 관리하기 위해 Player 클래스로 만들었고, 한 턴에 하는 행동들을 모두 메서드로 구현했다.플레이어들을 순서대로 진행시키기 위해 배열에 인스턴스들을 저장했다.총을 주울 때 어떤 총이 가장 쎈 총인지 빠르게 구분하기 위해 최대힙을 사용해 저장했다.초기화from heapq import heapreplace, heappush, heappopN, M, K = map(int, input().split())L = N+1guns = [[] for _ in range(L*L)]board = [0] * (L*N) + [1] * Lfor x in range(0, L*N, L): board[x+N] = 1 line = map(int, input().split()) for xy, gun in enumerate(line, x): if gun: guns[xy].append(-gun)N, M, K 는 문제에서 주어지는 [맵 크기, 플레이어 숫자, 게임이 진행되는 턴 수] 이다.L은 2차원 배열을 1차원 배열로 만들기위해 선언했다.guns 배열은 땅에 떨어져 있는 총의 배열을 위해 선언했는데, 가장 큰 총을 빠르게 찾기 위해 최대힙 으로 구현해주었다.board 배열은 플레이어가 어디에 존재하는지 확인하기 위한 용도인데, 0이면 빈칸, 1이면 격자의 바깥, 그리고 플레이어의 위치마다 다음에 후술할 Player 클래스의 인스턴스들을 넣어주었다.Player 클래스class Player: order = [] delta = (-L, 1, L, -1) guns_heap = guns def __init__(self, x, y, d, s): self.coord = (x-1) * L + (y-1) self.direc = d self.stat = -s self.gun = 0 self.score = 0 Player.order.append(self) def move(self): next_coord = self.coord + Player.delta[self.direc] self.direc = (self.direc + 2) % 4 if board[next_coord] == 1 else self.direc self.coord = self.coord + Player.delta[self.direc] def compare(self): if not Player.guns_heap[self.coord]: return elif not self.gun: self.gun = heappop(Player.guns_heap[self.coord]) elif self.gun &gt; Player.guns_heap[self.coord][0]: self.gun = heapreplace(Player.guns_heap[self.coord], self.gun) def fight(self, another_player): winner, loser = sorted([self, another_player], key = lambda x: (x.stat + x.gun, x.stat)) score = winner.stat + winner.gun - loser.stat - loser.gun loser.lose() winner.win(score) return (loser, winner) def lose(self): if self.gun: heappush(Player.guns_heap[self.coord], self.gun) self.gun = 0 for d in range(4): next_direc = (self.direc + d) % 4 next_coord = self.coord + Player.delta[next_direc] if board[next_coord]: continue self.direc = next_direc self.coord = next_coord self.compare() return def win(self, score): self.score += score self.compare()for _ in range(M): x, y, d, s = map(int, input().split()) Player(x, y, d, s)for player in Player.order: board[player.coord] = player가독성을 위해 플레이어를 클래스로 만들고, 플레이어가 하는 행위들은 모두 메서드로 추가해주었다. 플레이어가 생성되면 정적변수 Player.order배열에 추가해서, for 문을 돌리며 순서대로 행동하도록 했다.생성자 (def __init__(self, x, y, d, s):)생성자 매개변수로 입력에 주어지는 x, y, d, s를 받으면 x와 y는 1차원 배열의 좌표로 바꿔 self.coord에 저장하고, 방향은 그대로 self.direc에, 기본 공격력은 총에 사용되는 최대힙 반영을 위해 음수로 바꿔 self.stat에 저장해 주었다.self.gun에는 총이 없을 시 0, 있으면 해당 공격력으로 저장해주었고, self.score에는 점수를 저장해 주었다.이동 (def move(self):)메서드가 호출되면 가지고 있던 좌표와 방향에 따라 이동시켰다.만약 이동할 좌표의 board 배열이 1 이라면, 해당 칸은 격자 바깥이라는 의미, 따라서 방향을 거꾸로 돌리고 해당 방향으로 이동시켰다.비교 (def compare(self):)해당 플레이어가 위치한 곳의 좌표에서 총 배열을 확인해주었다. 만약 해당 위치에 총이 없다면 넘어가고, 플레이어가 지닌 총이 없다면 최대힙의 0번째 총을 장착(heappop)시키고, 플레이어가 지닌 총이 땅에 있는 총보다 약하다면, 바꿔(heapreplace)주었다.싸움 (def fight(self, another_player):)다른 플레이어와 위치가 겹쳤는지에 대한 확인은 클래스 밖에서 할 예정이니 넘어간다.일단 다른 플레이어와 위치가 겹쳤으면 해당 플레이어의 인스턴스를 board에서 가져와 확인해준다.승자와 패자에 대한 판정은 sorted 함수로 key를 (기본 공격력 + 총, 기본 공격력) 순서로 확인하도록 했다. 현재 공격력은 모두 음수이므로, 합이 더 작은 쪽이 승자다.진 사람은 후술할 lose 메서드를 실행시키고, 이긴 사람은 점수를 계산해 win 메서드를 실행시켰다.짐 (def lose(self):) 진 사람은 해당 칸에서 총을 내려놓아야 하므로, gun 배열에서 해당하는 좌표의 최대힙에 총을 추가해주고 자신의 총은 0으로 초기화 시킨다. for문으로 사방을 확인하면서 벽이나 다른 플레이어가 있는지 (board의 해당 좌표가 0이 아니면 된다) 확인하고 이동, 있다면 continue해서 다음 방향을 확인해준다. 이동할 장소를 발견하면 방향과 좌표를 업데이트 시키고, 총을 줍는 compare 메서드를 실행시킨다. 이김 (def win(self, score):) 매개변수로 받은 공격력 차이를 self.score에 더해주고, 총을 줍는 compare 메서드를 실행시킨다. 초기화이후는 입력을 받아 Player 인스턴스를 생성해주고, board 배열에 플레이어 위치마다 인스턴스를 넣어주었다.시뮬레이션for turn in range(K): for player in Player.order: board[player.coord] = 0 player.move() if board[player.coord]: loser, winner = player.fight(board[player.coord]) board[loser.coord] = loser board[winner.coord] = winner else: player.compare() board[player.coord] = playerK 만큼 턴을 돌면서 Player.order에서 플레이어를 하나씩 꺼내가며 시뮬레이션을 돌렸다.board[player.coord] 를 0으로 초기화 하지 않으면, loser가 다음 위치를 찾을 때 해당 플레이어 때문에 위치를 못찾을 수 있다.정답 출력answer = []for player in Player.order: answer.append(str(-player.score))print(' '.join(answer))answer 배열을 만들어 음수로 되어있는 점수를 양수로 바꿔 배열에 저장해주었다.마지막으로 출력하면 된다." }, { "title": "[백엔드|스프링부트] Lombok으로 코드 다이어트", "url": "/posts/SpringBoot_AboutLombok/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, Lombok", "date": "2022-10-10 19:00:00 +0900", "snippet": "Lombok 로고1자바로 DTO나 Entity 같은 객체를 만들면, Getter/Setter나 toString 등 비즈니스 로직이 아님에도 코드가 길어지도록 하는 메서드들이 있다. 이런 반복되는 코드들을 없애고, 어노테이션 하나로 간단하게 만들 수 있도록 도와주는 플러그인이 바로 이번에 소개할 롬복 이다.이렇게 편리한 기능을 제공해주는 롬복을 프로젝트에 어떻게 적용하고 사용할 수 있는지, 또 주의사항에는 어떤 것이 있는지 알아보도록 하자.적용 방법프로젝트에 Lombok을 적용 시키는 방법은 다음과 같다. 의존성 추가 어노테이션 프로세서 설정 어노테이션 추가예제 환경 IntelliJ IDEA Spring boot 2.5.6 Maven의존성 추가IntelliJ 환경이라면 프로젝트 생성 단계에서 다음의 그림과 같이 Lombok을 포함시킬 수 있다.IntelliJ에서 Lombok 의존성 추가 방법그렇지 않더라도 pom.xml에 롬복 의존성을 추가해주면, 다른 설정 없이 바로 사용 가능하다. &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;어노테이션 프로세서 설정다음은 어노테이션 설정이다. Ctrl + Alt + S로 Setting 창을 연 후, 다음과 같이 진입한다. Build, Execution, Deployment Compiler Annotation Processors 이 후 Enable annotation processing 이라는 항목에 체크하고, OK를 눌러 적용시킨다.IntelliJ에서 어노테이션 프로세서 설정 방법어노테이션 추가마지막으로 롬복에서 제공하는 어노테이션을 DTO나 Entity 클래스에 추가하면 된다. 롬복에서 제공하는 기능은 다음과 같다.@Getter / @Setter클래스에 선언돼 있는 필드에 대한 getter나 setter 메서드를 생성해준다. 아래의 코드에서 주석 처리 된 부분들이 Getter와 Setter 부분이다.@Getter@Setterpublic class ProductDto { private String name; private int price; private int stock; public ProductDto (String name, int price, int stock) { this.name = name; this.price = price; this.stock = stock; }// 아래의 주석 처리된 코드와 같다.// public String getName() {// return this.name;// }//// public int getPrice() {// return this.price;// }//// public int getStock() {// return this.stock;// }//// public void setName(String name) {// this.name = name;// }//// public void setPrice(int price) {// this.price = price;// }//// public void setStock(int stock) {// this.stock = stock;// }}만약 id 처럼 한 번 지정하고 나면 바뀌면 안되어서 Setter 메서드가 없어야하는 필드는 final 키워드를 붙이거나 AccessLevel.None을 붙여주면 된다.@Getter@Setterpublic class ProductDto { @Setter(AccessLevel.None) // 이걸 설정하거나 private final Long id; // final을 붙이거나 private String name; private int price; private int stock; public ProductDto (Long id, String name, int price, int stock) { this.id = id; this.name = name; this.price = price; this.stock = stock; }@NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor데이터 클래스의 초기화를 위한 생성자를 자동으로 만들어주는 어노테이션들이다. @NoArgsConstructor: 매개변수가 없는 생성자를 생성한다. 필드에 final 키워드가 붙어 있다면 초기화할 수 없기 때문에 오류가 난다. @NoArgsConstructorpublic class ProductDto { private final Long id; // 이것 때문에 오류가 난다. @NonNull private String name; private int price; private int stock;// 아래의 주석 처리된 코드와 같다.// public ProductDto () {// }} @RequiredArgsConstructor: final 이나 @NonNull 을 가지는 필드를 매개변수로 받는 생성자를 생성한다. @RequiredArgsConstructorpublic class ProductDto { private final Long id; @NonNull private String name; private int price; private int stock;// 아래의 주석 처리된 코드와 같다.// public ProductDto(Long id, @NonNull String name) {// if (name == Null) {// throw new NullPointerException(\"name is marked NonNull but is null.\");// } else {// this.id = id;// this.name = name;// }// }} @AllArgsConstructor: 모든 필드를 매개변수로 받는 생성자를 생성한다. @AllArgsConstructorpublic class ProductDto { private final Long id; @NonNull private String name; private int price; private int stock;// 아래의 주석 처리된 코드와 같다.// public ProductDto(Long id, @NonNull String name, int price, int stock) {// if (name == Null) {// throw new NullPointerException(\"name is marked NonNull but is null.\");// } else {// this.id = id;// this.name = name;// this.price = price;// this.stock = stock;// }// }} @ToString필드의 값을 문자열로 조합해 리턴하는 .toString()메서드를 생성하는 어노테이션이다.@ToStringpublic class ProductDto { private String name; private int price; private int stock;// 아래의 주석 처리된 코드와 같다.// public String toString() {// return \"ProductDto(name=\" + this.name + \", price=\" + this.price + \", stock=\" + this.stock + \")\";// }}만약 @ToString으로 표현하고 싶지 않은 필드가 있으면, exclude 속성으로 생성에서 제외할 수 있다.@ToString(exclude = \"stock\")public class ProductDto { private String name; private int price; private int stock;// 아래의 주석 처리된 코드와 같다.// public String toString() {// return \"ProductDto(name=\" + this.name + \", price=\" + this.price + \" + \")\";// }}@ EqualsAndHashCode객체의 동등성과 동일성을 비교하는 연산 메서드를 생성한다. 이름에 걸맞게 하나의 어노테이션으로 .equals() 와 .hashCode() 메서드 둘 모두 생성해준다.두 메서드는 각각 다음과 같은 연산을 수행한다. equals: 두 객체의 내용이 같은지 동등성을 비교한다. hashCode: 두 객체가 같은 객체인지 동일성을 비교한다.하지만 이렇게 설명해서는 도통 무슨 말인지 모를 것 같다. 다음의 예시 코드를 보자. 여기서 ProductDto와 ProductDto2 는 동일한 코드의 다른 클래스다.public class EqualsAndHashCodeTester { public static void main(String[] args) { ProductDto prod1 = new ProductDto(\"빵\", 1000, 10); ProductDto prod2 = new ProductDto(\"빵\", 1000, 10); ProductDto2 prod3 = new ProductDto2(\"빵\", 1000, 10); System.out.println(prod1 == prod2); System.out.println(prod1.equals(prod2)); System.out.println(prod1.hashCode() == prod2.hashCode()); System.out.println(prod1.equals(prod3)); System.out.println(prod1.hashCode() == prod3.hashCode()); }}prod1 과 prod2는 클래스와 내용은 같지만, 다른 주솟값을 갖는 다른 인스턴스이고,prod1 과 prod3은 내용만 같고 클래스도, 주솟값도 다른 인스턴스이다.이러한 두 쌍에 대해 equals 와 hashCode 메서드로 비교하면 어떤 결과가 나올까?위의 코드를 실행하면 다음과 같은 결과를 얻는다.EqualsAndHashCode 실험 결과첫 줄의 결과는 prod1과 prod2가 다른 주솟값을 가지는 다른 인스턴스이기 때문에 false가 나왔다.다음 두 줄의 결과는 prod1과 prod2가 다른 인스턴스 일지라도, 같은 클래스로 생성된 같은 내용을 가진 인스턴스이기 때문에 모두 true가 나왔다.마지막 두 줄은 prod1과 prod3가 다른 클래스로 생성된 인스턴스 이므로 equals의 결과가 false가 나왔지만, 두 클래스의 내용이 같으므로 hashCode의 결과는 true가 나왔다.즉, 객체의 동일성을 비교해야하는 hashCode가, 서로 다른 객체임에도 true를 반환하고 있다. 이로 인해 생기는 버그들이 있지만, 이는 후에 유의사항에서 알아보도록 하자.@ Data앞서 설명한 네 개의 어노테이션 모두를 포괄하는(생성자의 경우는 Required로) 어노테이션이다. 만약 모두 사용하고 싶으면 간단히 @Data만 붙여주면 되고, 그 중 사용하고 싶지 않은 것이 있다면 AccessLevel 을 설정해주면 된다.@Datapublic class ProductDto { @Setter(AccessLevel.None) private Long id; private String name; private int price; private int stock;@Value위의 @Data와 비슷하지만, @Setter를 빼고 필드를 final로 정의한, 즉 불변 클래스인 VO(Value Object)를 만들 때 사용하는 어노테이션이다.@Valuepublic class ProductVo { private Long id; private String name; private int price; private int stock;@Builder생성자 대신 빌더 패턴으로도 필드를 정의할 수 있게 해주는 코드를 생성하는 어노테이션이다.@Builderpublic class ProductDto { private String name; private int price; private int stock;// ProductDto(String name, int price, int stock) {// this.name = name;// this.price = price;// this.stock = stock;// }// // public static ProductDtoBuilder builder() {// return new ProductDtoBuilder();// }// // public static class ProductDtoBuilder {// private String name;// private int price;// private int stock;// // ProductDtoBuilder() {// }// // public ProductDtoBuilder name(String name) {// this.name = name;// return this;// }// // public ProductDtoBuilder price(int price) {// this.price = price;// return this;// }// // public ProductDtoBuilder stock(int stock) {// this.stock = stock;// return this;// }// // public ProductDto build() {// return new ProductDto(name, price, stock);// }// // public String toString() {// return \"ProductDto.ProductDtoBuilder(name=\" + this.name + \", price=\" + this.price + \", stock=\" + this.stock + \")\";// }// }}유의 사항Lombok 은 편리한 기능을 많이 제공하지만, 때때로는 그 편리함이 독이 될 수 있다. 2@AllArgsConstructor, @RequiredArgsConstructor 관련두 어노테이션은 필드가 정의된 순서대로 매개변수로 받도록 생성자를 만든다. 즉, 필드를 추가나 제거 하면서 필드의 순서가 뒤바뀌게 되는 경우가 생기면, 그대로 뒤바뀐 채로 생성하게 된다. 심지어 만약 그 뒤바뀐 필드가 같은 타입이면 오류로 멈추지도 않아 더욱 큰일이 나게 되는 것이다. 다음의 코드를 보자.// DTO 클래스@AllArgsConstructor@ToStringpublic class ProductDto { private String name;// private int price; // 여기서 stock과 price의 위치가 바뀌었다고 하자. private int stock; private int price;}// DTO를 생성하는 클래스class Tester { @Test void test() { ProductDto prod1 = new ProductDto(\"빵\", 1000, 10); System.out.println(prod1.toString()); // ProductDto(name=빵, stock=1000, price=10) }}원래는 (name, price, stock) 순서로 들어갔다고 생각하던게, (name, stock, price)로 들어가서 10원짜리 빵 1000개가 생겨버리는 불상사가 생겨버렸다.이런 오류를 범하지 않기 위해서는 @AllArgsConstructor 와 @RequiredArgsConstructor를 처음부터 사용을 하지 않거나, @Builder 를 사용해 파라미터 값이 잘못 들어가지 않도록 코딩하거나,하는 방법을 사용하면 된다.@EqualsAndHashCode 관련위에 설명했던 대로, HashCode가 값들만 비교하기 때문에 에러가 생긴다.@SpringBootTestclass AppTest { private ProductDto prod1 = new ProductDto(\"빵\", 1000, 10); @Test void test() { Set&lt;ProductDto&gt; prodSet = new HashSet&lt;&gt;(); prodSet.add(prod1); boolean contains1 = prodSet.contains(prod1); System.out.println(\"contains1 = \" + contains1); // true prod1.setStock(9); boolean contains2 = prodSet.contains(prod1); System.out.println(\"contains2 = \" + contains2); // false }}위의 코드는 prod1을 해시셋에 넣고 해시셋에 존재하는지 확인, prod1의 필드값 하나만 바꾸고 다시 해시셋에 존재하는지 확인하는 코드이다.앞에서 비교한 prod1과 뒤에서 비교한 prod1은 분명히 같은 객체이지만, 필드가 바뀌어 다른 해시값을 만들기 때문에 서로 다른 버켓을 참조하게 되면서, 해시셋 안에 존재하지 않는 것처럼 판별하는 것이다. 만약 @EqualsAndHashCode 가 없었다면 Object에 기본으로 구현된 .hashCode()가 주솟값으로 해시값을 만들어 내, 같은 버켓을 참조하게 만들었을 것이다.이런 오류를 범하지 않기 위해서는 @EqualsAndHashCode 를 사용하지 않거나, @EqualsAndHashCode(of={“[필드]”}) 로 고유한 값을 가지는 필드(ID 등)만으로 해시값을 만들도록 하거나,하는 방법을 사용하면 된다.@ToString 관련A 라는 객체의 멤버로 B 라는 객체가 있고, B 라는 객체의 멤버로 A 라는 객체가 있다면, 둘은 무한으로 순환하여 참조할 수 있다.이 경우, @ToString(exclude = \"[필드]\") 해당 객체를 가지는 필드를 참조하지 않게 해 예방하는 방법이 있다.출처 https://projectlombok.org/ &#8617; https://jake-seo-dev.tistory.com/70 &#8617; " }, { "title": "[백엔드|스프링부트] Logback으로 로깅하기", "url": "/posts/SpringBoot_AboutLogback/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, Logback", "date": "2022-10-04 15:30:00 +0900", "snippet": "Logback 로고1운영 중인 웹 어플리케이션이 문제가 발생했을 경우, 문제의 원인을 파악하려면 문제가 발생했을 때 당시의 정보가 필요하다. 이런 정보를 얻기 위해서 Exception이 발생했거나, 중요 기능이 실행되는 부분에서는 적절한 로그를 남겨야한다.자바에서는 이런 로깅을 도와주는 툴로 log4j나 Logback을 많이 사용한다. Logback은 기존의 log4j에서 불편한 점들을 개선해 나온 툴로, 오늘은 이 Logback의 특징과 적용 방법에 대해 글을 쓰려 한다.특징 로그 레벨 필터를 설정해, 로그 파일이 불필요한 로그로 채워지는 걸 방지할 수 있다. 5개의 로그 레벨: ERROR: 요청을 처리하는 중 오류가 발생한 경우 WARN: 처리 가능한 문제, 향후 시스템 에러의 원인이 될 수 있는 경우 INFO: 상태 변경 등의 정보를 표시하는 경우 DEBUG: 디버깅을 위해 메시지 표시가 필요한 경우 TRACE: DEBUG보다 훨씬 상세한 정보가 필요한 경우 ex) INFO로 설정하는 경우 하위 레벨인 DEBUG 와 TRACE레벨의 로그는 출력되지 않는다. 내부 알고리즘으로 설정 파일을 일정 시간마다 스캔해 로드한다. 설정 파일 변경 후 서버를 재시작하지 않아도, 수정된 설정 사항으로 로그가 출력된다. spring-boot-starter-web에 내장되어 있어, 의존성 추가 없이 사용 가능하다.적용 방법프로젝트에 Swagger를 적용하려면, 다음과 같은 3가지만 처리해주면 된다. xml 작성 어노테이션 추가예제 환경 Spring boot 2.5.6 MavenXML 작성resources 디렉토리 안에 Logback 설정 파일을 추가한다. 스프링부트 환경에서는 logback-spring.xml 이라는 이름으로, 그 외는 logback.xml 이라는 이름으로 생성한다.다음은 Logback 설정파일에 대한 예시이다. 2Property 영역&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\"&gt; &lt;!-- 속성 또는 변수 설정 --&gt; &lt;property name=\"${name}\" value=\"${value}\"/&gt;configuration의 속성값으로 scan 과 scanPeriod를 부여할 수 있다. 설정시, 서버 가동 중 해당 파일을 몇 초 간격으로 다시 읽어들일지 변경할 수 있다.property 태그로 변수 값을 설정할 수 있다. 다른 태그에서 ${name} 형식으로 불러올 수 있다.Appender 영역 &lt;!-- 어떤 속성의 appender를 사용할지 클래스 및 이름 설정 --&gt; &lt;appender name=\"${name}\" class=\"${appender class}\"&gt; &lt;!-- 각 append class에 맞는 설정값이 다름. ch.qos.logback.core.ConsoleAppender, ch.qos.logback.core.FileAppender, ch.qos.logback.core.rolling.RollingFileAppender, ch.qos.logback.classic.db.DBAppender, ch.qos.logback.classic.net.SMTPAppender 등 --&gt; &lt;/appender&gt;appender 영역은 로그의 형태를 설정하고 어떤 방법으로 출력할지를 설정하는 곳이다.다음과 같이 class 값을 변경해 출력 값을 어디에 저장할지 선택할 수 있다. ch.qos.logback.core.ConsoleAppender 콘솔에 로그를 출력한다. 로그를 OutputStream에 작성하여 콘솔에 출력되도록 한다. &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%level] [%logger] : %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; ch.qos.logback.core.FileAppender 모든 로그를 각각의 파일에 저장한다. 최대 보관 일 수 등를 지정할 수 있다. &lt;timestamp key=\"bySecond\" datePattern=\"yyyyMMdd'T'HHmmss\"/&gt;&lt;appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;file&gt;log-${bySecond}.txt&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;!-- set immediateFlush to false for much higher logging throughput --&gt; &lt;immediateFlush&gt;true&lt;/immediateFlush&gt; &lt;!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; ch.qos.logback.core.rolling.RollingFileAppender 파일을 순회하며 로그를 저장한다. rollingPolicy 태그로 파일 순회 시점을 설정한다. &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;logFile.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover --&gt; &lt;fileNamePattern&gt;logFile.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt; &lt;!-- keep 30 days' worth of history capped at 3GB total size --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; ch.qos.logback.classic.net.SMTPAppender 로그를 메일로 보낸다. &lt;appender name=\"EMAIL\" class=\"ch.qos.logback.classic.net.SMTPAppender\"&gt; &lt;smtpHost&gt;ADDRESS-OF-YOUR-SMTP-HOST&lt;/smtpHost&gt; &lt;to&gt;EMAIL-DESTINATION&lt;/to&gt; &lt;to&gt;ANOTHER_EMAIL_DESTINATION&lt;/to&gt; &lt;!-- additional destinations are possible --&gt; &lt;from&gt;SENDER-EMAIL&lt;/from&gt; &lt;subject&gt;TESTING: %logger{20} - %m&lt;/subject&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;%date %-5level %logger{35} - %message%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; ch.qos.logback.classic.db.DBAppender DB(데이터베이스)에 로그를 쌓는다. 이 경우, logging_event, logging_event_property, logging_event_exception 세 개의 데이터 베이스 테이블을 insert 하므로 DBAppender를 사용하기 전에 먼저 테이블을 생성해야 한다. DB 작성법 2 &lt;property resource=\"application.properties\" /&gt;&lt;springProperty name=\"spring.datasource.driverClassName\" source=\"spring.datasource.driverClassName\"/&gt;&lt;springProperty name=\"spring.datasource.url\" source=\"spring.datasource.url\"/&gt;&lt;springProperty name=\"spring.datasource.username\" source=\"spring.datasource.username\"/&gt;&lt;springProperty name=\"spring.datasource.password\" source=\"spring.datasource.password\"/&gt;&lt;appender name=\"DB\" class=\"ch.qos.logback.classic.db.DBAppender\"&gt; &lt;connectionSource class=\"ch.qos.logback.core.db.DriverManagerConnectionSource\"&gt; &lt;driverClass&gt;${spring.datasource.driverClassName}&lt;/driverClass&gt; &lt;url&gt;${spring.datasource.url}&lt;/url&gt; &lt;user&gt;${spring.datasource.username}&lt;/user&gt; &lt;password&gt;${spring.datasource.password}&lt;/password&gt; &lt;/connectionSource&gt;&lt;/appender&gt; Encoder 영역 &lt;appender name=\"${name}\" class=\"${appender class}\"&gt; &lt;!-- 어떤 형식으로 로그할지 정의--&gt; &lt;encoder&gt; &lt;pattern&gt;${pattern}&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt;Appender 태그 안에 존재하는 영역으로, 로그 표현 형식을 패턴으로 정의한다. 패턴 의미 %logger{length} Logger name을 축약 할 수 있다. {length}는 최대 글자 수 ex)logger{35} %-5level 로그 레벨, -5는 출력의 고정폭 값(5글자) ex) [INFO ] %msg 로그 메세지 ( = %message) ${PID:-} 프로세스 아이디 %d 로그 기록시간 (뒤에 [yyyy-MM-dd HH:mm:ss.SSS] 의 형식이 따라온다.) %p 로깅 레벨 %F 로깅이 발생한 프로그램 파일명 %M 로깅일 발생한 메소드의 명 %I 로깅이 발생한 호출지의 정보 %L 로깅이 발생한 호출지의 라인 수 %thread 현재 Thread 명 %t 로깅이 발생한 Threrad명 %c 로깅이 발생한 카테고리 %C 로깅이 발생한 클래스 명 %m 로그 메세지 %n 줄바꿈 %% %를 출력 %r 애플리케이션 시작 이후 부터 로깅이 발생한 시점 까지의 시간 (ms) Root 영역 &lt;!-- 전체 로그 출력설정 --&gt; &lt;root level=\"${property}\"&gt; &lt;appender-ref ref=\"${appender}\"/&gt; &lt;appender-ref ref=\"${appender}\"/&gt; &lt;appender-ref ref=\"${appender}\"/&gt; &lt;/root&gt; &lt;!-- or --&gt; &lt;!-- 패키지 별 로그 출력설정 --&gt; &lt;logger name=\"org.hibernate\" level=\"debug\"&gt; &lt;appender-ref ref=\"${appender}\"/&gt; &lt;appender-ref ref=\"${appender}\"/&gt; &lt;/logger&gt; &lt;!-- 해당 패키지 하위 로그를 출력하고 싶지 않을때 additivity=\"false\" --&gt; &lt;logger name=\"org.springframework\" level=\"debug\" additivity=\"false\"&gt; &lt;appender-ref ref=\"${appender}\"/&gt; &lt;appender-ref ref=\"${appender}\"/&gt; &lt;/logger&gt;&lt;/configuration&gt;앞서 정의한 Appender 들을 어느 로그 레벨로 출력할지 설정하는 곳이다. 레벨별로 일괄적으로 설정하고 싶다면 root 태그를, 패키지별로 설정하고 싶다면 logger 태그를 사용하면 된다.level 속성에는 INFO, DEBUG 등의 로그 레벨을, name 속성에는 패키지 단위로 로깅이 적용될 범위를, additivity 속성에는 앞에서 지정한 패키지 범위에 하위 패키지를 포함할지 여부를 넣는다.어노테이션 추가기존에 작성한 코드 중 어디에서 로그를 출력할지 어노테이션으로 추가한다. 로그 기능을 사용할 클래스들에 다음과 같은 코드를 정적 변수로 추가한다.public class [클래스명] { private final Logger LOGGER = LoggerFactory.getLogger([클래스명].class); // 중략}그리고 로그를 출력하고 싶은 곳 마다 다음과 같이 메서드를 호출해주면 된다. LOGGER.[로그 레벨](\"메세지, {}\", {}에 들어갈 변수)출처 https://logback.qos.ch/ &#8617; https://agileryuhaeul.tistory.com/entry/Logback-%EC%9D%B4%EB%9E%80 &#8617; &#8617;2 " }, { "title": "[백엔드|스프링부트] 스프링부트에 Swagger 적용하기", "url": "/posts/SpringBoot_AboutSwagger/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java, Swagger", "date": "2022-10-03 11:50:00 +0900", "snippet": "Swagger 로고1API는 간단하게 설명하자면 함수와도 비슷한 것이다. 특정 데이터를 넣으면, 함수가 처리한 값을 되돌려주는 것이다. 하지만 이런 함수는 그냥 무턱대고 쓸 수는 없다. 숫자를 받아 +1한 값을 반환해주는 함수에 a를 넣을 수는 없다. 이렇게 함수를 사용하려면, 이 함수가 무슨 값을 받는지, 이 값을 처리하면 무엇이 반환 되는지 등, 이 함수를 이용할 사용자에게 여러 정보를 알려주어야 한다.API에 사용 방법에 대한 이런 정보들을 문서로 정리하거나 공통의 기준을 정한 것을 API 명세라고 한다. API 명세는 직접 스프레드시트 등으로 직접 작성해 공유하거나, 혹은 작성을 도와주는 툴을 사용해 공유할 수도 있다. 만약 툴을 사용하지 않고 직접 작성하는 경우, API의 추가나 수정이 있을 때마다 명세를 수정해 배포해야하는 번거로움이 있다. 이런 번거로움을 해결하기 위해, 스프링부트에서는 Swagger 라는 API 명세 문서화 툴을 제공한다. 개발자는 간단한 설정만 해주면 API 명세 문서를 자동으로 만들어 배포해주는 것이다.적용 방법프로젝트에 Swagger를 적용하려면, 다음과 같은 3가지만 처리해주면 된다. 의존성 주입 문서 설정 어노테이션 추가(선택사항)예제 환경 Spring boot 2.5.6 Maven Swagger ui 2.9.2 Swagger2 2.9.2의존성 주입먼저 Swagger 라이브러리에 대한 의존성 주입을 해준다. pom.xml 파일의 &lt;dependencies&gt; 태그 밑에 아래와 같은 태그들을 추가해준다. &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt;특이사항으로 다른 라이브러리들과 다르게 &lt;version&gt; 태그를 기재해주는데, spring-boot-starter-parent에 기본적으로 명세되어있는 라이브러리가 아니기 때문이다.문서 설정다음으로 Swagger와 관련된 설정 코드를 작성해준다. API 명세를 노출시킬 HTML 문서를 작성하는 과정이다. 기존 프로젝트의 패키지 안에 다음과 같이 작성된 클래스를 추가해준다.package com.springboot.api.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfiguration { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.springboot.api\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"Spring Boot Open API Test with Swagger\") .description(\"설명 부분\") .version(\"1.0.0\") .build(); }}다음은 설정 코드에 삽입되는 코드들에 관한 설명이다.2 @Configuration: 설정 파일임을 선언. @EnableSwagger2: Swagger 활성화. Docket: HTML문서의 템플릿을 제공하는 플러그인. Docket 클래스에 DocumentationType.SWAGGER_2 심볼을 넣고 다음과 같은 메서드를 실행시키면 된다. .apiInfo(): API 에 대한 기본적인 설명을 추가하는 메서드. 매개변수로 ApiInfo 타입의 객체를 받는다. .select(): ApiSelectorBuilder를 생성하는 메서드. .apis(): @RestController가 선언된 패키지안에서 @RequestMapping이 선언된 API들을 지정하는 메서드. .paths(): 위에서 선택된 API중 path조건에 맞는 것들만 걸러내는 메서드 .useDefaultResponseMessages(): 불필요한 응답코드와 메시지를 제거하는 메서드. 매개변수로 false를 넣어 제거할 수 있다. .groupName(): Docket을 여러개 사용 할 경우 groupName이 충돌하지 않도록 지정하는 메서드. ApiInfo: API의 설명을 Docket에 추가하기 위한 객체. 매개변수로 넣을 때 ApiInfo 클래스를 호출해 한번에 넣을 수도 있지만, ApiInfoBuilder의 메서드로 하나씩 추가할 수 있다. .title(): API의 이름을 넣는 메서드. .description(): 설명을 넣는 메서드. .version() : API의 버전을 넣는 메서드. 어노테이션 추가마지막으로 각 API에 대한 설명을 넣어주면 된다. 기존 코드에 어노테이션만 추가해주면 된다. @ApiOperation(value= \"GET 메서드 예제\", notes = \"@RequestParam을 활용한 GET Method\") @GetMapping(value = \"/request1\") public String getRequestParam1( @ApiParam(value = \"이름\", required = true) @RequestParam String name, @ApiParam(value = \"이메일\", required = true) @RequestParam String email, @ApiParam(value = \"회사\", required = true) @RequestParam String organization) { return name + \" \" + email + \" \" + organization; } @ApiOperation(): 매핑 어노테이션과 함께 쓰여, 해당 API의 설명을 추가한다. value=: API의 이름을 추가한다. URI 옆에 나타나며, 기본값은 메서드명이다. notes=: API의 설명을 추가한다. 클릭해 확장시키면 나타난다. @ApiParam(): 매개변수에 대한 설명 및 설정을 추가한다. value=: 매개변수의 설명을 추가한다. required=: 해당 매개변수가 필수인지 표기한다. 이 외에도 여러가지 어노테이션으로 설명을 추가할 수 있다 3출처 https://swagger.io/ &#8617; https://otrodevym.tistory.com/entry/spring-boot-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-4-Swagger-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95 &#8617; https://velog.io/@gillog/Swagger-UI-Annotation-%EC%84%A4%EB%AA%85 &#8617; " }, { "title": "[백엔드|스프링부트] 스프링 기본 개념", "url": "/posts/SpringBoot_Fundamentals/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java", "date": "2022-09-26 17:50:00 +0900", "snippet": "스프링 부트 웹 어플리케이션 개발에 앞서 알고 있어야 할 기초 지식에 대해 다루어보자.마이크로서비스 아키텍처어떤 포털 사이트에서 블로그, 카페, 메일 등 지원하는 서비스들을 하나의 어플리케이션에 통합해 개발한다고 가정하자. 만약 이렇게 구성한다면, 서버를 업데이트 하거나 어플리케이션 유지보수를 할 때마다 모든 서비스를 중단하고 작업을 진행할 수 밖에 없게 되며, 서비스 자체의 규모도 커져 구동하는 데 걸리는 시간도 길어지게 된다. 이런 문제를 해결하기 위해 나온 것이 마이크로서비스 아키텍처(Microservice Architecture)이다.모놀리식 서비스 아키텍처와 마이크로서비스 아키텍처 비교1마이크로서비스 아키텍처는 어플리케이션을 핵심 기능별로 세분화해 구성한다. 앞의 포털 사이트를 블로그 프로젝트, 카페 프로젝트, 메일 프로젝트로 나누어 개발하는 것이다. 각 서비스는 독립적인 프로젝트이기 때문에, 어떠한 언어든지 요구사항에 맞게 개발할 수 있고, 개발자는 오직 특정 서비스만 집중하기 때문에 코드에 대해서 상세히 파악할 수 있어 구현단계에서 효율을 높일 수 있다는 장점이 있다.서비스를 기능별로 구분해서 독립적인 어플리케이션을 개발하게 되면 각 서비스 간에 통신해야 하는 경우가 발생하는데, 이를 서버 간 통신이라고 한다. 이 때 통신은 아래와 같은 프로토콜(=규칙)에 의해 다양한 방식을 적용할 수 있다.HTTPHTTP는 Hyper Text Transfer Protocol의 약자로, 하이퍼텍스트 문서(HTML)를 교환하기 위해서 만들어진 프로토콜이다. HTTP는 비연결성 프로토콜이기 때문에 요청/응답(클라이언트-서버)방식으로 동작한다. HTTP는 웹에서만 사용하는 프로토콜로서 TCP/IP를 기반으로 동작한다. 문제점 2 HTTP는 텍스트 통신이라고 할수 있는데 누군가 중간에서 가로챈다면 내용이 노출되어 보안상의 문제가 있다. 통신 상대를 확인하지 않기 때문에 변조가 가능하다.이런 보안상의 문제를 해결하기 위해 HTTPS가 나타났다.HTTPSHTTP와 HTTPS 비교2HTTPS는 기존의 HTTP 레이어 밑에 SSL 이나 TLS 같은 보안 레이어가 추가된 프로토콜이다. 송신 측은 요청과 응답 데이터를 네트워크로 보내기 전에 보안 레이어에서 암호화 하고, 수신 측은 이 레이어에서 복호화 해 HTTP 레이어로 보낸다.보안 레이어는 보안 인증서 방식를 통해 데이터를 암호화 하고 안정성을 검증받는다. 인증서란 클라이언트와 서버간의 통신을 제 3자가 보증을 해주는 문서이다. 송신 측은 데이터를 보내기 전, 이 보증 기관으로부터 인증서를 받아 암호화 한 데이터와 함께 수신 측에 보낸다. 수신 측은 받은 인증서를 보증 기관에 확인해 이 데이터가 안전한 데이터인지 확인하고 동시에 복호화에 필요한 키를 받아 데이터를 복호화 한다.보안 레이어에서 사용하는 프로토콜은 SSL 과 TSL이 있다. SSL은 90년대 중반 넷스케이프에 의해서 생성되었지만, 현재는 폐기된 프로토콜이다. TLS는 IETF에서 유지 및 관리하는 웹의 보안 암호화를 위한 새로운 프로토콜이다.3SSHSecure Shell Protocol의 약자로, 안전하지 않은 네트워크 환경에서 원격지 host에 안전하게 접속하기 위해 사용되는 프로토콜이다. 즉, URL과는 관련이 없고, 원격으로 서버를 제어하거나 서버에 데이터를 보낼 때 사용하는 프로토콜이다. HTTPS와 마찬가지로 데이터를 대칭키 및 공개키 방식으로 암호화 해 유출의 위험을 줄인다. 또 서버 제어권을 획득하기 위해 비밀번호를 사용하면 비밀번호가 네트워크를 통해 교환되기 때문에 위험성이 존재하는데, SSH는 공개키 인증 방식을 사용하므로 보안상 더욱 안전하다.4SOAPSimple Object Access Protocol(단순 객체 접근 프로토콜)의 약자로, HTTP, HTTPS 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. 웹서비스(Open API)를 제공할 때 사용되는 프로토콜이자 해당 프로토콜 기반으로 만들어진 아키텍처이다. 같은 기능을 하는 REST 방식에 비해 구조가 복잡하고, 속도가 느리기 때문에 현재는 잘 사용하지 않는다고 한다.스프링 부트의 MVC 모델스프링 부트에서 spring-boot-starter-web 모듈을 사용하면 톰캣을 사용하는 스프링 MVC 구조를 기반으로 동작한다. MVC란, Model, View, Controller 의 합성어로, 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴이다. Model은 백그라운드에서 동작하는 로직을 처리하고, View는 사용자가 보게 될 결과 화면을 출력, Controller는 이 두 레이어 사이에서의 흐름을 제어한다. 톰캣은 WAS(Web Application Server)를 제공하는 대표적인 서비스 중 하나로, 서블릿을 통해 요청에 맞는 컨트롤러를 호출해 처리한 결과로 동적 컨텐츠를 반환, 스프링 컨테이너와 함께 MVC 구조에서 V와 C를 담당해 자동으로 처리한다.서블릿은 서블릿 컨테이너에서 관리하는데, 서블릿 컨테이너는 다음과 같은 특징을 가지고 있다: 각 요청마다 스레드를 생성하여 처리하는 멀티 스레딩을 지원한다. 서블릿 컨테이너는 서블릿 객체의 생명주기를 관리한다. 같은 요청이 올 때마다 새로운 객체를 만드는 것은 비효율적이므로, 객체를 싱글톤으로 관리해 같은 요청은 같은 인스턴스를 사용하도록 함.스프링 MVC 구조5스프링에서는 톰캣의 디스패처 서블릿(Dispatcher Servlet)이 서블릿 역할을 한다.클라이언트로부터 요청이 들어오면 서버는 다음과 같은 순서로 요청을 처리한다: 5 핸들러 조회: 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다. 핸들러 어댑터 조회: 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다. 핸들러 어댑터 실행: 핸들러 어댑터를 실행한다. 핸들러 실행: 핸들러 어댑터가 실제 핸들러를 실행한다. ModelAndView 반환: 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다. viewResolver 호출: 뷰 리졸버를 찾고 실행한다. JSP의 경우 InternalResourceViewResolver가 자동 등록되고, 사용된다. View 반환:뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다. JSP의 경우 InternalResourceView(JstlView)를 반환한다. 내부에 forward() 로직이 있다. 뷰 렌더링: 뷰를 통해서 뷰를 렌더링한다.핸들러 매핑은 요청 정보를 기준으로 어떤 컨트롤러를 사용할지 선정하는 인터페이스이다. 스프링은 기본적으로 5개의 다른 전략을 기용하는 구현체를 제공한다.[^] BeanNameUrlHandlerMapping빈의 이름에 들어 있는 URL을 HTTP 요청의 URL 과 비교해서 일치하는 빈을 찾아 준다. 빈을 정의할 때 슬래시(‘/’)가 들어가면 매핑 대상이 되고, ‘*’, ‘**’, ‘?’와 같은 와일드 카드를 사용하는 패턴을 넣을 수도 있다. ControllerBeanNameHandlerMapping빈의 아이디나 빈 이름을 이용해 매핑해주는 전략이다. 빈의 아이디가 hello 로 선언되었다면, /hello URL에 매핑해주는 것이다. ControllerClassNameHandlerMapping클래스의 이름과 같은 URL에 매핑해주는 전략이다. 클래스의 이름이 Controller로 끝나는 경우, Controller를 제외한 나머지 부분을 추가적으로 매핑 대상으로 삼는다. SimpleUrlHandlerMappingURL 패턴에 매핑된 컨트롤러를 사용하는 전략이다. 매핑할 컨트롤러 빈의 이름을 직접 넣어줘야 하기 때문에 오타 등의 오류가 발생할 가능성이 있다. DefaultAnnotationHandlerMapping@RequestMapping 이라는 애노테이션을 컨트롤러 클래스나 메소드에 직접 부여하고 이를 이용해 매핑하는 전략이다.레이어드 아키텍처레이어드 아키텍처(Layered Architecture)란 애플리케이션의 기능들을 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조이다. 각 레이어는 자신의 고유 역할을 수행하고, 인접한 다른 레이어에 무언가를 요청하거나 응답한다. 그 밖의 다른 레이어는 신경 쓸 필요가 없기 때문에, 각 레이어는 자신의 역할에 충실할 수 있다. 또, 기능별로 레이어를 나눴기 때문에, 시스템 전체를 수정하지 않고 특정한 레이어의 기능이나 성능을 개선하는 것이 가능해진다.스프링 레이어드 아키텍처6레이어드 아키텍처는 일반적으로 3계층 또는 4계층으로 나뉘는데, 3계층으로 이뤄진 레이어드 아키텍처는 다음과 같은 형태를 가진다. 프레젠테이션 계층클라이언트의 요청을 해석하고 응답을 보내는 계층이며, 스프링의 Dispatcher Servlet이 담당하는 부분으로 MVC중 V와 C가 모두 여기에 속한다. 비즈니스 계층서비스 계층이라고도 하며, 핵심 비즈니스 로직을 구현하는 계층이다. 즉, 여기서부터 개발자가 구현해야하는 부분이다. 트랜잭션 처리나 유효성 검사 등의 작업도 수행한다. 데이터 접근 계층프로그램이 종료되어도 데이터가 사라지지 않도록 저장하는 곳이므로, 영속(Persistence) 계층이라고도 한다. CRUD 연산을 하거나 비즈니스 로직에서 필요한 데이터를 DTO에 담아 다시 비즈니스 계층으로 보내는 역할이다. 디자인 패턴디자인 패턴(Design Pattern)은 소프트 웨어를 설계할 때 자주 발생하는 문제들을 해결하기 위해 고민된 해결책들을 말한다. 디자인 패턴을 구체화해서 정리한 대표적인 분류방식으로 ‘GoF 디자인 패턴’이라는 것이 있다. 생성(Creational) 패턴 구조(Structural) 패턴 행위(Behavioral) 패턴 추상 팩토리(Abstract Factory) 어댑터(Adapter) 책임 연쇄(Chain of Responsibility) 빌더(Builder) 브리지(Bridge) 커맨드(Command) 팩토리 메서드(Factory Method) 컴포지트(Composite) 인터프리터(Interpreter) 프로토타입(Prototype) 데코레이터(Decorator) 이터레이터(Iterator) 싱글톤(Singleton) 파사드(Facade) 미디에이터(Mediator)   플라이웨이트(Flyweight) 메멘토(Memento)   프락시(Proxy) 옵저버(Observer)     스테이트(State)     스트레티지(Strategy)     템플릿 메서드(Template Method)     비지터(Visitor) GoF 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴 총 세 가지로 구분된다.생성 패턴객체 생성에 사용되는 패턴으로, 객체를 수정해도 호출부가 영향을 받지 않게 하는 디자인 패턴이다. 추상 팩토리: 구체적인 클래스를 지정하지 않고 상황에 맞는 객체를 생성하기 위한 인터페이스를 제공하는 패턴이다. 빌더: 객체의 생성과 표현을 분리해 객체를 생성하는 패턴이다. 팩토리 메서드: 객체 생성을 서브클래스로 분리해서 위임하는 패턴이다. 프로토타입: 원본 객체를 복사해 객체를 생성하는 패턴이다. 싱글톤: 한 클래스마다 인스턴스를 하나만 생성해서 인스턴스가 하나임을 보장하고 어느 곳에서도 접근할 수 있게 제공하는 패턴이다.구조 패턴객체를 조합해서 더 큰 구조를 만드는 패턴이다. 어댑터: 클래스의 인터페이스를 의도하는 인터페이스로 변환하는 패턴이다. 브리지: 추상화와 구현을 분리해서 각각 독립적으로 변형케 하는 패턴이다. 컴포지트: 여러 객체로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루는 패턴이다. 데코레이터: 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 하는 패턴이다. 파사드: 서브시스템의 인터페이스 집합들에 하나의 통합된 인터페이스를 제공하는 패턴이다. 플라이웨이트: 특정 클래스의 인스턴스 한 개를 가지고 여러 개의 ‘가상 인스턴스’를 제공할 때 사용하는 패턴이다. 프락시: 특정 객체를 직접 참조하지 않고 해당 객체를 대행하는 객체를 통해 접근하는 패턴이다.행위 패턴객체 간의 알고리즘이나 책임 분배에 관한 패턴이다. 객체 하나로는 수행할 수 없는 작업을 여러 객체를 이용해 작업을 분배한다. 결합도 최소화를 고려할 필요가 있다. 책임 연쇄: 요청 처리 객체를 집합으로 만들어 결합을 느슨하게 만드는 패턴이다. 커맨드: 실행될 기능을 캡슐화해서 주어진 여러 기능을 실행하도록 클래스를 설계하는 패턴이다. 인터프리터: 주어진 언어의 문법을 위한 표현 수단을 정의하고 해당 언어로 구성된 문장을 해석하는 패턴이다. 이터레이터: 내부 구조를 노출하지 않으면서 해당 객체의 집합 원소에 순차적으로 접근하는 방법을 제공하는 패턴이다. 미디에이터: 한 집합에 속한 객체들의 상호작용을 캡슐화하는 객체를 정의한 패턴이다. 메멘토: 객체의 상태 정보를 저장하고 필요에 따라 상태를 복원하는 패턴이다. 옵저버: 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버 목록을 객체에 등록해 상태가 변할 때마다 메서드 등을 통해 객체가 직접 옵저버에게 통지하게 하는 디자인 패턴이다. 스테이트: 상태에 따라 객체가 행동을 변경하게 하는 패턴이다. 스트래티지: 행동을 클래스로 캡슐화해서 동적으로 행동을 바꿀 수 있게 하는 패턴이다. 템플릿 메서드: 일정 작업을 처리하는 부분을 서브클래스로 캡슐화해서 전체 수행 구조는 바꾸지 않으면서 특정 단계만 변경해서 수행하는 패턴이다. 비지터: 실제 로직을 가지고 있는 객체(visitor)가 로직을 적용할 객체(element)를 방문하며 실행하는 패턴이다.출처 https://velog.io/@ghkstmd00/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98 &#8617; https://wonyong-jang.github.io/web/2020/03/25/Web-http-https.html &#8617; &#8617;2 https://bumday.tistory.com/43 &#8617; https://ikcoo.tistory.com/246 &#8617; https://velog.io/@woply/spring-%EC%8A%A4%ED%94%84%EB%A7%81-MVC%EC%9D%98-%EC%A0%84%EC%B2%B4-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0 &#8617; &#8617;2 https://springsource.tistory.com/3 &#8617; " }, { "title": "[백엔드|스프링부트] 스프링 WEB 관련 모듈", "url": "/posts/SpringBoot_WebModules/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java", "date": "2022-09-25 21:10:00 +0900", "snippet": "스프링 프레임워크의 모듈1이전 포스트에서도 언급했듯이, 스프링 프레임워크는 기능별로 구분된 약 20여 개의 모듈을 제공한다. 이 중에서 웹과 관련된 모듈들은 다음과 같다: spring-web spring-webmvc spring-websocket spring-webmvc-portlet오늘은 이 네가지 모듈들이 각각 무엇인지, 왜 사용하는지에 대해 적어보려 한다.웹 모듈 spring-web스프링 프레임워크 공식문서1에 따르면, spring-web은 1. 다른 웹 프레임워크와의 통합, 2. 기본적인 웹 지향 통합 기능을 제공한다고 한다. 웹 지향 통합 기능의 예로는, 단일/다중 파일 업로드 기능을 담당하는 의존성 commons-fileupload와 빈 MultipartResolver가 있고, 어플리케이션에 웹 지향 어플리케이션 컨텍스트를 연동시키는 기능의 의존성인 AnnotationConfigApplicationContext 등이 있다.어플리케이션 컨텍스트(Application context)란, 빈의 생성과 관계설정 기능이 있는 빈 팩토리(Bean Factory)를 상속 받아 확장한 것으로, 빈이 만들어지는 방식과 시점 및 전략 등을 다르게 하거나 후처리나 정보의 조합, 인터셉트 등과 같은 다양한 기능을 이용하고 싶을 때 사용한다고 한다.2 공식 문서에서는 이러한 추가 기능 때문에 개발자는 빈 팩토리보다 어플리케이션 컨텍스트를 사용하는 것을 선호한다고 한다.서블릿 모듈 spring-webmvc스프링 프레임워크의 서블릿 관계도3spring-webmvc 는 자체 MVC 프레임워크를 제공함으로써 서블릿 기반의 웹 어플리케이션을 보다 쉽게 만들기 위한 스프링 프레임워크 모듈이다. @WebServlet 어노테이션으로 해당 클래스가 어느 요청을 처리할 것인지 선언하고, 반환값은 HTTP 규격에 맞춘 Response로 바꿔주는 @ResponseBody로 감싸 반환 해주면 된다. 4서블릿은 클라이언트 요청에 따라 동적으로 컨텐츠를 만들 수 있는 기능을 위해 만들어지는 클래스 파일이다. 다른 동적 컨텐츠를 만드는 기술로는 CGI가 있는데, 이는 멀티 프로세싱 방법을 사용하기 때문에 멀티 스레딩으로 요청을 처리하는 서블릿보다 서버 자원을 더 많이 차지한다.5웹소켓 모듈 spring-websocket이름에서 알 수 있듯이, 웹 소켓 통신 기능을 편리하게 도입할 수 있도록 해주는 모듈이다. 바닐라 자바로 웹 소켓을 구현하려면 Java Socket으로 소켓 통신의 과정을 일일이 구현해야 했다. 하지만 스프링프레임워크에서는 다른 모듈처럼 의존성을 주입시키고 핸들러만 구현해 등록시키면 다른 과정은 알아서 처리된다.6웹소켓을 사용하는 이유를 알기 위해서는 기존의 방식인 HTTP가 어떤 특징을 가지는지 알아야한다.HTTP 와 웹소켓의 차이7HTTP의 특징:8 단방향성 → 요청이 있어야만 무언가를 보낼 수 있음 비연결성 → 무언가를 보내고 나면 연결이 끊어짐HTTP는 tcp 기반으로 만들어진 통신 프로토콜이므로 3-way handshaking으로 연결하고 4-way handshaking으로 끊는데, 연결이 유지되지 않기 때문에 매 번 맺고 끊는 과정의 비용이 발생한다. 또, 메시지를 보낼 때마다 헤더가 포함되어야 하므로, 적은 데이터를 실시간으로 계속해서 보내야 하는 경우 (채팅 등) 부담이 커진다. 이런 문제점들을 해결하기 위해 나온 것이 웹소켓 프로토콜이다.따라서 웹소켓 프로토콜은 실시간 통신을 필요로 하는 서비스(채팅, 게임, 주식 거래 등)에 주로 사용된다.포틀릿 모듈 spring-webmvc-portlet포틀릿의 모습9서블릿과 마찬가지로 포틀릿 환경에서 사용할 MVC 구현을 제공해주는 모듈이다. 포틀릿 모듈이 가진 특징을 설명하기 이전에, 포틀릿이 무엇인지 알아야할 것 같다. 포틀릿은 포털을 구성하는 요소로, 웹 기반 컨텐츠나 어플리케이션 등에 접근할 수 있도록 해주는 재사용 가능한 웹 모듈이다. 기능만으로 봤을 때는 삼성 갤럭시 핸드폰에서 제공하는 위젯 기능과 비슷하다. 지메일 위젯을 예로 들면, 위젯을 바둑판 배열 가운데 원하는 위치에 원하는 크기로 배치할 수 있으며, 로그인 정보에 따라 각기 다른 메일함을 보여주는 것이다. 이렇게 개인화(Personalization)가 가능하다는 것이 포털 및 포틀릿의 가장 큰 특징이다. 10포틀릿과 서블릿은 정말 많은 부분에서 유사하다. 둘 모두 컨테이너에 배치되어 동적/정적 컨텐츠를 생성하는 웹 구성 요소이고, 클라이언트의 요청에 의해서 응답이 생성되는 방식으로 작동한다. 그렇지만 포틀릿은 html의 모든 것을 생성하지 못하고 마크업 조각만을 생성해 삽입될 수 있으며, 포틀릿에게는 URL이 주어지지 않아 포틀릿의 컨텐츠를 사용하고 싶으면 포틀릿을 포함한 URL을 호출해야 한다. 11출처 https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/html/overview.html#overview-modules &#8617; &#8617;2 https://mangkyu.tistory.com/151 &#8617; https://docs.spring.io/spring-framework/docs/current/reference/html/web.html &#8617; https://jwdeveloper.tistory.com/105 &#8617; https://joonyk.tistory.com/16 &#8617; https://dev-gorany.tistory.com/3 &#8617; https://blog.scaleway.com/iot-hub-what-use-case-for-websockets/ &#8617; https://velog.io/@rhdmstj17/%EC%86%8C%EC%BC%93%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%95%9C-%EB%B2%88%EC%97%90-%EC%A0%95%EB%A6%AC-2 &#8617; https://docs.webix.com/desktop__portlet.html &#8617; https://blog.outsider.ne.kr/934 &#8617; https://blog.daum.net/tomayoon/7095404 &#8617; " }, { "title": "[백엔드|스프링부트] 스프링부트란?", "url": "/posts/SpringBoot_AboutSB/", "categories": "Backend, SpringBoot", "tags": "Tutorial, Backend, Spring, SpringBoot, Java", "date": "2022-09-19 22:20:00 +0900", "snippet": "백엔드 개발자로 웹 개발을 할 때 알야야 할, 특히 한국에서라면 거의 필수가 되는 기술 스택인 SpringBoot. 앞으로 몇 주간은 이에 대해 배우며, 공부한 내용을 포스팅 할 계획이다. 첫 포스트인만큼, 먼저 SpringBoot가 무엇인지 알아보자.스프링 프레임워크스프링 로고1스프링부트는 스프링을 더욱 쉽게 사용할 수 있도록 하기 위해 나온 것이므로, 먼저 스프링에 대해 설명하겠다.스프링 프레임워크(Spring Framework), 줄여서 스프링 이라고 부르는 이 프레임워크는 자바로 애플리케이션을 개발하는 데 필요한 것들을 제공하고, 쉽게 사용할 수 있도록 도와주는 도구이다. 스프링은 특히 백엔드 개발에 많이 사용되며, 자바스크립트에서의 Node.js와 위치가 같다고 생각하면 편하다.스프링은 바닐라 자바와 비교해서 다음과 같은 특징을 가지고 있다.제어 역전 (IoC: Inversion of Control)스프링의 제어 역전바닐라 자바로 개발할 때, 객체를 사용하고 싶으면 일반적으로는 개발자의 제어 하에 객체를 만들고 호출하고 없앤다 (객체의 생명주기라고도 함). 하지만 스프링의 경우 외부(스프링 컨테이너)에서 객체를 생성하고, 필요할 때 객체를 불러와 사용하는 방식으로 객체를 관리한다. 이처럼 객체의 제어를 외부에 위임하는 방식을 제어 역전이라고 하고, 스프링은 이 개념이 적용된 프레임워크이다. 제어 역전은 코드의 재사용성과 유지보수성을 높인다는 장점이 있다.의존성 주입 (DI: Dependency Injection)한 클래스에서 다른 클래스의 객체를 사용할 때, 그 클래스 자체가 아닌 프레임 워크로부터 객체를 받는 방식의 디자인 패턴으로, 위의 제어 역전에서의 ‘객체를 불러온다’는 부분을 담당하는 제어 역전의 하위 개념이다.스프링에서는 @Autowired 라는 어노테이션을 통해 의존성을 주입할 수 있고, 의존성을 주입 받는 방법은 다음과 같은 세 가지가 있다: 생성자를 통한 의존성 주입 @RestController public class DIController { MyService myService; @Autowired public DIController(MyService myService) { this.myService = myService; } @GetMapping(\"/di/hello\") public String getHello() { return myService.getHello(); } } 필드 객체 선언을 통한 의존성 주입 @RestController public class FieldInjectionController { @Autowired private MyService myService; } setter 메서드를 통한 의존성 주입 @RestController public class SetterInjectionController { MyService myService; @Autowired public void setMyService(MyService myService) { this.myService = myService; } } 스프링 공식 문서에서 권장하는 방법은 1. 생성자를 통해 주입받는 방식이다. 해당 방식만이 레퍼런스 객체 없이는 객체를 초기화 할 수 없게 설계할 수 있기 때문이다.관점 지향 프로그래밍 (AOP: Aspect-Oriented Programming)AOP 방식의 애플리케이션 로직객체 지향 프로그래밍 (Object-Oriented Programming)의 심화 개념으로, OOP로 각 핵심 기능들을 모듈화 해 분리시켜 놓았다면, AOP는 그 분리시킨 모듈들이 가지고 있는 핵심 기능 이외의 공통적인 부분들을 다시 분리 시켜 핵심 기능을 수행할 때마다 해당 부분들을 불러오는 개발 방식을 의미한다. 스프링은 기능 호출 할 때마다 전처리, 후처리를 포함하는 디자인 패턴인 프락시 패턴을 이용해 AOP 기능을 제공하고 있다.스프링 프레임워크의 다양한 모듈스프링 프레임워크의 모듈2스프링 프레임워크는 기능별로 구분된 약 20여 개의 모듈로 구성돼 있다. 구체적인 모듈들은 버전마다 조금씩 달라질 때도 있지만, 큰 틀은 유사하다. 애플리케이션을 개발 할 때 위의 모듈들을 무조건 포함해서 사용하는 것이 아닌, 필요한 모듈만 선택해서 사용할 수 있게끔 설계 되어 있어, 이를 ‘경량 컨테이너 설계’라고 부른다.스프링 프레임워크 vs. 스프링 부트스프링부트 로고3스프링은 이렇게 기존 개발 방식의 문제와 한계를 극복하기 위해 다양한 기능을 제공하는데, 오히려 기능이 너무 많아 설정이 복잡해졌다는 문제점이 생겨버렸다. 이 블로그4를 보면, 웹 애플리케이션 개발을 위해 설정해야 하는 사항들이 스프링에서는 정말 복잡하게 나열되어 있는데 반해, 스프링 부트는 설정할 파일도 적고, 파일의 내용 또한 많이 축소 되어 있다. 이는 스프링부트가 스프링에 비해 다음과 같은 방면에서 뛰어나기 때문이다.의존성 관리pom.xml 예시 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wikibooks&lt;/groupId&gt; &lt;artifactId&gt;chapter1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;chapter1&lt;/name&gt; &lt;description&gt;chapter1&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 스프링, 스프링부트 모두 라이브러리에 대한 의존성 관리는 pom.xml(Project Object Model)이라는 파일을 통해 관리하게 된다. 이 때, 스프링이라면 사용할 라이브러리의 각각의 모듈에 대해 태그 내에 , , 태그를 모두 작성해주어야 한다. 때문에 pom.xml 파일이 길어지는 것은 물론, 어느 한 라이브러리의 버전을 올릴 때에도 연관된 다른 라이브러리들의 버전을 모두 신경써주어야 한다. 하지만 스프링부트에서는 `spring-boot-starter`라는 의존성을 주입해 의존성 조합을 제공받고, 태그 내의 `start-parent`가 의존성 조합들간 충돌 문제가 없는 검증된 버전들을 알아서 추가 한다. 때문에 `pom.xml` 에 태그들을 일일히 적을 필요가 없는 것이다.다음은 많이 사용되는 spring-boot-starter 라이브러리들이다. spring-boot-starter-web: 스프링 MVC를 사용하는 RESTful 애플리케이션을 만들기 위한 의존성. 기본적으로 톰캣(Tomcat)이 포함되어 있어 jar 형식으로 실행 가능하다. spring-boot-starter-test: JUnit Jupiter, Mockito등 단위 테스트 라이브러리를 포함한다. spring-boot-starter-jdbc: HikariCP 커넥션 풀을 활용한 JDBC 기능을 제공한다. spring-boot-starter-security: 스프링 시큐리티(인증, 권한, 인가 등) 기능을 제공한다. spring-boot-starter-data-jpa: 하이버네이트를 활용한 JPA 기능을 제공한다. spring-boot-starter-cache: 스프링 프레임워크의 캐시 기능을 지원한다.자동 설정스프링 부트는 스프링 프레임워크의 기능을 사용하기 위한 자동 설정(Auto Configuration)을 지원한다. @SpringBootApplication이라는 어노테이션을 작성해 놓으면, 프레임워크가 다음 어노테이션들을 읽어내어 애플리케이션을 개발하는 데 필요한 의존성을 추가할 때 자동으로 관리해준다. 5 SpringBootConfiguration: 빈 팩토리를 위한 오브젝트를 설정을 담당하는 클래스라고 인식 할 수 있도록 알려주는 어노테이션이다. EnableAutoConfiguration: Spring boot의 핵심으로써, 미리 정의되어 있는 Bean들(spring-boot-autoconfigure &gt; META-INF &gt; spring.factories)을 가져와서 등록해준다. ComponentScan: 현재 패키지 이하에서 아래와 같은 어노테이션이 붙어 있는 클래스들을 찾아서 빈으로 등록하는 역할을 한다. @Component @Configuration @Repository @Service @Controller @RestController 내장 WAS스프링 부트의 각 웹 애플리케이션에는 내장 WAS(Web Application Server)가 존재하며, 웹 의존성인 spring-boot-starter-web의 경우, 톰캣을 내장한다. 때문에 특별한 설정 없이도 톰캣을 실행할 수 있다. 필요에 따라서 톰캣이 아닌 다른 웹 서버(Jetty, Undertow 등) 으로 대체 가능하다.모니터링서비스를 운영할 때 시스템이 사용하는 스레드, 메모리, 세션 등의 주요 요소를 모니터링 해야하는데, 스프링 부트네는 스프링 부트 액추에이터(Spring Boot Actuator)라는 자체 모니터링 도구가 내장되어 있다.출처 https://en.wikipedia.org/wiki/Spring_Framework &#8617; https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/html/overview.html#overview-modules &#8617; https://spring.io/projects/spring-boot &#8617; https://mirotic91.tistory.com/4 &#8617; https://velog.io/@suwon-city-boy/%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4 &#8617; " }, { "title": "[알고리즘|파이썬] 2차원 그래프 탐색을 빠르게 돌리는 법", "url": "/posts/Algo_2Dgraph/", "categories": "Algorithm, How To", "tags": "Algorithm, Python, Pypy, Graph Search, DFS, BFS, Matrix", "date": "2022-08-31 16:32:00 +0900", "snippet": "개요백준 사이트에서 알고리즘 문제를 풀면서 생겼던 의문이 있었다.graph2D[x][y] = 0 # 인덱스 x와 y에서 각각 한 번씩, 총 두 번 호출graph1D[xy] = 0 # 인덱스 xy에서 한 번 호출위와 같이 2차원 그래프 graph2D에서 x행 y열의 원소를 접근 할 때, x 인덱스와 y 인덱스 두 번을 호출 하는 것보다, 2차원 그래프를 일렬로 나열해 놓은 1차원 그래프 graph1D에서 xy 인덱스로 한 번에 호출 하는 것이 더 빠르지 않을까?결론부터 말하자면, ‘그렇다’ 이다. 아래의 예시코드를 보자.import time# 세로 크기 R, 가로 크기 C의 2차원 그래프에서 # 왼쪽 위칸에서 시작해 BFS로 모든 칸을 탐색하며# 방문 순서에 따라 숫자를 붙여주는 그래프를 만든다고 하자.R, C = 1000, 1000# 2차원 그래프에서 BFS를 돌리기 위한 준비물graph2D = [[0 for _ in range(R)] for _ in range(C)]visit2D = [[0 for _ in range(R)] for _ in range(C)]dx = (1, -1, 0, 0)dy = (0, 0, 1, -1)que2D = [(0, 0)]# 1차원 그래프에서 BFS를 돌리기 위한 준비물L = C+1graph1D = [0] * R*Lvisit1D = [0] * R*L + [1] * Lvisit1D[C:R*L:L] = [1] * Rdxy = (1, -1, L, -L)que1D = [0]# 2차원 그래프 BFSini2D = time.time()visit2D[0][0] = 1graph2D[0][0] = 1for x, y in que2D: for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; R and 0 &lt;= ny &lt; C and not visit2D[nx][ny]: visit2D[nx][ny] = 1 que2D.append((nx, ny)) graph2D[nx][ny] = len(que2D)fin2D = time.time()# 1차원 그래프 BFSini1D = time.time()visit1D[0] = 1graph1D[0] = 1for xy in que1D: for d in dxy: if not visit1D[xy+d]: visit1D[xy+d] = 1 que1D.append(xy+d) graph1D[xy+d] = len(que1D)fin1D = time.time()print(f'2차원 그래프 BFS 실행 시간: {fin2D - ini2D} sec')print(f'1차원 그래프 BFS 실행 시간: {fin1D - ini1D} sec')# 출력:# 2차원 그래프 BFS 실행 시간: 1.1490559577941895 sec# 1차원 그래프 BFS 실행 시간: 0.3833479881286621 sec# # 주석 해제 후 실행하면 결과물이 동일함을 확인할 수 있다.# # 주의: R과 C를 10으로 낮추고 실행하자.# # print('2차원 그래프 BFS 결과')# print(*graph2D, sep='\\n')# # print('1차원 그래프 BFS 결과')# for r in range(0, R*L, L):# print(graph1D[r:r+C])출력 결과를 보면 세 배 이상의 시간 차이가 나는 것을 볼 수 있다. 물론 위의 차이는 2차원 그래프 직렬화만으로 나온 것은 아니다. if 문을 간소화 시키기 위해, 직렬화를 하는 동시에 방문 배열에 간단하게 전처리를 한 것도 한 몫 했을 것이다.이 글에서는 어떻게 하면 2차원 그래프를 1차원으로 바꾸어 처리할 수 있는지 그 방법에 대해 다루려고 한다.입력입력은 백준 문제를 푸는 것 처럼, 표준 입력을 받아 처리한다고 가정한다.입력을 받기 전에 정해야 할 것은 2차원 그래프의 마진 칸 수를 정하고, 마진을 포함한 칸수의 그래프를 미리 선언해 두는 것이다.마진이 필요한 이유는 각 행의 우측 끝 칸과 그 다음 행의 왼쪽 끝 칸이 인접한 것으로 판단되는 것을 방지하기 위함이다. 위 그림에서의 1번 칸과 3번 칸이 서로 인접하지 않도록 2번칸을 넣어주는 것과 같다. 마진은 보통 1칸으로 설정해두면 되지만, 1726번: 로봇문제 처럼 한 번에 여러 칸을 이동하는 경우, 그 칸 수만큼 설정해야 할 수 있다.마진에 어떤 값을 넣느냐에 따라 탐색시의 if 문을 간소화 시킬 수 있다. 마진을 탐색하는 경우는 2차원 그래프 바깥으로 나가는 경우이므로, 문제에 주어지는 벽, 장애물 등의 탐색 제외 값을 입력 배열의 마진에 넣어주거나, 해당 칸을 미리 방문 한 것처럼 방문 값을 방문 배열의 마진에 넣어주면, 0 &lt;= nx &lt; R and 0 &lt;= ny &lt; C 조건을 넣지 않아도 걸러낼 수 있다. 두 방법 중 어느 걸 택할지는 문제 조건을 보고 가능한 방법을 선택하면 된다.이렇게 하면 각 칸의 좌표 값은 열값(y)에 좌표의 행값 과 마진을 포함한 열의 칸수의 곱(x*L)을 더한 값이 된다. 이 상태에서 for문을 사용해 마진칸을 제외하고 입력을 받으려면 for x in range(0, R*L, L): 에 graph[x:x+C] = map(int, input().split()) 을 사용하면 된다. 만약 문제 조건에 의해 모든 칸을 한 번씩 탐색해야 할 때는, 앞의 for문에 이중 포문으로 for xy in range(x, x+C): 를 더해 나오는 좌표값 xy를 탐색하면 된다.아래는 7576: 토마토문제로 작성한 예시이다. 해당 문제의 경우 입력 배열 자체를 방문 배열로 사용 가능하기 때문에, 방문 배열을 선언하지 않아도 되지만, 설명을 위해 선언한 예시를 보여주겠다.import sysinput = sys.stdin.readlineC, R = map(int, input().split())L = C+1que = []notRipe = 0# 입력 배열 마진에 탐색 제외값을 넣는 방법visit = [0] * R * Lgraph = [-1] * (R+1) * L for x in range(0, R*L, L): graph[x:x+C] = map(int, input().split()) for xy in range(x, x+C): if graph[xy] == 1: que.append(xy) elif graph[xy] == 0: notRipe += 1# 방문 배열 마진에 방문 값을 넣는 방법visit = [0] * R * L + [1] * Lvisit[C:R*L:L] = [1] * R graph = [0] * R * Lfor x in range(0, R*L, L): graph[x:x+C] = map(int, input().split()) for xy in range(x, x+C): if graph[xy] == 1: que.append(xy) elif graph[xy] == 0: notRipe += 1탐색탐색은 오히려 더 간단해진다.일반적인 2차원 그래프 탐색은 델타 값으로 dx = (0, 0, 1, -1); dy = (1, -1, 0, 0) 을 선언하고, 탐색시 if 문에 0 &lt;= nx &lt; R and 0 &lt;= ny &lt; C 같은 조건을 넣어야 하지만, 직렬화 시켰다면 dxy = (1, -1, L, -L) 으로 델타값만 선언하면 된다. 격자 바깥으로 나가는 경우는 입력받을 때 걸러지기 때문이다.dxy = (1, -1, L, -L)for time in range(0, R*C): if notRipe == 0: break nextQue = [] for xy in que: for d in dxy: if graph[xy+d] == 0 and visit[xy+d] == 0: # 입력 배열의 마진을 수정했으면 앞에서 걸러지고, # 방문 배열의 마진을 수정했으면 뒤에서 걸러진다. visit[xy+d] = 1 nextQue.append(xy+d) if not nextQue: time = -1 break notRipe -= len(nextQue) que = nextQueprint(time)결과def main(): C, R = map(int, input().split()) L = C+1 que = [] notRipe = 0 visit = [0] * R * L graph = [-1] * (R+1) * L for x in range(0, R*L, L): graph[x:x+C] = map(int, input().split()) for xy in range(x, x+C): if graph[xy] == 1: que.append(xy) elif graph[xy] == 0: notRipe += 1 dxy = (1, -1, L, -L) for time in range(0, R*C): if notRipe == 0: break nextQue = [] for xy in que: for d in dxy: if graph[xy+d] == 0 and visit[xy+d] == 0: visit[xy+d] = 1 nextQue.append(xy+d) if not nextQue: time = -1 break notRipe -= len(nextQue) que = nextQue return timeif __name__ == \"__main__\": print(main())" }, { "title": "[백준] 3109번: 빵집", "url": "/posts/BOJ_3109/", "categories": "Algorithm, BOJ", "tags": "Algorithm, Baekjoon_Online_Judge, Python, Pypy, 3109, 빵집", "date": "2022-08-30 19:10:00 +0900", "snippet": "문제[원문 링크]유명한 제빵사 김원웅은 빵집을 운영하고 있다. 원웅이의 빵집은 글로벌 재정 위기를 피해가지 못했고, 결국 심각한 재정 위기에 빠졌다.원웅이는 지출을 줄이고자 여기저기 지출을 살펴보던 중에, 가스비가 제일 크다는 것을 알게되었다. 따라서 원웅이는 근처 빵집의 가스관에 몰래 파이프를 설치해 훔쳐서 사용하기로 했다.빵집이 있는 곳은 R*C 격자로 표현할 수 있다. 첫째 열은 근처 빵집의 가스관이고, 마지막 열은 원웅이의 빵집이다.원웅이는 가스관과 빵집을 연결하는 파이프를 설치하려고 한다. 빵집과 가스관 사이에는 건물이 있을 수도 있다. 건물이 있는 경우에는 파이프를 놓을 수 없다.가스관과 빵집을 연결하는 모든 파이프라인은 첫째 열에서 시작해야 하고, 마지막 열에서 끝나야 한다. 각 칸은 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선으로 연결할 수 있고, 각 칸의 중심끼리 연결하는 것이다.원웅이는 가스를 되도록 많이 훔치려고 한다. 따라서, 가스관과 빵집을 연결하는 파이프라인을 여러 개 설치할 것이다. 이 경로는 겹칠 수 없고, 서로 접할 수도 없다. 즉, 각 칸을 지나는 파이프는 하나이어야 한다.원웅이 빵집의 모습이 주어졌을 때, 원웅이가 설치할 수 있는 가스관과 빵집을 연결하는 파이프라인의 최대 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 R과 C가 주어진다. (1 ≤ R ≤ 10,000, 5 ≤ C ≤ 500)다음 R개 줄에는 빵집 근처의 모습이 주어진다. ‘.’는 빈 칸이고, ‘x’는 건물이다. 처음과 마지막 열은 항상 비어있다.출력첫째 줄에 원웅이가 놓을 수 있는 파이프라인의 최대 개수를 출력한다.해설이 문제는 가장 왼쪽 열에서 시작해 가장 오른쪽 열로 도달하는 가장 윗 길을, 각 행마다 겹치지 않게 찾아주면 되는 간단한 문제다. 각 행(y)을 for문을 돌리고, 열(x)은 0부터 큐에 넣어주고, for i in range(N): que.append([i, 0]) DFS를 돌면서 x+1과 (y+1, y, y-1) 칸들을 탐색하면서 while que: y, x = que.pop() vis[y][x] = 1 nx = x + 1 for j in range(1, -2, -1): ny = y + j 장애물이 없으며, 동시에 방문하지 않은 칸을 큐에 추가하고, if 0 &lt;= ny &lt; N and brd[ny][nx] == '.' and not vis[ny][nx]: que.append((ny, nx)) x가 가장 오른쪽 열(M-1)에 도달한 경우, DFS를 멈추고 정답(cnt)에 1을 더해준다. if x == M-1: cnt += 1 que.clear() break 유의할 점으로는, 파이프로 쓰이지 않았더라도, 방문했던 칸은 다시 방문하지 않도록 해주었는데, 이는 어차피 해당 칸은 결국 막혀 있어 쓰이지 않을 것이기 때문이다.예시밑의 예시 그림을 보면서 큐에 어떤 좌표가 있는지 따라가면 이해하기 쉬울 것이다.큐에 (0, 0)을 넣고 시작한다.que = [(0, 0)](0, 0) (1번칸) 탐색시, 위를 제외한 앞, 밑칸으로 갈 수 있다.que = [(1, 1), (0, 1)](0, 1) (2번칸) 탐색시, 위, 앞, 밑 모두 막혀 있다.que = [(1, 1)](1, 1) (3번칸) 탐색시, 밑칸으로 갈 수 있다.que = [(2, 2)](2, 2) (4번칸) 탐색시, 위, 앞칸으로 갈 수 있다.que = [(3, 2), (3, 3)](3, 3) (5번칸) 탐색시, 위, 앞, 밑 모두 갈 수 있다.que = [(3, 2), (4, 3), (4, 2), (4, 1)](4, 1) (6번칸) 탐색시, x가 M-1인 4에 도달 했으므로, DFS 종료.cnt에 1을 더해주고, 방문 기록은 그대로 남겨두고, 다음 열에서 DFS 다시 시작, 마지막 열까지 모두 진행하면 끝이다.import sysinput = sys.stdin.readlinedef main(): N, M = map(int, input().split()) brd = [input().strip() for _ in range(N)] vis = [[0] * M for _ in range(N)] cnt = 0 que = [] for i in range(N): que.append([i, 0]) while que: y, x = que.pop() vis[y][x] = 1 if x == M-1: cnt += 1 que.clear() break nx = x + 1 for j in range(1, -2, -1): ny = y + j if 0 &lt;= ny &lt; N and brd[ny][nx] == '.' and not vis[ny][nx]: que.append((ny, nx)) return cntif __name__ == \"__main__\": print(main())결과" } ]
