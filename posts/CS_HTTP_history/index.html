<!DOCTYPE html><html lang="ko-KR" data-mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[CS] HTTP 1.0 부터 3.0까지: HTTP 규약은 어떻게 변화해 왔나" /><meta name="author" content="TaemHam" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="This is a wannabe backend developer’s dev blog." /><meta property="og:description" content="This is a wannabe backend developer’s dev blog." /><link rel="canonical" href="https://taemham.github.io/posts/CS_HTTP_history/" /><meta property="og:url" content="https://taemham.github.io/posts/CS_HTTP_history/" /><meta property="og:site_name" content="TaemHam" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-13T09:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[CS] HTTP 1.0 부터 3.0까지: HTTP 규약은 어떻게 변화해 왔나" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"TaemHam","url":"https://github.com/TaemHam/"},"dateModified":"2023-02-13T09:00:00+09:00","datePublished":"2023-02-13T09:00:00+09:00","description":"This is a wannabe backend developer’s dev blog.","headline":"[CS] HTTP 1.0 부터 3.0까지: HTTP 규약은 어떻게 변화해 왔나","mainEntityOfPage":{"@type":"WebPage","@id":"https://taemham.github.io/posts/CS_HTTP_history/"},"url":"https://taemham.github.io/posts/CS_HTTP_history/"}</script><title>[CS] HTTP 1.0 부터 3.0까지: HTTP 규약은 어떻게 변화해 왔나 | TaemHam</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="TaemHam"><meta name="application-name" content="TaemHam"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://raw.githubusercontent.com/TaemHam/Taemham.github.io/main/assets/img/pics/TaemHam_Face.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">TaemHam</a></div><div class="site-subtitle font-italic">and his devlog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/TaemHam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tk4003950','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[CS] HTTP 1.0 부터 3.0까지: HTTP 규약은 어떻게 변화해 왔나</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[CS] HTTP 1.0 부터 3.0까지: HTTP 규약은 어떻게 변화해 왔나</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1676246400" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2023-02-13 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/TaemHam/">TaemHam</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2571 단어"> <em>14 분</em>읽는 시간</span></div></div></div><div class="post-content"><p><img data-src="https://www.investopedia.com/thmb/Sh6RKE3ItNkCDYbjI40DcuLlaS4=https://raw.githubusercontent.com/TaemHam/Taemham.github.io/main/assets/img/750x0/filters:no_upscale():max_bytes(150000):strip_icc():format(webp)/IPaddress-1e113dd325f74135ab2183d432ea5865.jpg" alt="" data-proofer-ignore></p><h2 id="개요"><span class="mr-2">개요</span><a href="#개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>인터넷에서 웹 서버와 사용자 컴퓨터에 설치된 웹 브라우저 사이에 문서를 전송하기 위한 통신 규약인 HTTP 프로토콜은, 당연하게도 처음부터 완벽한 상태로 나오지는 않았다. 개발자들은 ‘어떻게 하면 더 빨리, 더 안전하게 응답을 보낼 수 있을까’에 대해 고민하며 데이터 송수신 방식을 발전시켜왔고, 그에 따라 여러가지 규약들이 생겨났다. 이번엔 이 HTTP의 규약이 처음엔 어땠고, 어떤 변화를 거쳐왔는지 알아보도록 하자.</p><h2 id="http10"><span class="mr-2">HTTP/1.0</span><a href="#http10" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="https://media.licdn.com/dms/image/C5612AQE9qQFC78CzbA/article-inline_image-shrink_1000_1488/0/1623005286462?e=1681948800&amp;v=beta&amp;t=https://raw.githubusercontent.com/TaemHam/Taemham.github.io/main/assets/imgx7U297-FWx5nRJ5whRCGxxBcmcmP9TY6bolhBEunzCg" alt="" data-proofer-ignore></p><h3 id="특징"><span class="mr-2">특징</span><a href="#특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>TCP 기반으로 연결을 설정한다.<li>한 연결에 하나의 요청을 처리하도록 설계 되었다.<li>GET, HEAD, POST의 메서드만을 지원한다.<ul><li>GET : Request-URI에서 지정한 정보를 Entity Body로 전달해달라는 요청<li>HEAD : Header의 정보만 요구<li>POST : Request 메시지의 body에 포함된 자원을 Request-URI로 넘겨주는 경우 사용</ul></ul><h3 id="한계"><span class="mr-2">한계</span><a href="#한계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>서버로부터 파일을 가져올 때마다 TCP의 3-웨이 핸드셰이크를 열어야해서 RTT(라운드 트립, 패킷 왕복 시간)가 증가하는 단점이 있다.<ul><li>RTT 증가에 대한 해결책으로 이미지 스프라이트(여러 개의 이미지를 하나의 이미지로 합쳐서 관리하는 이미지), 코드 압축(빈 칸 삭제), 이미지 Base64 인코딩 방식을 사용했다.</ul></ul><h2 id="http11"><span class="mr-2">HTTP/1.1</span><a href="#http11" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https://raw.githubusercontent.com/TaemHam/Taemham.github.io/main/assets/imghttps%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxFnJz%2FbtrNosPHQNi%2F03ZVFkvTWwVcGfC9K9ULi1%2Fimg.png" alt="" data-proofer-ignore></p><h3 id="특징-1"><span class="mr-2">특징</span><a href="#특징-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>HTTP/1.0에서 발전한 것으로, 매번 TCP 연결을 하는 것이 아니라, 한번 <strong>TCP를 초기화 한 후 Keep-alive 옵션으로 여러개의 파일을 송수신</strong> 할 수 있게 바뀌었다.<li><strong>여러 개의 요청을 동시에 보내</strong>는 Pipelining을 지원해 응답 속도를 높일 수 있게끔 했다.<li>OPTION, PUT, DELETE, TRACE의 메서드가 추가되었다.<ul><li>OPTION : 통신과 관련된 선택사항들에 대한 정보를 요구하는 경우<li>PUT : Request 메시지에 포함되어 있는 data를 지정한 Request-URI로 저장하기 위함<li>DELETE : 특정 resource를 지우기 위함<li>TRACE : 최종 destination까지의 Loopback을 테스트하기 위함</ul></ul><h3 id="한계-1"><span class="mr-2">한계</span><a href="#한계-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>문서 안에 포함된 다수의 리소스를처리하려면, 요청할 리소스 개수에 비례해서 대기 시간이 길어지는 단점이 있다.<li>HOL Blocking(Head Of Line Blocking)으로 전송이 빠르지만 나중에 도착한 패킷(css 등)보다 전송이 느리지만 먼저 도착한 패킷(이미지 등)을 먼저 전송해야해서 성능 저하 현상이 발생한다.<li>HTTP/1.1의 헤더에는 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무겁다.</ul><h2 id="http2"><span class="mr-2">HTTP/2</span><a href="#http2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="https://file.okky.kr/images/1645506175857.png" alt="" data-proofer-ignore></p><h3 id="장점"><span class="mr-2">장점</span><a href="#장점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>여러 개의 스트림을 사용해 송수신</strong>하는 멀티플렉싱을 지원한다. 멀티플렉싱은 하나의 TCP 연결로 동시에 여러개의 메시지를 주고 받고, 응답을 순서에 상관없이 스트림으로 주고받는 방식을 말한다. 즉, HTTP 상의 HOL Blocking을 해결하게 되었다.<li><strong>중복되는 헤더의 반복 전송을 낮추</strong>기 위해, 허프만 코딩 압축 알고리즘(중복 횟수가 많은 정보는 적은 비트 수를 사용해 표현하며 데이터의 표현에 필요한 비트양을 줄이는 방식)을 사용해 헤더를 HPACK 압축 형식으로 압축해서 전송한다.<li>서버 푸시 기능을 통해 클라이언트가 <strong>요청하지 않은 데이터라도 서버가 스스로 전송</strong>해줄 수 있도록 했다. html에 css와 js가 포함되어있다면, html 요청 한 번에 html, css, js 응답 3개를 모두 전송하는 것이다.</ul><h3 id="한계-2"><span class="mr-2">한계</span><a href="#한계-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>TCP 기반으로 동작하기에 핸드셰이크 과정이 필수적이고, 그에 따른 지연 시간이 발생한다.<li>패킷이 유실되거나 오류가 있을때 재전송을하는데, 이 패킷을 재전송하는 동안 전체 패킷 전송이 중단되게 된다. HOL Blocking 문제가 여전히 발생하는 것이다.</ul><h2 id="http3"><span class="mr-2">HTTP/3</span><a href="#http3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="https://velog.velcdn.com/images%2Fwsong0101%2Fpost%2Fc0cb6743-6d56-4203-8068-0a12180bad24%2F3.png" alt="" data-proofer-ignore></p><h3 id="특징-2"><span class="mr-2">특징</span><a href="#특징-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>TCP 기반이 아닌, UDP 기반으로 <strong>QUIC 프로토콜을 사용해 연결 설정</strong>을 하기 때문에 3-웨이 핸드셰이크 과정을 필요로 하지 않는다. 또, 보안 통신을 위해 TLS를 이용할 때에도 TCP+TLS 로 다수의 라운드 트립이 필요했던 HTTP/2와 다르게, Quic은 TLS 인증서를 내포하고 있기 때문에 인증도 단축되었다. 결과적으로 첫 연결 설정에 한 번의 라운드 트립만 필요하고, 덕분에 <strong>초기 연결의 시간이 단축</strong>되었다.<li>순방향 오류 수정 메커니즘이 적용되어, 패킷이 손실 되었어도 수신 측에서 에러를 검출하고 수정할 수 있어 <strong>패킷 손실률이 낮다</strong>.<li>각 스트림을 스트림 식별자로 식별함으로 스트림 중 하나에서 <strong>어떤 패킷이 손실되더라도 해당 스트림만 멈추게 된다</strong>. 즉, TCP상의 HOL Blocking 문제까지 해결하게 되었다.<li>QUIC은 Connection ID를 사용하여 서버와 연결을 생성하기 때문에, 네트워크 변경과 같이 <strong>IP가 바뀌는 상황에도 연결을 유지</strong>할 수 있다.</ul><h3 id="한계-3"><span class="mr-2">한계</span><a href="#한계-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>QUIC은 패킷별로 암호화를 한다. 이는 기존의 TLS-TCP에서 패킷을 묶어서 암호화하는 것보다 더 큰 리소스 소모를 불러올 수 있다는 단점이 있다.<li>UDP 기반이기 때문에 패킷 차단에 필요한 정보가 거의 없어 Ddos 공격에 대응하기 어렵고, 또 IP 스푸핑으로 IP를 속인 채 요청을 대량으로 보내면 피해 IP는 원치 않는 데이터를 대량으로 수신하게 되는 반사 공격을 할 수도 있다.</ul><h2 id="예상-질문"><span class="mr-2">예상 질문</span><a href="#예상-질문" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>HTTP/1.0 에 대해 설명해주세요.</ul><details> <summary>답변</summary> 1. HTTP/1.0는 TCP를 기반으로 한 번의 연결로 하나의 요청을 처리할 수 있도록 설계된 버전입니다. 2. 요청 하나마다 3-웨이 핸드셰이킹으로 연결하고 4-웨이 핸드셰이킹으로 종료해야 하므로, 라운드 트립이 여러번 발생한다는 단점이 있습니다. 3. 이런 단점에 대한 해결책으로 이미지 스프라이트나 Base64 인코딩, 코드 압축 같은 기술이 도입되었습니다. * 이미지 스프라이트란 여러 개의 이미지를 하나로 합쳐 관리하는 기법입니다. * Base64 인코딩은 이미지파일을 64진법으로 이루어진 문자열로 인코딩해 이미지에 대한 요청을 없애는 기법입니다. * 코드 압축은 코드상의 개행 문자 같은 빈칸을 없애 크기를 최소화하는 방법입니다. </details><hr /><ul><li>HTTP/1.1은 1.0과 무슨 차이가 있는지 설명해주세요.</ul><details> <summary>답변</summary> 1. HTTP/1.1은 한번의 연결로 많은 요청을 처리할 수 있도록 하는 Keep-alive 옵션이 생겼습니다. 2. 또, 파이프 라이닝을 지원해 여러 개의 요청을 동시에 보낼 수 있도록 할 수 있습니다. 3. 기존의 GET, POST, HEAD 메서드에서 추가되어 PUT, DELETE, OPTION 등의 메서드가 추가되었습니다. </details><hr /><ul><li>HTTP/2.0에 대해 설명해주세요.</ul><details> <summary>답변</summary> 1. HTTP/2.0는 1.0보다 지연 시간을 줄이고 응답 시간을 빠르게 할 수 있도록 설계된 버전입니다. 2. 2.0의 장점으로는 멀티플렉싱, HPACK 방식의 헤더 압축, 서버 푸시 등이 있습니다. * 멀티플렉싱은 여러 개의 스트림을 사용해 패킷을 송수신 하는 것입니다. * HPACK은 허프만 코딩 알고리즘으로 헤더를 압축한 것을 말하는데, 중복되는 헤더를 그 횟수에 따라 다른 비트로 표현하는 것입니다. * 서버 푸시란, 한 번의 요청으로 관련된 자료를 같이 응답으로 주는 것입니다. 3. 단점으로는, TCP 상의 HOL Blocking을 해결하지 못했다는 것과, TCP와 TLS 사용으로 초기 연결 시간이 길다는 것입니다. </details><hr /><ul><li>HTTP/3.0에 대해 설명해주세요.</ul><details> <summary>답변</summary> 1. HTTP/3.0은 2.0까지 사용되어 왔던 TCP가 아닌, UDP 기반의 QUIC 프로토콜을 이용해 통신하는 버전입니다. 2. 3.0의 장점으로는 1-RTT 연결 설정, 스트림 식별자 사용, Connection ID 사용 등이 있습니다. * 3.0는 TLS 인증서를 내포한 QUIC 프로토콜로 연결을 설정하므로, 한 번의 RTT로 연결 설정이 완료됩니다. * 또, 스트림 식별자를 사용해 패킷 유실시에도 해당 패킷과 관련된 스트림만 멈춰 HOL Blocking을 해결합니다. * 그리고 IP 대신 Connection ID로 연결을 설정해, 네트워크 변경시에도 연결을 유지할 수 있습니다. 3. 단점으로는, QUIC은 패킷별로 암호화를 해 리소스 소모가 크다는 점, QUIC 폭주나 반사 공격 등 보안 취약점이 아직 존재한다는 점이 있습니다. </details><hr /><h2 id="참고-자료"><span class="mr-2">참고 자료</span><a href="#참고-자료" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><a href="https://it-mesung.tistory.com/146">[Network] HTTP 1.0 vs HTTP 1.1</a><li><a href="https://evan-moon.github.io/2019/10/08/what-is-http3/">HTTP/3는 왜 UDP를 선택한 것일까?</a><li><a href="https://www.hamadevelop.me/http3/">HTTP3, 사실 진짜로 바뀐건 TCP 였다.</a><li><div class="table-wrapper"><table><tbody><tr><td>[QUIC 폭주 DDoS 공격이란?<td>QUIC 폭주와 UDP 폭주](https://www.cloudflare.com/ko-kr/learning/ddos/what-is-a-quic-flood/)</table></div></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>CS</a>, <a href='/categories/network/'>Network</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cs/" class="post-tag no-text-decoration" >CS</a> <a href="/tags/network/" class="post-tag no-text-decoration" >Network</a> <a href="/tags/http/" class="post-tag no-text-decoration" >HTTP</a> <a href="/tags/https/" class="post-tag no-text-decoration" >HTTPS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5BCS%5D+HTTP+1.0+%EB%B6%80%ED%84%B0+3.0%EA%B9%8C%EC%A7%80%3A+HTTP+%EA%B7%9C%EC%95%BD%EC%9D%80+%EC%96%B4%EB%96%BB%EA%B2%8C+%EB%B3%80%ED%99%94%ED%95%B4+%EC%99%94%EB%82%98+-+TaemHam&url=https%3A%2F%2Ftaemham.github.io%2Fposts%2FCS_HTTP_history%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5BCS%5D+HTTP+1.0+%EB%B6%80%ED%84%B0+3.0%EA%B9%8C%EC%A7%80%3A+HTTP+%EA%B7%9C%EC%95%BD%EC%9D%80+%EC%96%B4%EB%96%BB%EA%B2%8C+%EB%B3%80%ED%99%94%ED%95%B4+%EC%99%94%EB%82%98+-+TaemHam&u=https%3A%2F%2Ftaemham.github.io%2Fposts%2FCS_HTTP_history%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Ftaemham.github.io%2Fposts%2FCS_HTTP_history%2F&text=%5BCS%5D+HTTP+1.0+%EB%B6%80%ED%84%B0+3.0%EA%B9%8C%EC%A7%80%3A+HTTP+%EA%B7%9C%EC%95%BD%EC%9D%80+%EC%96%B4%EB%96%BB%EA%B2%8C+%EB%B3%80%ED%99%94%ED%95%B4+%EC%99%94%EB%82%98+-+TaemHam" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Springboot_FetchJoin+Paging_Problem/">[Springboot] 페이징 + Fetch Join 쿼리로 OneToMany 할 때, 모든 엔티티를 불러오는 문제를 해결해보자</a><li><a href="/posts/CS_DatabaseBasic/">[CS] DB: DB란 무엇인가?</a><li><a href="/posts/CS_About_Process/">[CS] OS: 프로세스란?</a><li><a href="/posts/CS_MultiProcess/">[CS] OS: 멀티 프로세싱과 멀티 스레딩</a><li><a href="/posts/SpringBoot_AboutSpringSecurity/">[백엔드|스프링부트] 서버가 사용자를 인증하는 법 (JWT를 이용한 방법)</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backend/">Backend</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/tutorial/">Tutorial</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/db/">DB</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CS_HTTPvsHTTPS/"><div class="card-body"> <em class="small" data-ts="1676505600" data-df="YYYY-MM-DD" > 2023-02-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[CS] HTTP와 HTTPS: 메시지를 안전하게 보내는 방법</h3><div class="text-muted small"><p> 개요 지난 번에는 HTTP 프로토콜의 변천사에 대해 알아보면서, ‘어떻게 하면 더 빨리’ 메시지를 보내도록 바뀌었는지 그 과정을 알아보았다. 이번에는 ‘더 안전하게’ 메시지를 보내기 위해 나온 HTTPS에 대해, 더 정확히는 그 메시지를 보내는 과정에 무엇이 추가 되었고 어떻게 메시지를 보내는지에 대해 알아보고자 한다. HTTP HTTP(Hy...</p></div></div></a></div><div class="card"> <a href="/posts/CS_Network/"><div class="card-body"> <em class="small" data-ts="1675641600" data-df="YYYY-MM-DD" > 2023-02-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[CS] 네트워크의 기초</h3><div class="text-muted small"><p> 네트워크 네트워크는 두 대 이상의 장치들을 연결해 서로 리소스를 공유할 수 있는 집합을 지칭하는 용어다. 네트워크 장치들을 노드라고 하며, 유선 또는 무선 연결을 링크라고 한다. 좋은 네트워크의 기준은 많은 처리량을 처리할 수 있고, 지연시간이 짧고, 장애 빈도가 적으며, 좋은 보안을 갖추어야 한다. 기본 용어 정리 처리량 처리량(thro...</p></div></div></a></div><div class="card"> <a href="/posts/CS_TCPIP/"><div class="card-body"> <em class="small" data-ts="1675728000" data-df="YYYY-MM-DD" > 2023-02-07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[CS] TCP/IP: 인터넷에서 컴퓨터들이 정보를 주고 받을 때 쓰이는 프로토콜들에 대해 알아보자</h3><div class="text-muted small"><p> 개요 사람들과 마찬가지로, 컴퓨터들도 서로 의사소통 하기 위해 공통된 규칙이 있어야 한다. 컴퓨터가 사용하는 규칙을 프로토콜이라고 하며, 용도에 따라 나뉘면서 많은 프로토콜이 존재한다. 이런 많은 프로토콜에 대한 합의된 표준이 필요하게 되어 나오게 된게 TCP/IP 이다. TCP/IP는 보통 컴퓨터에 내장되어있고 대부분 알아서 동작하긴 하지만,...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/SpringBoot_AboutSpringSecurity/" class="btn btn-outline-primary" prompt="이전 글"><p>[백엔드|스프링부트] 서버가 사용자를 인증하는 법 (JWT를 이용한 방법)</p></a> <a href="/posts/CS_HTTPvsHTTPS/" class="btn btn-outline-primary" prompt="다음 글"><p>[CS] HTTP와 HTTPS: 메시지를 안전하게 보내는 방법</p></a></div><script src="https://utteranc.es/client.js" repo="TaemHam/Taemham.github.io" issue-term="pathname" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/TaemHam">TaemHam</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backend/">Backend</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/springboot/">SpringBoot</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/tutorial/">Tutorial</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/db/">DB</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
