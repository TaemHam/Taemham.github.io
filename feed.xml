<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://taemham.github.io/</id><title>TaemHam</title><subtitle>This is a wannabe backend developer's dev blog.</subtitle> <updated>2023-03-30T17:15:38+09:00</updated> <author> <name>TaemHam</name> <uri>https://taemham.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://taemham.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko-KR" href="https://taemham.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 TaemHam </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[Springboot] 페이징 + Fetch Join 쿼리로 OneToMany 할 때, 모든 엔티티를 불러오는 문제를 해결해보자</title><link href="https://taemham.github.io/posts/Springboot_FetchJoin+Paging_Problem/" rel="alternate" type="text/html" title="[Springboot] 페이징 + Fetch Join 쿼리로 OneToMany 할 때, 모든 엔티티를 불러오는 문제를 해결해보자" /><published>2023-03-30T12:00:00+09:00</published> <updated>2023-03-30T17:15:11+09:00</updated> <id>https://taemham.github.io/posts/Springboot_FetchJoin+Paging_Problem/</id> <content src="https://taemham.github.io/posts/Springboot_FetchJoin+Paging_Problem/" /> <author> <name>TaemHam</name> </author> <category term="Springboot" /> <category term="DB" /> <summary> 문제 상황 댓글이 일대다 매핑 된 게시글들을 페이지 단위로 불러오는 쿼리를 실행하면 OOM(메모리 초과) 문제가 발생하는 것을 확인했다. 문제가 되는 엔티티와 쿼리문은 다음과 같다. 게시글 엔티티 @Builder @Getter @AllArgsConstructor @NoArgsConstructor @Entity public class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id; @Column private String title; @Column private String content; @OneToMany(mappedBy = ... </summary> </entry> <entry><title>[CS] DB: 정규화란?</title><link href="https://taemham.github.io/posts/CS_DB_Normalization/" rel="alternate" type="text/html" title="[CS] DB: 정규화란?" /><published>2023-03-03T11:00:00+09:00</published> <updated>2023-03-03T11:00:00+09:00</updated> <id>https://taemham.github.io/posts/CS_DB_Normalization/</id> <content src="https://taemham.github.io/posts/CS_DB_Normalization/" /> <author> <name>TaemHam</name> </author> <category term="CS" /> <category term="DB" /> <summary> 정규화 정규화란, 관계형 데이터베이스의 설계에서 중복을 최소화하고, 독립적인 관계를 가진 속성을 분리시켜 데이터를 구조화하는 작업을 말한다. 정규화의 기본 목표는 관련이 없는 함수 종속성은 별개의 릴레이션으로 표현하는 것이다. 함수적 종속이란, 어떤 릴레이션 R의 속성 X와 Y에 대해, X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, Y는 X에 함수적 종속이라고 한다. 학번을 알면 학생의 이름을 알 수 있는 것. 정규형 제1정규형 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(Atomic value)만으로 구성되어 있어 반복 그룹이 없는 상태를 말한다. 즉, 하나의 기본키에 두 개 이상의 값을 가지는 속성 집합이 있어서는 안된다는 것... </summary> </entry> <entry><title>[CS] DB: 키의 종류</title><link href="https://taemham.github.io/posts/CS_About_Key/" rel="alternate" type="text/html" title="[CS] DB: 키의 종류" /><published>2023-03-02T09:00:00+09:00</published> <updated>2023-03-02T09:00:00+09:00</updated> <id>https://taemham.github.io/posts/CS_About_Key/</id> <content src="https://taemham.github.io/posts/CS_About_Key/" /> <author> <name>TaemHam</name> </author> <category term="CS" /> <category term="DB" /> <summary> 키 데이터베이스에서 키란, 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플과 구별할 수 있는 유일한 기준이 되는 속성(Attribute)이다. 종류 키의 종류에는 5가지가 있다. 후보키 (Candidate key) 릴레이션(테이블)에서 각 튜플을 유일하게 식별할 수 있는 속성 또는 집합을 말한다. 후보키가 되려면 유일성과 최소성을 모두 만족해야 한다. 기본키 (Primary key) 기본키는 후보키 중에서 행을 식별하기 위해 특별히 선택된 키를 말한다. 기본키는 중복될 수 없으며, NULL값이 올 수 없다. 유일성과 최소성을 만족해야 한다. 기본키는 ... </summary> </entry> <entry><title>[CS] DB: DB란 무엇인가?</title><link href="https://taemham.github.io/posts/CS_DatabaseBasic/" rel="alternate" type="text/html" title="[CS] DB: DB란 무엇인가?" /><published>2023-02-25T09:00:00+09:00</published> <updated>2023-03-02T08:49:26+09:00</updated> <id>https://taemham.github.io/posts/CS_DatabaseBasic/</id> <content src="https://taemham.github.io/posts/CS_DatabaseBasic/" /> <author> <name>TaemHam</name> </author> <category term="CS" /> <category term="DB" /> <summary> 데이터베이스 데이터베이스란, 일정한 규칙 혹은 규약을 통해 구조화 되어 저장되는 데이터의 모음이다. 그런 데이터를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)라고 하며, 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다. 또, 데이터베이스는 실시간 접근과 동시 공유가 가능하다. 기초 용어 엔티티 엔티티(Entity)는 사람, 장소, 물건 등 데이터베이스에서 관리 되는 여러 개의 속성을 지닌 명사를 의미한다. 예를 들어, 회원이라는 엔티티는 이름, 아이디, 주소, 전화번호 등의 속성이 있고, 이 중 서비스의 요구사항에 맞게 필요햔 것만 남고 나머지는 사라진다. 엔티티는... </summary> </entry> <entry><title>[CS] OS: CPU 스케줄링 알고리즘</title><link href="https://taemham.github.io/posts/CS_CpuScheduler/" rel="alternate" type="text/html" title="[CS] OS: CPU 스케줄링 알고리즘" /><published>2023-02-24T09:00:00+09:00</published> <updated>2023-02-24T09:00:00+09:00</updated> <id>https://taemham.github.io/posts/CS_CpuScheduler/</id> <content src="https://taemham.github.io/posts/CS_CpuScheduler/" /> <author> <name>TaemHam</name> </author> <category term="CS" /> <category term="OS" /> <summary> CPU 스케줄링 알고리즘 CPU 스케줄러는 레디 큐에 존재하는 프로세스들을 특정한 우선순위를 기반으로 CPU를 할당받게 해주는 역할을 한다. 스케줄링 알고리즘 프로그램이 실행될 때 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄 것인지 결정한다. 이 알고리즘은 다음과 같은 항목들을 목표로 한다. CPU 이용률: CPU를 얼마나 잘 활용했는지 처리량: 단위시간 당 완료된 프로세스의 개수가 몇 개인지 총 처리 시간: 어떤 프로세스를 실행하는데 걸리는 시간이 얼마나 짧은지 대기 시간: 레디 큐에서 대기한 시간이 얼마나 짧은지 응답 시간: 시스템에 요청이 들어온 시간부터 첫 번째 응답이 발생하기까지의 시간이 얼마나 짧은지 종류는 크게 두 가지로 나뉜다. ... </summary> </entry> </feed>
